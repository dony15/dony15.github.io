<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DonY15</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-06T10:32:05.837Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>宝全哥哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FastDFS 基础原理</title>
    <link href="http://yoursite.com/2018/07/06/FastDfs%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/06/FastDfs基础原理/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-07-06T10:32:05.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FastDFS-基础原理"><a href="#FastDFS-基础原理" class="headerlink" title="FastDFS 基础原理"></a>FastDFS 基础原理</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>Depth First Search </p><p><strong>无向图算法概念</strong>(一种递归原理)</p><p>先按照一条边进行搜索,当遇到第一个节点时,对它相邻的其他节点进行搜索并标记为已查找的节点(会查找完第一条节点的最深层后返回)<br>详细见算法目录(持续更新)</p><p><img src="http://i.imgur.com/vJ23ZgT.jpg" alt="&quot;无向图算法图片&quot;的图片搜索结果"></p><h3 id="FastDFS–结构"><a href="#FastDFS–结构" class="headerlink" title="FastDFS–结构"></a>FastDFS–结构</h3><h2 id="1">FastDFS 架构–结构</h2><p><strong>FastDFS服务有三个角色:跟踪服务器(tracker server)、存储服务器(storage server)和客户端(client)</strong></p><p>主要解决了海量数据存储问题 ,特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。 </p><h4 id="跟踪器Tracker"><a href="#跟踪器Tracker" class="headerlink" title="跟踪器Tracker :"></a>跟踪器Tracker :</h4><p>主要做调度工作，相当于mvc中的controller的角色，在访问上起负载均衡的作用。跟踪器和存储节点都可以由一台或多台服务器构成，跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务，其中<strong>跟踪器</strong>中的所有服务器都是<strong>对等</strong>的，可以根据服务器的压力情况随时增加或减少。 </p><p>跟踪器Tracker负责管理所有的Storage和group，本身不需要持久化任何数据,直接增加机器就可以拓展tracker,每个Storage在启动后会连接Tracker，并周期性保持联系.</p><h4 id="存储服务器Storage"><a href="#存储服务器Storage" class="headerlink" title="存储服务器Storage:"></a>存储服务器Storage:</h4><p>以group为最小单位,方便实现 应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数）,建议同一group内的配置尽量相同,减少资源浪费(storage依赖于本地文件系统)</p><h4 id="客户端Client"><a href="#客户端Client" class="headerlink" title="客户端Client:"></a>客户端Client:</h4><p><strong>基本文件访问接口:</strong>比如upload、download、append、delete等，以客户端库的方式提供给用户使用。 </p><h3 id="FastDFS–运行"><a href="#FastDFS–运行" class="headerlink" title="FastDFS–运行"></a>FastDFS–运行</h3><p><strong>tracker</strong></p><p>当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个trakcer。</p><p><strong>group</strong></p><p>当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group，支持如下选择group的规则：</p><ol><li>Round robin，所有的group间轮询 </li><li>Specified group，指定某一个确定的group </li><li>Load balance，剩余存储空间多多group优先</li></ol><p><strong>storage</strong></p><p>当选定group后，tracker会在group内选择一个storage server给客户端，支持如下选择storage的规则： </p><ol><li>Round robin，在group内的所有storage间轮询 </li><li>First server ordered by ip，按ip排序 </li><li>First server ordered by priority，按优先级排序（优先级在storage上配置）</li></ol><p><strong>storage path</strong></p><p>当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录，支持如下规则： </p><ol><li>Round robin，多个存储目录间轮询 </li><li>剩余存储空间最多的优先</li></ol><p><strong>Fileid</strong></p><p>选定存储目录之后，storage会为文件生一个Fileid，<br>由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，<br>然后将这个二进制串进行base64编码，转换为可打印的字符串。</p><p><strong>选择两级目录</strong></p><p>当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash（猜测），路由到其中一个子目录，然后将文件以fileid为文件名存储到该子目录下。</p><p><strong>生成文件名</strong> </p><p>当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。</p><p><strong>文件同步</strong></p><p>写文件时，客户端将文件写至group内一个storage server即认为写文件成功，<br>storage server写完文件后，会由后台线程将文件同步至 [同group] 内其他的storage server。<br>storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。</p><p><strong>Download file</strong></p><p>客户端upload file成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。</p><h3 id="FastDFS–特点"><a href="#FastDFS–特点" class="headerlink" title="FastDFS–特点"></a>FastDFS–特点</h3><h4 id="小文件合并存储"><a href="#小文件合并存储" class="headerlink" title="小文件合并存储"></a>小文件合并存储</h4><p><strong>解决问题:</strong></p><ol><li>本地文件系统inode数量有限，从而存储的小文件数量也就受到限制。 </li><li>多级目录+目录里很多文件，导致访问文件的开销很大（可能导致很多次IO） </li><li>按小文件存储，备份与恢复的效率低</li></ol><p>FastDFS在V3.0版本里引入小文件合并存储的机制，可将多个小文件存储到一个大的文件（trunk file），为了支持这个机制，FastDFS生成的文件fileid需要额外增加16个字节 </p><h4 id="HTTP访问支持"><a href="#HTTP访问支持" class="headerlink" title="HTTP访问支持"></a>HTTP访问支持</h4><p>客户端可以通过http协议来下载文件，tracker在接收到请求时，通过http的redirect机制将请求[重定向]至文件所在的storage上；除了内置的http协议外，FastDFS还提供了通过apache或nginx扩展模块下载文件的支持。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>group机制本身可用来做负载均衡，但这只是一种静态的负载均衡机制，需要预先知道应用的访问特性；同时group机制也导致不可能在group之间迁移数据来做动态负载均衡。</p><h3 id="FastDFS–使用小结"><a href="#FastDFS–使用小结" class="headerlink" title="FastDFS–使用小结"></a>FastDFS–使用小结</h3><p>1.每次上传文件后都会返回一个地址，用户需要自己保存此地址。<br>2.为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。</p><h3 id="FastDFS原理系列文章-转发"><a href="#FastDFS原理系列文章-转发" class="headerlink" title="FastDFS原理系列文章(转发)"></a>FastDFS原理系列文章(转发)</h3><p><strong><a href="https://blog.csdn.net/hfty290/article/details/42076205" target="_blank" rel="noopener">https://blog.csdn.net/hfty290/article/details/42076205</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FastDFS-基础原理&quot;&gt;&lt;a href=&quot;#FastDFS-基础原理&quot; class=&quot;headerlink&quot; title=&quot;FastDFS 基础原理&quot;&gt;&lt;/a&gt;FastDFS 基础原理&lt;/h2&gt;&lt;h3 id=&quot;深度优先搜索&quot;&gt;&lt;a href=&quot;#深度优先搜索&quot;
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Shiro基础原理</title>
    <link href="http://yoursite.com/2018/07/04/Shiro%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/04/Shiro基础原理/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-06T13:31:33.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shiro基础原理"><a href="#Shiro基础原理" class="headerlink" title="Shiro基础原理"></a>Shiro基础原理</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><strong>shiro是apache的一个开源框架，实现 |认证|授权|为核心的一系列权限管理框架.</strong></p><ul><li>Web 应用程序一般做法通过表单提交用户名及密码达到认证目的。 </li><li>“授权”即是否允许已认证用户访问受保护资源。 </li></ul><h3 id="2-对比"><a href="#2-对比" class="headerlink" title="2.对比"></a>2.对比</h3><p><strong>Shiro与Spring Security</strong></p><ol><li>简单性:shiro更加简单,更容易理解</li><li>灵活性:shiro可以使用在 |Web|EJB|IoC| 等大部分的应用环境,而Spring Security必须和Spring一起集成使用</li><li>拔插性:shiro干净的API(工具类集合)和设计模式(单例+工厂)使它可以方便的和许多其他框架整合,Spring Security则只能与Spring一起集成</li></ol><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成"></a>3.组成</h3><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/1b7bc2c3-9f2c-4ea2-8ed7-97820c205482/128/index_files/871676-20160722213407794-1894786938.png" alt="img"></p><p><strong>三个核心组件</strong>    </p><ol><li>Subject: 令牌与项目的登录关系,Shiro保证了项目整体的安全性,是<strong>Shiro对外API的核心</strong></li><li>Security Manager:负责安全认证预授权等  <strong>Shiro的核心</strong> </li><li>Realm:整个框架中<strong>必须</strong>由设计者自行实现的模块之一.并且Shiro支持多个<strong>Realm数据源</strong>,最为重要的一种实现方式—&gt;数据库查询,当需要多个数据库组合验证时,多个数据源的效果就体现出来</li></ol><hr><ol><li>Authentication:    身份认证</li><li>Authorization:  授权,权限验证</li><li>Session Manager: 会话管理</li><li>Cryptography:加密</li><li>Web Support: web支持</li><li>Caching:缓存</li><li>Concurrency:多线程验证</li><li>Testing:提供测试支持</li><li>Run As:允许一个用户假装另一个用户访问</li><li>Remember Me: 记住我</li></ol><hr><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/b9f81ac7-ad34-4adc-b4c2-cb2f73a4f2dd/128/index_files/48cae49c-8924-4a4e-8efd-bdbf38f07c97.jpg" alt="img">    </p><ol><li><strong>注意:Shiro不会自己维护用户|权限;</strong></li><li><strong>需要开发者去 设计|提供 ;</strong></li><li><strong>然后通过接口注入给Shiro即可</strong></li></ol><h3 id="4-源码"><a href="#4-源码" class="headerlink" title="4.源码"></a>4.源码</h3><h4 id="Token认证"><a href="#Token认证" class="headerlink" title="Token认证"></a>Token认证</h4><p><strong>JdbcRealm</strong></p><p>Shiro –&gt;JdbcRealm封装的固定sql</p><p> [1.封装根据用户名查询密码的SQL语句]</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The default query used to retrieve account data for the user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AUTHENTICATION_QUERY = <span class="string">"select password from users where username = ?"</span>;</span><br></pre></td></tr></table></figure><pre><code>[2.盐加密&amp;&amp;authenticationQuery验证查询(判断)] </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the salt style.  See &#123;<span class="doctag">@link</span> #saltStyle&#125;.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> saltStyle new SaltStyle to set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSaltStyle</span><span class="params">(SaltStyle saltStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.saltStyle = saltStyle;</span><br><span class="line">        <span class="keyword">if</span> (saltStyle == SaltStyle.COLUMN &amp;&amp; authenticationQuery.equals(DEFAULT_AUTHENTICATION_QUERY)) &#123;</span><br><span class="line">            authenticationQuery = DEFAULT_SALTED_AUTHENTICATION_QUERY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  [3.发现源代码中使用预编译的原生JDBC,并根据索引查找对比,所以要求自定义语句时不能乱写,根据规则走] </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ps = conn.prepareStatement(authenticationQuery);</span><br><span class="line">            ps.setString(1, username);</span><br><span class="line"></span><br><span class="line">            // Execute query</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            // Loop over results - although we are only expecting one result, since usernames should be unique</span><br><span class="line">            boolean foundResult = false;</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">                // Check to ensure only one row is processed</span><br><span class="line">                if (foundResult) &#123;</span><br><span class="line">                    throw new AuthenticationException(&quot;More than one user row found for user [&quot; + username + &quot;]. Usernames must be unique.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                result[0] = rs.getString(1);     //索引查询</span><br><span class="line">                if (returningSeparatedSalt) &#123;</span><br><span class="line">                    result[1] = rs.getString(2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                foundResult = true;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>new SimpleAuthenticationInfo()(存放唯一认证) 源码分析</strong></p><p>principal: 整个Shiro中唯一的标识符,可以存用户名,也可以存ID</p><p>credentials: 唯一标识符的密码</p><p>realmName: 当前数据源的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAuthenticationInfo</span><span class="params">(Object principal, Object credentials, String realmName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.principals = <span class="keyword">new</span> SimplePrincipalCollection(principal, realmName);</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\Desktop\20180122131153906.png" alt="20180122131153906"></p><p>使用了工厂模式来对SecurityManager进行生成和配置  </p><p>生成过程是使用<strong>单例+工厂</strong> </p><p>提供对外的<strong>工具类</strong>来使用，包含获取SecurityManager的方法和获取Subject的方法  </p><p><img src="C:\Users\Administrator\Desktop\3.png" alt="3"></p><p>(代码略)</p><p>subject的使用是通过传入AuthenticationToken接口（注意是接口，其实扩展接口rememnverMeaut…和HostAutho…），</p><p>该接口目前的实现类是UserPasswordToken，当然也可以自己扩展实现自定义的认证Token </p><h4 id="测试加密算法"><a href="#测试加密算法" class="headerlink" title="测试加密算法"></a>测试加密算法</h4><p><strong>盐值加密如果几个人密码一样，那么加密后的密码则一致。这样不安全，要解决这个问题，可以在密码上加盐。一般会选择不重复的值作为盐值，例如 用户名。</strong>(部分代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">        <span class="comment">//第一个参数：散列算法</span></span><br><span class="line">        <span class="comment">//第二个参数：明文，原始密码</span></span><br><span class="line">        <span class="comment">//第三个参数：盐，通过使用随机数</span></span><br><span class="line">        <span class="comment">//第四个参数：散列的次数，比如散列两次，相当 于md5(md5(''))</span></span><br><span class="line">        SimpleHash simpleHash = <span class="keyword">new</span> SimpleHash(<span class="string">"md5"</span>, source, salt, hashIterations);</span><br><span class="line">        String md5 =  simpleHash.toString();</span><br><span class="line">        System.out.println(md5);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shiro-realm-md5.ini</span><br><span class="line">---------------------</span><br><span class="line">[main]</span><br><span class="line">定义凭证匹配器</span><br><span class="line">credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line">散列算法</span><br><span class="line">credentialsMatcher.hashAlgorithmName=md5</span><br><span class="line">散列次数</span><br><span class="line">credentialsMatcher.hashIterations=<span class="number">1024</span></span><br><span class="line">开启加盐（无需设置，realm中使用的SimpleAuthenticationInfo 是 SaltedAuthenticationInfo 接口的实现类，默认开启的加盐功能）</span><br><span class="line">credentialsMatcher.hashSalted=<span class="keyword">true</span></span><br><span class="line">自定义 realm</span><br><span class="line">customRealm=com.qfedu.shirodemo.realm.CustomRealmMd5</span><br><span class="line">customRealm.credentialsMatcher=$credentialsMatcher</span><br><span class="line">将realm设置到securityManager，相当 于spring中注入</span><br><span class="line">securityManager.realms=$customRealm</span><br></pre></td></tr></table></figure><h4 id="授权流程原理"><a href="#授权流程原理" class="headerlink" title="授权流程原理"></a>授权流程原理</h4><p><strong>授权</strong></p><p>授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</p><p><strong>主体（Subject）</strong></p><p>主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。</p><p><strong>资源</strong></p><p>在应用中用户可以访问的任何东西，比如JSP 页面、某些数据、某个业务方法等等都是资源。用户只要授权后才能访问。</p><p><strong>权限</strong></p><p>权限表示在应用中用户能不能访问某个资源，</p><p>如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）打印文档等等。。。</p><p><strong>角色</strong></p><p>角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。</p><p>典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。</p><h5 id="判断是否授权的方式"><a href="#判断是否授权的方式" class="headerlink" title="判断是否授权的方式"></a>判断是否授权的方式</h5><p>Shiro 支持三种方式的授权判断：</p><p><strong>编程式</strong></p><p>通过写if/else 授权代码块完成：</p><p>Subject subject = SecurityUtils.getSubject();</p><p>if(subject.hasRole(“admin”)) {</p><p>​      //有权限</p><p>} else {</p><p>​     //无权限</p><p>}</p><p><strong>注解式</strong></p><p>通过在执行的Java方法上放置相应的注解完成：</p><p>@RequiresRoles(“admin”)</p><p>public void hello() {</p><p>   //有权限</p><p>}</p><p>没有权限将抛出相应的异常；</p><p><strong>JSP 标签</strong></p><p>在JSP 页面通过相应的标签完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!— 有权限—&gt;</span><br><span class="line"></span><br><span class="line">&lt; /shiro:hasRole &gt;</span><br></pre></td></tr></table></figure><h5 id="自定义realm授权"><a href="#自定义realm授权" class="headerlink" title="自定义realm授权"></a>自定义realm授权</h5><p><strong>从认证的realm拷贝，改变继承的抽象父类，添加新的方法</strong></p><h3 id="5-程序分析"><a href="#5-程序分析" class="headerlink" title="5.程序分析"></a>5.程序分析</h3><p><strong>程序分析：从应用程序角度的来观察如何使用Shiro完成工作</strong> </p><ol><li>应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager； </li><li>我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</li><li>可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject； </li></ol><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/e66c475a-c763-4097-85a0-b0219938fe7f/128/index_files/4a5f51ff-ef16-4a61-a834-9a9b06da850b.jpg" alt="img"></p><p><strong>Shiro内部结构</strong></p><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/1b7bc2c3-9f2c-4ea2-8ed7-97820c205482/128/index_files/9b959a65-799d-396e-b5f5-b4fcfe88f53c.png" alt="img"></p><p><strong>详细原理深入和运用:<a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/2018398</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shiro基础原理&quot;&gt;&lt;a href=&quot;#Shiro基础原理&quot; class=&quot;headerlink&quot; title=&quot;Shiro基础原理&quot;&gt;&lt;/a&gt;Shiro基础原理&lt;/h2&gt;&lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/07/03/hello-world/"/>
    <id>http://yoursite.com/2018/07/03/hello-world/</id>
    <published>2018-07-03T15:51:12.163Z</published>
    <updated>2018-07-05T12:34:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
