<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DonY15</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-10T23:58:23.218Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>宝全哥哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工具类集合分析--接口</title>
    <link href="http://yoursite.com/2018/07/08/%E5%B7%A5%E5%85%B7%E7%B1%BB%E9%9B%86%E5%90%88%E5%88%86%E6%9E%90--%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/07/08/工具类集合分析--接口/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-10T23:58:23.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具类集合分析–接口"><a href="#工具类集合分析–接口" class="headerlink" title="工具类集合分析–接口"></a>工具类集合分析–接口</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>使用接口作为工具类,一般分两种情况</p><p>​    (1)定义常量</p><p>​    (2)定义动态工具类</p><h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h4><h5 id="1-定义常量"><a href="#1-定义常量" class="headerlink" title="1.定义常量"></a>1.定义常量</h5><p>可以在工具类中快捷明了的定义常量来使用,因为接口中默认属性便是常量,如:</p><p>​    int HOTEL_STATUS_INVALID=0;//酒店失效</p><p>​    int HOTEL_STATUS_VALID=1;//酒店有效</p><p>当controller中往前端传递数据时,需要判断状态,而状态从controller中多次定义会导致观察不变,不利于交接和后期维护,此时便可以将状态抽出来存进接口工具类中,提高代码的<strong>可读性</strong>和<strong>开发效率</strong> (RestFull开发风格中,提高代码可读性尤为突出)</p><h5 id="2-定义动态工具类"><a href="#2-定义动态工具类" class="headerlink" title="2.定义动态工具类"></a>2.定义动态工具类</h5><p>当程序运行在不同的环境中时,因为程序对环境的耦合性,频繁的修改代码会大大降低开发效率,可以使用工具类接口的方式,将耦合性降低,如<strong>动态工具类</strong></p><p><strong>场景</strong></p><p>​    redis 单机版和集群版    (可以根据需要选择具体的方案,减少代码的修改量)</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;工具类集合分析–接口&quot;&gt;&lt;a href=&quot;#工具类集合分析–接口&quot; class=&quot;headerlink&quot; title=&quot;工具类集合分析–接口&quot;&gt;&lt;/a&gt;工具类集合分析–接口&lt;/h3&gt;&lt;h4 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;head
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper与Dubbo基础原理</title>
    <link href="http://yoursite.com/2018/07/08/Zookeeper%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/08/Zookeeper基础原理/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-07T16:28:18.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Zookeeper与Dubbo基础原理"><a href="#Zookeeper与Dubbo基础原理" class="headerlink" title="Zookeeper与Dubbo基础原理"></a>Zookeeper与Dubbo基础原理</h3><h4 id="Zookeeper-RPC框架"><a href="#Zookeeper-RPC框架" class="headerlink" title="Zookeeper(RPC框架)"></a>Zookeeper(RPC框架)</h4><p><strong>高效的分布式分布式应用协调服务,提供注册和负载均衡等–&gt;服务中心</strong></p><ul><li>zookeeper让调用者知道调用的哪台服务器地址,也是集群的管理者</li><li>Zookeeper具有心跳检测机制,当服务器挂掉时可以让调用者知道,从而切换请求服务器</li><li>Zookeeper具有高并发的横向扩展,在不改变代码的情况下对设备进行扩展</li></ul><p><strong>1.命名服务   2.配置管理   3.集群管理   4.分布式锁  5.队列管理</strong> </p><p>命名服务:在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现。 </p><p>配置管理:程序分散部署在多台机器上难以管理,可以将每台设备的信息存储在Zookeeper的目录节点中,然后相关程序对该目录进行监控,如果配置信息发生变化,则Zookeeper会发布新的配置</p><p>集群管理:(1)设备的加入(2)选举master(可以改变设备编号,编号第一位自动master(一种思路))</p><p>分布式锁:zookeeper是一致性的文件系统,锁服务可以分为两类，(1)保持独占，(2)控制时序。  </p><p>列队管理:</p><ol><li>同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。  </li><li>队列按照 FIFO 方式进行入队和出队操作。和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。   </li></ol><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ol><li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper<strong>最重要的性能</strong>。 </li><li>可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。 </li><li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。  </li><li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。  </li><li>原子性：更新只能成功或者失败，没有中间状态。  </li><li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。  </li></ol><h5 id="Zookeeper工作原理"><a href="#Zookeeper工作原理" class="headerlink" title="Zookeeper工作原理"></a>Zookeeper工作原理</h5><p>​    Zookeeper 的核心是<strong>原子广播</strong>，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做<strong>Zab协议</strong>。Zab协议有两种模式，它们分别是<strong>恢复模式</strong>（选主）和<strong>广播模式</strong>（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态 </p><p>​    为了保证事务的<strong>顺序一致性</strong>，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。 </p><p><strong>(部分整理)</strong></p><p><strong>原文:<a href="https://blog.csdn.net/xqb_756148978/article/details/52259381" target="_blank" rel="noopener">https://blog.csdn.net/xqb_756148978/article/details/52259381</a></strong></p><h4 id="Dubbo-SOA基础框架"><a href="#Dubbo-SOA基础框架" class="headerlink" title="Dubbo(SOA基础框架)"></a>Dubbo(SOA基础框架)</h4><p><strong>管理中间层的框架,与注册中心搭配使用,如Zookeeper(最常用),使之具有Zookeeper负载均衡/资源同步等的特性</strong></p><p><strong>单一应用架构</strong>(ORM) –&gt;<strong>垂直应用架构</strong>(MVC)–&gt;<strong>分布式服务架构</strong>(RPC)–&gt;<strong>流动计算架构</strong>(SOA) </p><h5 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h5><ol><li>远程通讯 </li><li>集群容错 </li><li>自动发现 </li></ol><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li><strong>透明化的远程方法调用</strong>，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入   </li><li><strong>软负载均衡及容错机制</strong>，可在内网替代F5等硬件负载均衡器，降低成本，减少单点.</li><li><strong>服务自动注册与发现</strong>，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ol><p>Dubbo采用全spring配置方式,透明化接入,应用,没有API入侵</p><h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><p><img src="https://i.imgur.com/zNpr0bk.jpg" alt=""></p><pre><code>Provider: 暴露服务的服务提供方。</code></pre><p>​       Consumer: 调用远程服务的服务消费方。</p><p>​       Registry: 服务注册与发现的注册中心。</p><p>​       Monitor: 统计服务的调用次调和调用时间的监控中心.</p><p>​    Container]: 服务运行器。</p><h5 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a>调用关系说明：</h5><ol start="0"><li><p>服务容器负责启动，加载，运行服务提供者。</p></li><li><p>服务提供者在启动时，向注册中心注册自己提供的服务。</p></li><li><p>服务消费者在启动时，向注册中心订阅自己所需的服务。</p></li><li><p>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p></li><li><p>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p></li><li><p>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p></li></ol><p><strong>收藏Dubbo架构详解<a href="http://shiyanjun.cn/archives/325.html" target="_blank" rel="noopener">http://shiyanjun.cn/archives/325.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Zookeeper与Dubbo基础原理&quot;&gt;&lt;a href=&quot;#Zookeeper与Dubbo基础原理&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper与Dubbo基础原理&quot;&gt;&lt;/a&gt;Zookeeper与Dubbo基础原理&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>基础排序 组合</title>
    <link href="http://yoursite.com/2018/07/08/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%20%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2018/07/08/基础排序 组合/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-09T15:35:26.541Z</updated>
    
    <content type="html"><![CDATA[<p><strong>规范:()中,先写下,在写上</strong></p><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><p>转换为计算机写法<strong>A(n,m)</strong>     n在下  m在上</p><p>​    即:n个数中取m个来排序</p><h3 id="2-组合"><a href="#2-组合" class="headerlink" title="2.组合"></a>2.组合</h3><p>转换为计算机写法<strong>C(n,m)</strong>    n在下 m在上</p><p>​    即: 分子:n的阶乘,阶乘的个数为m</p><p>​          分母:m的阶乘</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;规范:()中,先写下,在写上&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-排序&quot;&gt;&lt;a href=&quot;#1-排序&quot; class=&quot;headerlink&quot; title=&quot;1.排序&quot;&gt;&lt;/a&gt;1.排序&lt;/h3&gt;&lt;p&gt;转换为计算机写法&lt;strong&gt;A(n,m)&lt;
      
    
    </summary>
    
      <category term="初等数学" scheme="http://yoursite.com/categories/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>实用工具类集合</title>
    <link href="http://yoursite.com/2018/07/08/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2018/07/08/实用工具类集合/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-11T00:47:19.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实用工具类集合"><a href="#实用工具类集合" class="headerlink" title="实用工具类集合"></a>实用工具类集合</h3><p><strong>简述</strong></p><p>该工具类集合章会持续更新,具体工具类会集成到我的GitHub仓库中</p><p><strong>传送门</strong></p><p><strong><a href="https://github.com/dony15/mymodes" target="_blank" rel="noopener">https://github.com/dony15/mymodes</a></strong></p><h4 id="1-js-utils-js"><a href="#1-js-utils-js" class="headerlink" title="1.js-utils.js"></a>1.js-utils.js</h4><p>常用js的前段封装</p><ol><li><p>XMLHttpRequest 原生ajax的获取 ,内置了Chrome和IE的兼容转换</p></li><li><p>图片上传功能前段,四个id解决 | 图片 | 表单 | 回显 | 的结合</p></li><li><p>验证码显示和输入框校验 两个id 一个url 即可解决 | 校验 | 提示 | 提交url |的结合</p></li><li><p>点击切换验证码 id和url </p></li></ol><h4 id="2-pattern-js"><a href="#2-pattern-js" class="headerlink" title="2.pattern.js"></a>2.pattern.js</h4><p>包含开发中各种验证常用的正则封装</p><h4 id="2-CollectionsFactory"><a href="#2-CollectionsFactory" class="headerlink" title="2.CollectionsFactory"></a>2.CollectionsFactory</h4><p>包含各种集合类型的构建,静态工具类,使代码看起来更加<strong>规范简洁</strong></p><h4 id="3-DownloadUtil"><a href="#3-DownloadUtil" class="headerlink" title="3.DownloadUtil"></a>3.DownloadUtil</h4><p>文件下载工具类,根据文件名或者文件路径获取文件进行下载(多场景的封装)</p><h4 id="3-FileUtil"><a href="#3-FileUtil" class="headerlink" title="3.FileUtil"></a>3.FileUtil</h4><p>非常实用的文件处理工具,如获取文件名/去重/清空但不删除文件夹/磁盘遍历/xml生成等等…</p><h4 id="4-FormatStyle"><a href="#4-FormatStyle" class="headerlink" title="4.FormatStyle"></a>4.FormatStyle</h4><p>文件容量单位的格式转换,主要解决特殊情况下<strong>因为数字太大导致java直接写无法识别的</strong></p><h4 id="5-IDUtils"><a href="#5-IDUtils" class="headerlink" title="5.IDUtils"></a>5.IDUtils</h4><p>ID的多种生成策略</p><h4 id="5-JsonUtils"><a href="#5-JsonUtils" class="headerlink" title="5.JsonUtils"></a>5.JsonUtils</h4><p>使用jackson,多种类型和json的转化封装 <strong>对象 | List</strong></p><h4 id="6-ResourcesUtil"><a href="#6-ResourcesUtil" class="headerlink" title="6.ResourcesUtil"></a>6.ResourcesUtil</h4><p>资源读取工具类,较为特殊,使用较少(主要是国际语言的匹配读取,现在前段控制即可)</p><h4 id="7-UtilFuns"><a href="#7-UtilFuns" class="headerlink" title="7.UtilFuns"></a>7.UtilFuns</h4><p>该工具类非常的丰富.各种SE的基础转换和时间/固定长度转换/编码解码等都有涉猎</p><h4 id="其他中文命名工具类不再解释-简单明了"><a href="#其他中文命名工具类不再解释-简单明了" class="headerlink" title="其他中文命名工具类不再解释(简单明了)"></a>其他中文命名工具类不再解释(简单明了)</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实用工具类集合&quot;&gt;&lt;a href=&quot;#实用工具类集合&quot; class=&quot;headerlink&quot; title=&quot;实用工具类集合&quot;&gt;&lt;/a&gt;实用工具类集合&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该工具类集合章会持续更新,具体工具类会集成到我
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>ActiveMQ基础与运用</title>
    <link href="http://yoursite.com/2018/07/06/activeMQ%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%90%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/06/activeMQ基础与运用/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-07-10T10:51:43.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ActiveMQ基础与运用"><a href="#ActiveMQ基础与运用" class="headerlink" title="ActiveMQ基础与运用"></a>ActiveMQ基础与运用</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>消息队列:<strong>即时消息通信</strong>和<strong>延时消息通信</strong></p><p>ActiveMQ底层基于java的JMS实现,在没有JMS之前的系统存在很多缺陷:</p><ol><li>前后端同步问题,如果后台没有响应,则前段会一直阻塞等待</li><li>前后端生命周期耦合性太强,一方崩了则另一方也会崩</li><li>点对点通信,前段一次只能发送给某一个单独的服务对象,无法群发</li></ol><p><strong>JMS:</strong> (Java Message Service ) 通过消息中间件(MOM：Message Oriented Middleware )</p><p>将消息发送给单独的消息服务器中,消息服务器会将消息存放在若干的队列/主题中,在合适的时候将消息发送给接收者.<strong>发送和接收是异步的,无需阻塞等待</strong> 在pub/sub的模式下,可以将消息发送给多个接收者</p><p><strong>JMS类中定义了java访问中间件的接口,除此之外都是异常定义</strong></p><ol><li>Provider/MessageProvider：生产者 </li><li>Consumer/MessageConsumer：消费者 </li><li>PTP：Point To Point，点对点通信消息模型 </li><li>Pub/Sub：Publish/Subscribe，发布订阅消息模型 </li><li><strong>Queue</strong>：队列，目标类型之一，和PTP结合 </li><li><strong>Topic</strong>：主题，目标类型之一，和Pub/Sub结合 </li><li>ConnectionFactory：连接工厂，JMS用它创建连接 </li><li>Connnection：JMS Client到JMS Provider的连接 </li><li>Destination：消息目的地，由Session创建 </li><li><strong>Session</strong>：会话，由Connection创建，实质上就是发送、接受消息的一个线程，因此生产者、消费者都是Session创建的 </li></ol><h4 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h4><p><strong>| 异步处理 | 应用解耦 | 流量削锋 | 消息通讯 |</strong></p><p><strong>详情参考:<a href="https://blog.csdn.net/kingcat666/article/details/78660535" target="_blank" rel="noopener">https://blog.csdn.net/kingcat666/article/details/78660535</a></strong></p><h4 id="3-消息模式"><a href="#3-消息模式" class="headerlink" title="3.消息模式"></a>3.消息模式</h4><ul><li><strong>P2P模式(点对点)</strong></li><li><strong>Pub/Sub模式(发布订阅)</strong></li><li><strong>Push模式(推拉模式,消息更新C/S中)</strong></li></ul><h4 id="4-java中与Solr结合"><a href="#4-java中与Solr结合" class="headerlink" title="4.java中与Solr结合"></a>4.java中与Solr结合</h4><p>ActiveMQ以监视器的方式将信息与Solr结合使用…待更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ActiveMQ基础与运用&quot;&gt;&lt;a href=&quot;#ActiveMQ基础与运用&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ基础与运用&quot;&gt;&lt;/a&gt;ActiveMQ基础与运用&lt;/h3&gt;&lt;h4 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot;
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>FastDFS 基础原理</title>
    <link href="http://yoursite.com/2018/07/06/FastDfs%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/06/FastDfs基础原理/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-07-08T07:02:23.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FastDFS-基础原理"><a href="#FastDFS-基础原理" class="headerlink" title="FastDFS 基础原理"></a>FastDFS 基础原理</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>Depth First Search </p><p><strong>无向图算法概念</strong>(一种递归原理)</p><p>先按照一条边进行搜索,当遇到第一个节点时,对它相邻的其他节点进行搜索并标记为已查找的节点(会查找完第一条节点的最深层后返回)<br>详细见算法目录(持续更新)</p><p><img src="http://i.imgur.com/vJ23ZgT.jpg" alt="&quot;无向图算法图片&quot;的图片搜索结果"></p><h3 id="FastDFS–结构"><a href="#FastDFS–结构" class="headerlink" title="FastDFS–结构"></a>FastDFS–结构</h3><h2 id="1">FastDFS 架构–结构</h2><p><strong>FastDFS服务有三个角色:跟踪服务器(tracker server)、存储服务器(storage server)和客户端(client)</strong></p><p>主要解决了海量数据存储问题 ,特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。 </p><h4 id="跟踪器Tracker"><a href="#跟踪器Tracker" class="headerlink" title="跟踪器Tracker :"></a>跟踪器Tracker :</h4><p>主要做调度工作，相当于mvc中的controller的角色，在访问上起负载均衡的作用。跟踪器和存储节点都可以由一台或多台服务器构成，跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务，其中<strong>跟踪器</strong>中的所有服务器都是<strong>对等</strong>的，可以根据服务器的压力情况随时增加或减少。 </p><p>跟踪器Tracker负责管理所有的Storage和group，本身不需要持久化任何数据,直接增加机器就可以拓展tracker,每个Storage在启动后会连接Tracker，并周期性保持联系.</p><h4 id="存储服务器Storage"><a href="#存储服务器Storage" class="headerlink" title="存储服务器Storage:"></a>存储服务器Storage:</h4><p>以group为最小单位,方便实现 应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数）,建议同一group内的配置尽量相同,减少资源浪费(storage依赖于本地文件系统)</p><h4 id="客户端Client"><a href="#客户端Client" class="headerlink" title="客户端Client:"></a>客户端Client:</h4><p><strong>基本文件访问接口:</strong>比如upload、download、append、delete等，以客户端库的方式提供给用户使用。 </p><h3 id="FastDFS–运行"><a href="#FastDFS–运行" class="headerlink" title="FastDFS–运行"></a>FastDFS–运行</h3><p><strong>tracker</strong></p><p>当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个trakcer。</p><p><strong>group</strong></p><p>当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group，支持如下选择group的规则：</p><ol><li>Round robin，所有的group间轮询 </li><li>Specified group，指定某一个确定的group </li><li>Load balance，剩余存储空间多多group优先</li></ol><p><strong>storage</strong></p><p>当选定group后，tracker会在group内选择一个storage server给客户端，支持如下选择storage的规则： </p><ol><li>Round robin，在group内的所有storage间轮询 </li><li>First server ordered by ip，按ip排序 </li><li>First server ordered by priority，按优先级排序（优先级在storage上配置）</li></ol><p><strong>storage path</strong></p><p>当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录，支持如下规则： </p><ol><li>Round robin，多个存储目录间轮询 </li><li>剩余存储空间最多的优先</li></ol><p><strong>Fileid</strong></p><p>选定存储目录之后，storage会为文件生一个Fileid，<br>由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，<br>然后将这个二进制串进行base64编码，转换为可打印的字符串。</p><p><strong>选择两级目录</strong></p><p>当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash（猜测），路由到其中一个子目录，然后将文件以fileid为文件名存储到该子目录下。</p><p><strong>生成文件名</strong> </p><p>当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。</p><p><strong>文件同步</strong></p><p>写文件时，客户端将文件写至group内一个storage server即认为写文件成功，<br>storage server写完文件后，会由后台线程将文件同步至 [同group] 内其他的storage server。<br>storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。</p><p><strong>Download file</strong></p><p>客户端upload file成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。</p><h3 id="FastDFS–特点"><a href="#FastDFS–特点" class="headerlink" title="FastDFS–特点"></a>FastDFS–特点</h3><h4 id="小文件合并存储"><a href="#小文件合并存储" class="headerlink" title="小文件合并存储"></a>小文件合并存储</h4><p><strong>解决问题:</strong></p><ol><li>本地文件系统inode数量有限，从而存储的小文件数量也就受到限制。 </li><li>多级目录+目录里很多文件，导致访问文件的开销很大（可能导致很多次IO） </li><li>按小文件存储，备份与恢复的效率低</li></ol><p>FastDFS在V3.0版本里引入小文件合并存储的机制，可将多个小文件存储到一个大的文件（trunk file），为了支持这个机制，FastDFS生成的文件fileid需要额外增加16个字节 </p><h4 id="HTTP访问支持"><a href="#HTTP访问支持" class="headerlink" title="HTTP访问支持"></a>HTTP访问支持</h4><p>客户端可以通过http协议来下载文件，tracker在接收到请求时，通过http的redirect机制将请求[重定向]至文件所在的storage上；除了内置的http协议外，FastDFS还提供了通过apache或nginx扩展模块下载文件的支持。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>group机制本身可用来做负载均衡，但这只是一种静态的负载均衡机制，需要预先知道应用的访问特性；同时group机制也导致不可能在group之间迁移数据来做动态负载均衡。</p><h3 id="FastDFS–使用小结"><a href="#FastDFS–使用小结" class="headerlink" title="FastDFS–使用小结"></a>FastDFS–使用小结</h3><ol><li>分别配置Tracker地址(上传存储使用)和Storage地址(响应回显使用)</li><li>接收前段file文件后,将名字拆分重塑后存储</li><li>响应url则拼接Storage地址生成</li><li>每次上传文件后都会返回一个地址，用户需要自己保存此地址。</li><li>前段设计:将整个编辑内容存进一个由事件控制的表单,当图片上传的时候不会影响到表单的完整性,而且可以依靠上传时间来动态生成回显方案,将url放进input中,清除不必要的组件(可能影响表单提交完整性的部分)</li><li>为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。</li></ol><p><strong>注意:spring-mvc中除了要配置上传解析器之外,还需要将String的字符串指定为UTF-8(默认8859-1)</strong></p><h3 id="FastDFS原理系列文章-转发"><a href="#FastDFS原理系列文章-转发" class="headerlink" title="FastDFS原理系列文章(转发)"></a>FastDFS原理系列文章(转发)</h3><p><strong><a href="https://blog.csdn.net/hfty290/article/details/42076205" target="_blank" rel="noopener">https://blog.csdn.net/hfty290/article/details/42076205</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FastDFS-基础原理&quot;&gt;&lt;a href=&quot;#FastDFS-基础原理&quot; class=&quot;headerlink&quot; title=&quot;FastDFS 基础原理&quot;&gt;&lt;/a&gt;FastDFS 基础原理&lt;/h2&gt;&lt;h3 id=&quot;深度优先搜索&quot;&gt;&lt;a href=&quot;#深度优先搜索&quot;
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Solr基础原理</title>
    <link href="http://yoursite.com/2018/07/06/Solr%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/06/Solr基础原理/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-07-10T09:55:45.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Solr基础原理"><a href="#Solr基础原理" class="headerlink" title="Solr基础原理"></a>Solr基础原理</h3><h4 id="1-目录核心组成"><a href="#1-目录核心组成" class="headerlink" title="1.目录核心组成"></a>1.目录核心组成</h4><p><strong>1.core</strong></p><p>​    solr的索引库,可以理解为数据库,需要手动创建(文件夹),core可以根据需要建立多个索引库,索引库的内容可以在后台看到也可以在core中看到</p><p><strong>2.solrhome</strong></p><p>​    solr的配置目录,solr服务器所有的配置文件存放的目录(<strong>core创建在solrhome中</strong>)</p><p><strong>3.collection</strong></p><p>​    solr的逻辑索引(逻辑意义上的完整索引),由多个shard的组成,每个shard又由一个leadereplica和多个replica,每个replica都是物理索引,即每个replica都对应着一个core,collection本质是可以跨越多个核的索引,包含冗余的索引.</p><p><strong>参考<a href="https://blog.csdn.net/zhousenshan/article/details/51799567" target="_blank" rel="noopener">https://blog.csdn.net/zhousenshan/article/details/51799567</a></strong></p><h4 id="2-配置详解"><a href="#2-配置详解" class="headerlink" title="2.配置详解"></a>2.配置详解</h4><h5 id="1-配置中文分词"><a href="#1-配置中文分词" class="headerlink" title="1.配置中文分词"></a>1.配置中文分词</h5><ol><li><fieldtype name="text_ik" class="solr.TextField">   <!-- text_ik 中文分词包的引用名 --></fieldtype></li><li><analyzer class="org.wltea.analyzer.lucene.IKAnalyzer">  <!-- 中文分词包 --></analyzer></li><li></li><li><!-- 字段title 使用中文分词 stored="true"下载并索引 --></li><li><field name="item_title" type="text_ik" indexed="true" stored="true"> </field></li><li><!-- 字段price 使用long类型 --></li><li><field name="item_price" type="long" indexed="true" stored="true"></field></li><li><!-- city_id 使用long类型 --></li><li><field name="item_city_id" type="long" indexed="true" stored="true"> </field></li><li><!-- city_name 因为城市名固定,所以不需要分词,String即可 --></li><li><field name="item_city_name" type="string" indexed="true" stored="true"></field></li><li><!-- image 图片地址,String类型 --></li><li><field name="item_image" type="string" indexed="true" stored="true"></field></li><li><!-- content 中文分词 stored="false"(不下载,但可以索引) --></li><li><field name="item_content" type="text_ik" indexed="true" stored="false"></field></li><li><!-- item_keywords 自定义查询名(关键字);可以根据title||city_name||content来查询 --></li><li><field name="item_keywords" type="text_ik" indexed="true" stored="false" multivalued="true"></field></li><li><copyfield source="item_title" dest="item_keywords"></copyfield></li><li><copyfield source="item_city_name" dest="item_keywords"></copyfield></li><li><copyfield source="item_content" dest="item_keywords"></copyfield></li></ol><ol><li><!-- 默认使用item_keywords(Solr后台分词查询中显示自定义的字段) --></li><li><requesthandler name="/select" class="solr.SearchHandler"></requesthandler></li><li>​    &lt;!– default values for query parameters can be specified, these</li><li>​         will be overridden by parameters in the request</li><li>​      –&gt;</li><li>​     <lst name="defaults"></lst></li><li>​       <str name="echoParams">explicit</str></li><li>​       <str name="df">item_keywords</str></li><li>​        <int name="rows">10</int></li></ol><ol><li><!-- 默认使用item_keywords(开启查询) --></li><li><requesthandler name="/query" class="solr.SearchHandler"></requesthandler></li><li>​     <lst name="defaults"></lst></li><li>​       <str name="echoParams">explicit</str></li><li>​       <str name="wt">json</str></li><li>​       <str name="indent">true</str></li><li>​       <str name="df">item_keywords</str></li><li>​     </li><li></li></ol><h5 id="2-配置Solr-Dataimport"><a href="#2-配置Solr-Dataimport" class="headerlink" title="2.配置Solr Dataimport"></a>2.配置Solr Dataimport</h5><ol><li><!-- dataimport 开启Solr连接数据库功能 --></li><li><requesthandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler"> </requesthandler></li><li>​    <lst name="defaults">      </lst></li><li><!-- dataimport读取data-config.xml设定的JDBC配置文件 -->   </li><li>​         <str name="config">data-config.xml</str> </li><li>​              </li><li>  </li></ol><ol><li><dataconfig>       </dataconfig></li><li><!-- JDBC配置 --></li><li>​    <datasource type="JdbcDataSource" driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost:3306/travel_db?characterEncoding=utf-8" user="root" password="root" batchsize="-1">   </datasource></li><li>​    <document>   </document></li><li><!-- 查询语句(全表查询)字段,并匹配分词中设定的name -->  </li><li>​        <entity name="hotel" query="select ID,TITLE,PRICE,IMAGE,CITY_NAME, CITY_ID from HOTEL" datasource="JdbcDataSource">        </entity></li><li>​            <field column="ID" name="id"> </field></li><li>​            <field column="TITLE" name="item_title"> </field></li><li>​                            <field column="PRICE" name="item_price"> </field></li><li>​                            <field column="CONTENT" name="item_content"></field></li><li><field column="IMAGE" name="item_image"></field></li><li>​                            <field column="CITY_NAME" name="item_city_name"></field></li><li><field column="CITY_ID" name="item_city_id"></field></li><li>​                </li><li>​            </li><li>  </li></ol><h5 id="3-Solr后台的使用"><a href="#3-Solr后台的使用" class="headerlink" title="3.Solr后台的使用"></a>3.Solr后台的使用</h5><p>第一次先Dataimport–&gt;Execute导入,然后Refresh刷新状态即可</p><p><strong>Query:查询功能</strong> </p><p>​    q  <em> ; </em>    –&gt;第一个 <em> 表示字段; 第二个 </em> 表示字段的内容;  </p><p>​    如    item_keywords:北京   分词中有”北京”关键字的内容</p><p>​        item_price:[* TO 200]  价格是200以内的内容</p><p>​        item_price:[100 TO 700]  价格是100-200的内容</p><h4 id="3-java中的作用"><a href="#3-java中的作用" class="headerlink" title="3.java中的作用"></a>3.java中的作用</h4><p>建立一个新的索引模块 index,接口层和实现发布层</p><p>写Solr<strong>更新</strong>和<strong>搜索</strong>两个方法dubbo发布即可在controller中使用</p><p>(一般与MQ一起使用,如activeMQ,见<strong>activeMQ基础与运用章节</strong>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Solr基础原理&quot;&gt;&lt;a href=&quot;#Solr基础原理&quot; class=&quot;headerlink&quot; title=&quot;Solr基础原理&quot;&gt;&lt;/a&gt;Solr基础原理&lt;/h3&gt;&lt;h4 id=&quot;1-目录核心组成&quot;&gt;&lt;a href=&quot;#1-目录核心组成&quot; class=&quot;head
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Shiro基础原理</title>
    <link href="http://yoursite.com/2018/07/04/Shiro%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/04/Shiro基础原理/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-10T23:39:44.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shiro基础原理"><a href="#Shiro基础原理" class="headerlink" title="Shiro基础原理"></a>Shiro基础原理</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><strong>shiro是apache的一个开源框架，实现 |认证|授权|为核心的一系列权限管理框架.</strong></p><ul><li>Web 应用程序一般做法通过表单提交用户名及密码达到认证目的。 </li><li>“授权”即是否允许已认证用户访问受保护资源。 </li></ul><h3 id="2-对比"><a href="#2-对比" class="headerlink" title="2.对比"></a>2.对比</h3><p><strong>Shiro与Spring Security</strong></p><ol><li>简单性:shiro更加简单,更容易理解</li><li>灵活性:shiro可以使用在 |Web|EJB|IoC| 等大部分的应用环境,而Spring Security必须和Spring一起集成使用</li><li>拔插性:shiro干净的API(工具类集合)和设计模式(单例+工厂)使它可以方便的和许多其他框架整合,Spring Security则只能与Spring一起集成</li></ol><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成"></a>3.组成</h3><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/1b7bc2c3-9f2c-4ea2-8ed7-97820c205482/128/index_files/871676-20160722213407794-1894786938.png" alt="img"></p><p><strong>三个核心组件</strong>    </p><ol><li>Subject: 令牌与项目的登录关系,Shiro保证了项目整体的安全性,是<strong>Shiro对外API的核心</strong></li><li>Security Manager:负责安全认证预授权等  <strong>Shiro的核心</strong> </li><li>Realm:整个框架中<strong>必须</strong>由设计者自行实现的模块之一.并且Shiro支持多个<strong>Realm数据源</strong>,最为重要的一种实现方式—&gt;数据库查询,当需要多个数据库组合验证时,多个数据源的效果就体现出来</li></ol><hr><ol><li>Authentication:    身份认证</li><li>Authorization:  授权,权限验证</li><li>Session Manager: 会话管理</li><li>Cryptography:加密</li><li>Web Support: web支持</li><li>Caching:缓存</li><li>Concurrency:多线程验证</li><li>Testing:提供测试支持</li><li>Run As:允许一个用户假装另一个用户访问</li><li>Remember Me: 记住我</li></ol><hr><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/b9f81ac7-ad34-4adc-b4c2-cb2f73a4f2dd/128/index_files/48cae49c-8924-4a4e-8efd-bdbf38f07c97.jpg" alt="img">    </p><ol><li><strong>注意:Shiro不会自己维护用户|权限;</strong></li><li><strong>需要开发者去 设计|提供 ;</strong></li><li><strong>然后通过接口注入给Shiro即可</strong></li></ol><h3 id="4-源码"><a href="#4-源码" class="headerlink" title="4.源码"></a>4.源码</h3><h4 id="Token认证"><a href="#Token认证" class="headerlink" title="Token认证"></a>Token认证</h4><p><strong>JdbcRealm</strong></p><p>Shiro –&gt;JdbcRealm封装的固定sql</p><p> [1.封装根据用户名查询密码的SQL语句]</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The default query used to retrieve account data for the user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AUTHENTICATION_QUERY = <span class="string">"select password from users where username = ?"</span>;</span><br></pre></td></tr></table></figure><pre><code>[2.盐加密&amp;&amp;authenticationQuery验证查询(判断)] </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the salt style.  See &#123;<span class="doctag">@link</span> #saltStyle&#125;.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> saltStyle new SaltStyle to set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSaltStyle</span><span class="params">(SaltStyle saltStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.saltStyle = saltStyle;</span><br><span class="line">        <span class="keyword">if</span> (saltStyle == SaltStyle.COLUMN &amp;&amp; authenticationQuery.equals(DEFAULT_AUTHENTICATION_QUERY)) &#123;</span><br><span class="line">            authenticationQuery = DEFAULT_SALTED_AUTHENTICATION_QUERY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  [3.发现源代码中使用预编译的原生JDBC,并根据索引查找对比,所以要求自定义语句时不能乱写,根据规则走] </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ps = conn.prepareStatement(authenticationQuery);</span><br><span class="line">            ps.setString(1, username);</span><br><span class="line"></span><br><span class="line">            // Execute query</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            // Loop over results - although we are only expecting one result, since usernames should be unique</span><br><span class="line">            boolean foundResult = false;</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">                // Check to ensure only one row is processed</span><br><span class="line">                if (foundResult) &#123;</span><br><span class="line">                    throw new AuthenticationException(&quot;More than one user row found for user [&quot; + username + &quot;]. Usernames must be unique.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                result[0] = rs.getString(1);     //索引查询</span><br><span class="line">                if (returningSeparatedSalt) &#123;</span><br><span class="line">                    result[1] = rs.getString(2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                foundResult = true;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>new SimpleAuthenticationInfo()(存放唯一认证) 源码分析</strong></p><p>principal: 整个Shiro中唯一的标识符,可以存用户名,也可以存ID</p><p>credentials: 唯一标识符的密码</p><p>realmName: 当前数据源的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAuthenticationInfo</span><span class="params">(Object principal, Object credentials, String realmName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.principals = <span class="keyword">new</span> SimplePrincipalCollection(principal, realmName);</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\Desktop\20180122131153906.png" alt="20180122131153906"></p><p>使用了工厂模式来对SecurityManager进行生成和配置  </p><p>生成过程是使用<strong>单例+工厂</strong> </p><p>提供对外的<strong>工具类</strong>来使用，包含获取SecurityManager的方法和获取Subject的方法  </p><p><img src="C:\Users\Administrator\Desktop\3.png" alt="3"></p><p>(代码略)</p><p>subject的使用是通过传入AuthenticationToken接口（注意是接口，其实扩展接口rememnverMeaut…和HostAutho…），</p><p>该接口目前的实现类是UserPasswordToken，当然也可以自己扩展实现自定义的认证Token </p><h4 id="测试加密算法"><a href="#测试加密算法" class="headerlink" title="测试加密算法"></a>测试加密算法</h4><p><strong>盐值加密如果几个人密码一样，那么加密后的密码则一致。这样不安全，要解决这个问题，可以在密码上加盐。一般会选择不重复的值作为盐值，例如 用户名。</strong>(部分代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">        <span class="comment">//第一个参数：散列算法</span></span><br><span class="line">        <span class="comment">//第二个参数：明文，原始密码</span></span><br><span class="line">        <span class="comment">//第三个参数：盐，通过使用随机数</span></span><br><span class="line">        <span class="comment">//第四个参数：散列的次数，比如散列两次，相当 于md5(md5(''))</span></span><br><span class="line">        SimpleHash simpleHash = <span class="keyword">new</span> SimpleHash(<span class="string">"md5"</span>, source, salt, hashIterations);</span><br><span class="line">        String md5 =  simpleHash.toString();</span><br><span class="line">        System.out.println(md5);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shiro-realm-md5.ini</span><br><span class="line">---------------------</span><br><span class="line">[main]</span><br><span class="line">定义凭证匹配器</span><br><span class="line">credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line">散列算法</span><br><span class="line">credentialsMatcher.hashAlgorithmName=md5</span><br><span class="line">散列次数</span><br><span class="line">credentialsMatcher.hashIterations=<span class="number">1024</span></span><br><span class="line">开启加盐（无需设置，realm中使用的SimpleAuthenticationInfo 是 SaltedAuthenticationInfo 接口的实现类，默认开启的加盐功能）</span><br><span class="line">credentialsMatcher.hashSalted=<span class="keyword">true</span></span><br><span class="line">自定义 realm</span><br><span class="line">customRealm=com.qfedu.shirodemo.realm.CustomRealmMd5</span><br><span class="line">customRealm.credentialsMatcher=$credentialsMatcher</span><br><span class="line">将realm设置到securityManager，相当 于spring中注入</span><br><span class="line">securityManager.realms=$customRealm</span><br></pre></td></tr></table></figure><h4 id="授权流程原理"><a href="#授权流程原理" class="headerlink" title="授权流程原理"></a>授权流程原理</h4><p><strong>授权</strong></p><p>授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</p><p><strong>主体（Subject）</strong></p><p>主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。</p><p><strong>资源</strong></p><p>在应用中用户可以访问的任何东西，比如JSP 页面、某些数据、某个业务方法等等都是资源。用户只要授权后才能访问。</p><p><strong>权限</strong></p><p>权限表示在应用中用户能不能访问某个资源，</p><p>如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）打印文档等等。。。</p><p><strong>角色</strong></p><p>角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。</p><p>典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。</p><h5 id="判断是否授权的方式"><a href="#判断是否授权的方式" class="headerlink" title="判断是否授权的方式"></a>判断是否授权的方式</h5><p>Shiro 支持三种方式的授权判断：</p><p><strong>编程式</strong></p><p>通过写if/else 授权代码块完成：</p><p>Subject subject = SecurityUtils.getSubject();</p><p>if(subject.hasRole(“admin”)) {</p><p>​      //有权限</p><p>} else {</p><p>​     //无权限</p><p>}</p><p><strong>注解式</strong></p><p>通过在执行的Java方法上放置相应的注解完成：</p><p>@RequiresRoles(“admin”)</p><p>public void hello() {</p><p>   //有权限</p><p>}</p><p>没有权限将抛出相应的异常；</p><p><strong>JSP 标签</strong></p><p>在JSP 页面通过相应的标签完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!— 有权限—&gt;</span><br><span class="line"></span><br><span class="line">&lt; /shiro:hasRole &gt;</span><br></pre></td></tr></table></figure><h5 id="自定义realm授权"><a href="#自定义realm授权" class="headerlink" title="自定义realm授权"></a>自定义realm授权</h5><p><strong>从认证的realm拷贝，改变继承的抽象父类，添加新的方法</strong></p><h3 id="5-程序分析"><a href="#5-程序分析" class="headerlink" title="5.程序分析"></a>5.程序分析</h3><p><strong>程序分析：从应用程序角度的来观察如何使用Shiro完成工作</strong> </p><ol><li>应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager； </li><li>我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</li><li>可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject； </li></ol><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/e66c475a-c763-4097-85a0-b0219938fe7f/128/index_files/4a5f51ff-ef16-4a61-a834-9a9b06da850b.jpg" alt="img"></p><p><strong>Shiro内部结构</strong></p><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/1b7bc2c3-9f2c-4ea2-8ed7-97820c205482/128/index_files/9b959a65-799d-396e-b5f5-b4fcfe88f53c.png" alt="img"></p><p><strong>详细原理深入和运用:<a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/2018398</a></strong></p><h3 id="6-Shiro认证技巧整理"><a href="#6-Shiro认证技巧整理" class="headerlink" title="6.Shiro认证技巧整理"></a>6.Shiro认证技巧整理</h3><h4 id="工具类接口的使用"><a href="#工具类接口的使用" class="headerlink" title="工具类接口的使用"></a>工具类接口的使用</h4><p>建立一个工具类接口Constants,以常量字符串的方式,专门存放Shiro中自定义的<strong>标识符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Constants &#123;</span><br><span class="line">    // md5(用户密码+PASSWORD_SALT_KEY)保存到数据库中。</span><br><span class="line">    String PASSWORD_SALT_KEY = &quot;Shiro.admin.2017&quot;;</span><br><span class="line">    //Shiro的session中存放用户的key</span><br><span class="line">    String SESSION_USER_KEY = &quot;SESSION_USER_KEY&quot;;</span><br><span class="line">    //redis中存放的用户权限菜单的key</span><br><span class="line">    String SESSION_USER_MANU = &quot;SESSION_USER_MANU&quot;;</span><br><span class="line">    //Shiro存放的角色信息</span><br><span class="line">    String SESSION_USER_ROLE = &quot;SESSION_USER_ROLE&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口工具类的思路不仅限于Shiro,灵活的定义接口,将冗余和容易混淆的部分抽离出来统一管理,可以极大的提高开发和维护的效率</strong></p><h4 id="认证优化技巧"><a href="#认证优化技巧" class="headerlink" title="认证优化技巧"></a>认证优化技巧</h4><p>Controller层登录方法中,接收到用户名和密码后先进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">if (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">    ...认证</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接获取subject,先进性判断该用户是否认证过,如果认证过则直接跳出即可</p><p>如果没有认证过,再进入认证环节</p><p>该逻辑可以减少服务器和数据库的压力,提高服务器的并发能力</p><h4 id="shiro-xml-拦截器设置"><a href="#shiro-xml-拦截器设置" class="headerlink" title="..shiro.xml 拦截器设置"></a>..shiro.xml 拦截器设置</h4><p><strong>Shiro主过滤器本身功能十分强大,其强大之处就在于它支持任何基于URL路径表达式的、自定义的过滤器的执行</strong></p><ul><li>/login.html=anon 静态资源的方式屏蔽过滤器</li><li>/**=authc 该路径下需要认证才能访问</li><li>…</li></ul><p>过滤器的完整参考：</p><p><a href="http://blog.csdn.net/jadyer/article/details/12172839" target="_blank" rel="noopener">http://blog.csdn.net/jadyer/article/details/12172839</a></p><h4 id="登录认证使用原理"><a href="#登录认证使用原理" class="headerlink" title="登录认证使用原理"></a>登录认证使用原理</h4><p><strong>动态权限控制</strong></p><p><strong>RBAC（Role-Based Access Control ）基于角色的访问控制</strong></p><ol><li>配置好环境和工具类</li><li>自定义Realm和异常</li><li>service中添加通过用户名查找用户信息</li><li>在Controller层认证登录</li><li><ul><li>UsernamePasswordToken token = new UsernamePasswordToken(name, password);</li><li>Subject subject = SecurityUtils.getSubject();</li><li>ubject.login(token);</li></ul></li><li>将真正的验证交给封装的底层–&gt;AuthenticationToken实现.(自定义Realm中)</li><li>通过此时token的username去数据库查询用户信息</li><li>用户信息存在,则存入SimpleAuthenticationInfo,否则  抛出用户对应的异常</li></ol><p><strong>Shiro的分布式认证结构(shiro认证将账号密码的比较环节封装到AuthenticationToken中)</strong></p><p>​    Realm放在Controller中,在分布式中Controller使用Dubbo服务端接口,而dubbo接口通过service实现类来发布,这个角度看realm与dao隔层交互设计不太合理</p><p>​    验证成功则返回SimpleAuthenticationInfo(存放唯一标识(id或者username),密码,Realm名</p><h3 id="7-Shiro授权技巧整理"><a href="#7-Shiro授权技巧整理" class="headerlink" title="7.Shiro授权技巧整理"></a>7.Shiro授权技巧整理</h3><ol><li>通过用户登录的唯一标识principals 查找到用户有哪些菜单权限(ID)</li><li>将这些ID存到SimpleAuthorizationInfo中</li><li>在自定义ShiroFilterFactoryBean中获取所有菜单列表,并将id加入到section中</li><li>底层自动对比,哪些ID用户有,则允许访问,没有的话”authc”拦截</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shiro基础原理&quot;&gt;&lt;a href=&quot;#Shiro基础原理&quot; class=&quot;headerlink&quot; title=&quot;Shiro基础原理&quot;&gt;&lt;/a&gt;Shiro基础原理&lt;/h2&gt;&lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基础原理</title>
    <link href="http://yoursite.com/2018/07/04/Redis%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/04/Redis基础原理/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-09T12:13:41.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis基础原理"><a href="#Redis基础原理" class="headerlink" title="Redis基础原理"></a>Redis基础原理</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p><strong>NoSQL</strong></p><p>非关系型数据库,Redis是非关系型数据库中的<strong>键值存储数据库</strong></p><p><strong>应用</strong></p><p>处理高并发/海量数据的访问,内容缓存</p><p><strong>优点</strong></p><ol><li>快速查询,支持横向扩充(集群)和纵向扩充(加强设备)</li><li>一主多从,读写分离</li><li>哨兵机制,检测选举</li><li>集群机制,多主多从,数据高可用,分布式存储</li></ol><p><strong>缺点</strong></p><p>​    存储缺少结构化(难以构建关系型理数据库模型)</p><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>最简单的KV存储,value可以是String也可以是数字等</p><p><strong>场景</strong></p><p>kv字符串结构等,非常普遍</p><p><strong>指令</strong></p><p>​    SET key value                   设置key=value </p><p>​    GET key                         或者键key对应的值 </p><p>​    GETRANGE key start end          得到字符串的子字符串存放在一个键 </p><p>​    GETSET key value                设置键的字符串值，并返回旧值 </p><p>​    GETBIT key offset               返回存储在键位值的字符串值的偏移 </p><p>​    MGET key1 [key2..]              得到所有的给定键的值 </p><p>​    SETBIT key offset value         设置或清除该位在存储在键的字符串值偏移 </p><p>​    SETEX key seconds value         键到期时设置值 </p><p>​    SETNX key value                 设置键的值，只有当该键不存在 </p><p>​    SETRANGE key offset value       覆盖字符串的一部分从指定键的偏移 </p><p>​    STRLEN key                      得到存储在键的值的长度 </p><p>​    MSET key value [key value…]   设置多个键和多个值 </p><p>​    MSETNX key value [key value…] 设置多个键多个值，只有在当没有按键的存在时 </p><p>​    PSETEX key milliseconds value   设置键的毫秒值和到期时间 </p><p>​    INCR key                        增加键的整数值一次 INCRBY key increment            由给定的数量递增键的整数值 </p><p>​    INCRBYFLOAT key increment       由给定的数量递增键的浮点值</p><p>​    DECR key                        递减键一次的整数值 </p><p>​    DECRBY key decrement            由给定数目递减键的整数值 </p><p>​    APPEND key value                追加值到一个键 </p><p>​    ——–操作管理———-</p><ul><li><p>DEL key                         如果存在删除键 </p></li><li><p>DUMP key                        返回存储在指定键的值的序列化版本 </p></li><li><p>EXISTS key                      此命令检查该键是否存在 </p></li><li><p>EXPIRE key seconds              指定键的过期时间</p></li><li><p>EXPIREAT key timestamp          指定的键过期时间。在这里，时间是在Unix时间戳格式 </p></li><li><p>PEXPIRE key milliseconds        设置键以毫秒为单位到期 </p></li><li><p>PEXPIREAT key milliseconds-timestamp        设置键在Unix时间戳指定为毫秒到期 </p></li><li><p>KEYS pattern                    查找与指定模式匹配的所有键 </p></li><li><p>MOVE key db                     移动键到另一个数据库 </p></li><li><p>PERSIST key                     移除过期的键 </p></li><li><p>PTTL key                        以毫秒为单位获取剩余时间的到期键。 </p></li><li><p>TTL key                         获取键到期的剩余时间。 </p></li><li><p>RANDOMKEY                       从Redis返回随机键 </p></li><li><p>RENAME key newkey               更改键的名称 </p></li><li><p>RENAMENX key newkey             重命名键，如果新的键不存在 </p></li><li><p>TYPE key                        返回存储在键的数据类型的值。 </p></li></ul><h5 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h5><p>字符串列表,非常重要的Redis类型,本质是双向链表,支持反向查询和遍历,更加方便,但是会额外增加内存开销(存储双向链表),redis内部的<strong>发送缓冲队列</strong>使用的就是List结构</p><p><strong>场景</strong></p><p>如twitter的关注列表和粉丝列表,实现轻量级的消息队列等</p><p><strong>指令</strong></p><ul><li>BLPOP<br>BLPOP key1 [key2 ] timeout 取出并获取列表中的第一个元素，或阻塞，直到有可用</li><li>BRPOP<br>BRPOP key1 [key2 ] timeout 取出并获取列表中的最后一个元素，或阻塞，直到有可用</li><li>BRPOPLPUSH<br>BRPOPLPUSH source destination timeout 从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用</li><li>LINDEX<br>LINDEX key index 从一个列表其索引获取对应的元素</li><li>LINSERT<br>LINSERT key BEFORE|AFTER pivot value 在列表中的其他元素之后或之前插入一个元素</li><li>LLEN<br>LLEN key 获取列表的长度</li><li>LPOP<br>LPOP key 获取并取出列表中的第一个元素</li><li>LPUSH<br>LPUSH key value1 [value2] 在前面加上一个或多个值的列表</li><li>LPUSHX<br>LPUSHX key value 在前面加上一个值列表，仅当列表中存在</li><li>LRANGE<br>LRANGE key start stop 从一个列表获取各种元素</li><li>LREM<br>LREM key count value 从列表中删除元素</li><li>LSET<br>LSET key index value 在列表中的索引设置一个元素的值</li><li>LTRIM<br>LTRIM key start stop 修剪列表到指定的范围内</li><li>RPOP<br>RPOP key 取出并获取列表中的最后一个元素</li><li>RPOPLPUSH<br>RPOPLPUSH source destination 删除最后一个元素的列表，将其附加到另一个列表并返回它</li><li>RPUSH<br>RPUSH key value1 [value2] 添加一个或多个值到列表</li><li>RPUSHX<br>RPUSHX key value 添加一个值列表，仅当列表中存在</li></ul><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。 </p><p><strong>场景</strong></p><p>可以方便的存储用户信息,用户ID为Key,用户信息序列化为value存储</p><p><strong>指令</strong></p><ul><li>HDEL<br>HDEL key field[field…] 删除对象的一个或几个属性域，不存在的属性将被忽略</li><li>HEXISTS<br>HEXISTS key field 查看对象是否存在该属性域</li><li>HGET<br>HGET key field 获取对象中该field属性域的值</li><li>HGETALL<br>HGETALL key 获取对象的所有属性域和值</li><li>HINCRBY<br>HINCRBY key field value 将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用</li><li>HINCRBYFLOAT<br>HINCRBYFLOAT key field increment 将该对象中指定域的值增加给定的浮点数</li><li>HKEYS<br>HKEYS key 获取对象的所有属性字段</li><li>HVALS<br>HVALS key 获取对象的所有属性值</li><li>HLEN<br>HLEN key 获取对象的所有属性字段的总数</li><li>HMGET<br>HMGET key field[field…] 获取对象的一个或多个指定字段的值</li><li>HSET<br>HSET key field value 设置对象指定字段的值</li><li>HMSET<br>HMSET key field value [field value …] 同时设置对象中一个或多个字段的值</li><li>HSETNX<br>HSETNX key field value 只在对象不存在指定的字段时才设置字段的值</li><li>HSTRLEN<br>HSTRLEN key field 返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0.</li><li>HSCAN<br>HSCAN key cursor [MATCH pattern] [COUNT count] 类似SCAN命令</li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>存储数据不重复,set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 </p><p><strong>场景</strong></p><p>set和list的功能类似,但是set加载的列表自动排重,当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 </p><p>在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 </p><p><strong>指令</strong></p><ul><li>SADD<br>SADD key member [member …] 添加一个或者多个元素到集合(set)里</li><li>SACRD<br>SCARD key 获取集合里面的元素数量</li><li>SDIFF<br>SDIFF key [key …] 获得队列不存在的元素</li><li>SDIFFSTORE<br>SDIFFSTORE destination key [key …] 获得队列不存在的元素，并存储在一个关键的结果集</li><li>SINTER<br>SINTER key [key …] 获得两个集合的交集</li><li>SINTERSTORE<br>SINTERSTORE destination key [key …] 获得两个集合的交集，并存储在一个集合中</li><li>SISMEMBER<br>SISMEMBER key member 确定一个给定的值是一个集合的成员</li><li>SMEMBERS<br>SMEMBERS key 获取集合里面的所有key</li><li>SMOVE<br>SMOVE source destination member 移动集合里面的一个key到另一个集合</li><li>SPOP<br>SPOP key [count] 获取并删除一个集合里面的元素</li><li>SRANDMEMBER<br>SRANDMEMBER key [count] 从集合里面随机获取一个元素</li><li>SREM<br>SREM key member [member …] 从集合里删除一个或多个元素，不存在的元素会被忽略</li><li>SUNION<br>SUNION key [key …] 添加多个set元素</li><li>SUNIONSTORE<br>SUNIONSTORE destination key [key …] 合并set元素，并将结果存入新的set里面</li><li>SSCAN<br>SSCAN key cursor [MATCH pattern][COUNT count] 迭代set里面的元素</li></ul><h5 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h5><p>set的有序版,由HaspMap和跳跃表组成</p><p><strong>场景</strong></p><p>用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列。 </p><p><strong>指令</strong></p><ul><li>ZADD<br>ZADD key score1 member1 [score2 member2] 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数</li><li>ZCARD<br>ZCARD key 得到的有序集合成员的数量</li><li>ZCOUNT<br>ZCOUNT key min max 计算一个有序集合成员与给定值范围内的分数</li><li>ZINCRBY<br>ZINCRBY key increment member 在有序集合增加成员的分数</li><li>ZINTERSTORE<br>ZINTERSTORE destination numkeys key [key …] 多重交叉排序集合，并存储生成一个新的键有序集合。</li><li>ZLEXCOUNT<br>ZLEXCOUNT key min max 计算一个给定的字典范围之间的有序集合成员的数量</li><li>ZRANGE<br>ZRANGE key start stop [WITHSCORES] 由索引返回一个成员范围的有序集合（从低到高）</li><li>ZRANGEBYLEX<br>ZRANGEBYLEX key min max [LIMIT offset count]返回一个成员范围的有序集合（由字典范围）</li><li>ZRANGEBYSCORE<br>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列</li><li>ZRANK<br>ZRANK key member 确定成员的索引中有序集合</li><li>ZREM<br>ZREM key member [member …] 从有序集合中删除一个或多个成员，不存在的成员将被忽略</li><li>ZREMRANGEBYLEX<br>ZREMRANGEBYLEX key min max 删除所有成员在给定的字典范围之间的有序集合</li><li>ZREMRANGEBYRANK<br>ZREMRANGEBYRANK key start stop 在给定的索引之内删除所有成员的有序集合</li><li>ZREMRANGEBYSCORE<br>ZREMRANGEBYSCORE key min max 在给定的分数之内删除所有成员的有序集合</li><li>ZREVRANGE<br>ZREVRANGE key start stop [WITHSCORES] 返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分</li><li>ZREVRANGEBYSCORE<br>ZREVRANGEBYSCORE key max min [WITHSCORES] 返回一个成员范围的有序集合，以socre排序从高到低</li><li>ZREVRANK<br>ZREVRANK key member 确定一个有序集合成员的索引，以分数排序，从高分到低分</li><li>ZSCORE<br>ZSCORE key member 获取给定成员相关联的分数在一个有序集合</li><li>ZUNIONSTORE<br>ZUNIONSTORE destination numkeys key [key …] 添加多个集排序，所得排序集合存储在一个新的键</li><li>ZSCAN<br>ZSCAN key cursor [MATCH pattern] [COUNT count] 增量迭代排序元素集和相关的分数</li></ul><p><strong>Redis过期策略:<a href="https://www.jb51.net/article/103236.htm" target="_blank" rel="noopener">https://www.jb51.net/article/103236.htm</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis基础原理&quot;&gt;&lt;a href=&quot;#Redis基础原理&quot; class=&quot;headerlink&quot; title=&quot;Redis基础原理&quot;&gt;&lt;/a&gt;Redis基础原理&lt;/h3&gt;&lt;h4 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/07/03/hello-world/"/>
    <id>http://yoursite.com/2018/07/03/hello-world/</id>
    <published>2018-07-03T15:51:12.163Z</published>
    <updated>2018-07-05T12:34:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GitHub 博客快速搭建</title>
    <link href="http://yoursite.com/2018/07/02/GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/07/02/GitHub博客搭建/</id>
    <published>2018-07-01T16:00:00.000Z</published>
    <updated>2018-07-10T09:27:14.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitHub-博客快速搭建"><a href="#GitHub-博客快速搭建" class="headerlink" title="GitHub 博客快速搭建"></a>GitHub 博客快速搭建</h3><p><strong>环境:Win7</strong></p><p><strong>搭建流程</strong></p><p>Node.js | Hexo | Next(themes) </p><p><strong>基础</strong></p><ol><li>首先安装Node.js 注意<strong>Path指定位置</strong>(影响到balabala一些配置的存放的位置,默认C盘,建议改)</li><li>Node.js安装好后,选择一个文件夹安装Hexo(此处为<strong>搭建Blog的位置</strong>)</li><li>将GitHub账号的博客地址添加到Hexo的配置文件中(根目录 <strong>_config.yml</strong>),并将部署方式改为Git(老版本是GitHub方式)</li><li>根据指令部署后即可完成基础的博客搭建,此时查看博客仓库是否上传了静态资源(如果上传了则代表搭建成功)</li><li>短暂的延迟后进入博客网页即可看到搭建的博客</li><li>写博客的方式–&gt;将编写的md文章放在posts下,然后 hexo g d 部署一下即可(每次方式用这个指令就可以上传文章了,文章会被自适应解析)</li></ol><p><strong>参考<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a></strong></p><hr><p><strong>进阶</strong></p><p>Hexo中的themes是主题设定的位置,可以选择主题,教程中选择Next的基础主题(没有追求可以凑合用( • ̀ω•́ )✧)</p><p>themes中的(<strong>_config.yml</strong>)是主题的配置,里面可以根据提示做自己的简单配置,包括菜单的增减和修改,布局等等,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br></pre></td></tr></table></figure><p>根据教程和注释完成自己的布局即可</p><p><strong>参考<a href="http://www.cnblogs.com/fengxiongZz/p/7707568.html" target="_blank" rel="noopener">http://www.cnblogs.com/fengxiongZz/p/7707568.html</a></strong></p><hr><p><strong>进阶加强</strong></p><p>完成这些想玩点花的话可以去官网或者GitHub找喜欢的themes修改使用,教程百度一大堆( • ̀ω•́ )✧</p><p><strong>一大波官网主题:<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></strong></p><p><strong>第三方的插件口头整合</strong></p><ol><li>第三方登录(Github)</li><li>评论功能</li><li>站内搜索</li><li>站内统计</li><li>交互式背景</li><li>网易云播放器插件</li><li>将网站的所有图片通过url委托给第三方云图片服务器(七牛云存储10G免费)</li><li>…</li></ol><hr><p><strong>维护技巧</strong></p><p>当不能保证在同一台电脑上传文章时,可以选择master分离的方式或者将博客部署在自己的远程服务器上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GitHub-博客快速搭建&quot;&gt;&lt;a href=&quot;#GitHub-博客快速搭建&quot; class=&quot;headerlink&quot; title=&quot;GitHub 博客快速搭建&quot;&gt;&lt;/a&gt;GitHub 博客快速搭建&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;环境:Win7&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="搭建" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
</feed>
