<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DonY15</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-15T13:14:03.011Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>宝全哥哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring基础原理</title>
    <link href="http://yoursite.com/2018/07/15/Spring%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/15/Spring基础原理/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2018-07-15T13:14:03.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring基础原理"><a href="#Spring基础原理" class="headerlink" title="Spring基础原理"></a>Spring基础原理</h2><p>[TOC]</p><h3 id="1-Spring概念"><a href="#1-Spring概念" class="headerlink" title="1.Spring概念"></a>1.Spring概念</h3><p><strong>提供一个ioc容器来管理Bean,并通过AOP方式来增加Bean的功能</strong></p><p>基于Spring-IoC和AOP来构建多层Java EE 项目,能构将项目内的组件进行解耦分离,大大提高了开发效率和维护效率</p><p><strong>通过反射+XML实现的对象管理工厂(大容器)</strong></p><p><strong>目的:</strong></p><ol><li>解耦,简化开发</li><li>AOP编程的支持</li><li>声明事务的支持</li><li>方便程序测试</li><li>继承各种优秀框架</li><li>降低Java EE API的使用难度</li></ol><h3 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2.核心概念"></a>2.核心概念</h3><ol><li>IoC: Inversion of Control 控制反转 (通过反射机制创建对象实例)</li><li>DI: Dependency Injection  依赖注入(将bean之间的关系交给spring容器管理,我们可以在service注入dao层的实例,controller中注入service层实例)</li><li>AOP: Aspect Oriented Programming  面向切面</li></ol><h3 id="3-Spring组成"><a href="#3-Spring组成" class="headerlink" title="3.Spring组成"></a>3.Spring组成</h3><p>Spring框架的功能大概由20多个模块组成,这些模块按组可以分为以下几部分</p><p><strong>| 核心容器 | 数据访问/集成 | WEB | AOP | 设备 | 消息 | 测试 |</strong></p><p>​    核心模块:Beans Core Context spEL对应项目初始化时需要的四个核心包<br><img src="https://i.imgur.com/4dxxIk6.png" alt="Spring架构"></p><h3 id="4-Spring说明"><a href="#4-Spring说明" class="headerlink" title="4.Spring说明"></a>4.Spring说明</h3><ol><li><strong>bean元素:需要spring管理的对象,是Spring中最基础的单位(包括数据源/SessionFactory/事务管理等)</strong></li><li><strong>class属性: 需要spring管理对象的全类名</strong></li><li><strong>name属性:给被管理者起个引用名,根据该引用名就可以使用该对象(bean对象的标识)</strong></li><li>id属性:bean对象的唯一标识(和name的区别是整个spring中不可重复)</li><li><strong>lazy-init:是否延时加载,默认false(开启后只对单例有效)</strong></li><li>init-method:对象初始化方法</li><li>destory:对象销毁方法</li><li>scope:<strong>singleton</strong>(默认,适用实际开发的大部分情况)还是<strong>prototype</strong></li></ol><h4 id="1-Spring管理对象原理"><a href="#1-Spring管理对象原理" class="headerlink" title="1.Spring管理对象原理"></a>1.Spring管理对象原理</h4><h5 id="1-Spring容器"><a href="#1-Spring容器" class="headerlink" title="1.Spring容器"></a>1.Spring容器</h5><p>Spring要管理对象,就需要把对象加入到自己的容器中</p><p><strong>Spring容器</strong>是Spring的核心,主要的责任便是<strong>管理Spring中java的组件</strong></p><ol><li>对象加入到Spring容器的三种方法(依赖注入) <strong>|无参构造+setter注入|有参构造方法注入|动静态工厂注入|</strong></li><li>使用bean对象时,实例化容器的两种方法<strong>|ClassPathXml..xml实例化|FileSystem…绝对路径实例化|</strong></li><li>ApplicationContext容器实例化后,默认会实例化内部的所有bean,通过getBean即可获取bean对象的使用权</li></ol><h5 id="2-Spring容器与对象Bean"><a href="#2-Spring容器与对象Bean" class="headerlink" title="2.Spring容器与对象Bean"></a>2.Spring容器与对象Bean</h5><p>通常情况下,Bean是被动的接收Spring容器创建的实例,具有使用权,即Bean不对Spring进行访问</p><p>如果想让Bean对Spring进行访问,则需要手动配置,让Bean实现<strong>BeanFactoryAware </strong>接口…</p><p><strong>该操作非常不推荐,污染代码,使Bean和Spring耦合在一起,若非特别需要,否则不要用</strong></p><h5 id="3-Spring容器中Bean的继承特性与Java中继承区别"><a href="#3-Spring容器中Bean的继承特性与Java中继承区别" class="headerlink" title="3.Spring容器中Bean的继承特性与Java中继承区别"></a>3.Spring容器中Bean的继承特性与Java中继承区别</h5><p>spring中可以使用抽象bean,即abstract 属性为true,抽象bean不能被实例化,作用是<strong>Spring中的继承</strong></p><p><strong>spring中的继承:</strong></p><p>主要用于bean的数量越来越多,许多属性配置冗余,此时可以使用继承</p><p><strong>spring的继承无法继承如下属性:</strong></p><ul><li>depends-on,aotuwirwe,dependency-check,singleton,scope,lazy-iniyt这些属性总是子Bean定义，或采用默认值。 </li></ul><p><strong>Bean继承与java中继承的区别： </strong></p><ul><li>Spring中的子bean和父Bean可以是不同类型，但java中的继承则可保证子类是一种特殊的父类； </li><li>Spring中的Bean的继承是实例之间的关系，因此只要表现在参数值的延续，而java中的继承是类之间的关系，主要表现为方法、属性之间的延续； </li><li>Spring中的子Bean不可以作为父Bean使用，不具备多态性，java中的子类完全可以当成父类使用。 </li></ul><h5 id="4-Spring容器中Bean模式的生命周期"><a href="#4-Spring容器中Bean模式的生命周期" class="headerlink" title="4.Spring容器中Bean模式的生命周期"></a>4.Spring容器中Bean模式的生命周期</h5><p><strong>singleton：</strong> Spring容器能够准确的追踪其创建/使用/销毁</p><p><strong>prototype：</strong>Spring容器仅负责其创建,无法追踪其使用和销毁,每次创建后都会委托给客户端,不再对其追踪 </p><h5 id="5-强制初始化Bean-使用较少"><a href="#5-强制初始化Bean-使用较少" class="headerlink" title="5.强制初始化Bean(使用较少)"></a>5.强制初始化Bean(使用较少)</h5><p>Spring有一个默认的规则，总是先初始化主调Bean，然后在初始化依赖Bean。<br>为了指定Bean在目标Bean之前初始化，可以使用depends-on属性</p><h5 id="6-自动装配"><a href="#6-自动装配" class="headerlink" title="6.自动装配"></a>6.自动装配</h5><ul><li>Spring能自动装配Bean与Bean之间的依赖关系，即使无需使用ref显式指定依赖Bean。</li><li>自动装配可以减少配置文件的工作量，但是降低了依赖关系的透明性和依赖性。</li><li>可以根据指定属性值类型来缩小自动装配的范围(很少指定)</li><li><strong>| no | byName | byType | constructor | autodetect | </strong></li></ul><h5 id="7-依赖检察-使用较少"><a href="#7-依赖检察-使用较少" class="headerlink" title="7.依赖检察(使用较少)"></a>7.依赖检察(使用较少)</h5><p>Spring提供一种依赖检查的功能，可以防止出现配置手误，或者其他情况的错误。<br>dependency-check=”all” 该属性值可以为<strong>| none | simple | objects | all | </strong></p><h4 id="2-Spring核心机制-IoC-DI"><a href="#2-Spring核心机制-IoC-DI" class="headerlink" title="2.Spring核心机制:IoC/DI"></a>2.Spring核心机制:IoC/DI</h4><p>无论是<strong>IoC</strong>(控制反转) 还是<strong>DI</strong>(依赖注入),其含以上是互相包容的,在控制反转时便实现依赖注入</p><ul><li><strong>传统方法:</strong>当一个java实例(A)需要调用另一个java实例(B)时,需要在A中new一个B来构建</li><li><strong>Spring管理中:</strong>B对象的创建交给了Spring来管理(控制反转) | 将B对象注入给A对象的过程称为(依赖注入)</li></ul><h4 id="4-Spring-AOP"><a href="#4-Spring-AOP" class="headerlink" title="4.Spring AOP"></a>4.Spring AOP</h4><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h5><p> <strong>AOP</strong>（Aspect Oriented Programming），即面向切面编程，基于<strong>面向过程</strong></p><p>是<strong>OOP</strong>（Object Oriented Programming，面向对象编程）的补充和完善。 </p><p><strong>(OOP无法关注到程序的切入点,AOP具有更强大的切面控制力)</strong></p><p>例如:</p><ul><li>面向对象的流程是用户注册信息,然后插入到数据库中<br>   面向切面的流程是用户注册信息,在插入数据库前进行控    制,在插入数据库后进行控制</li></ul><p><strong>AOP使用横切技术,把软件系统分成两部分</strong><br><strong>核心关注点</strong>,特点:纵向关系为主,建立对象层次结构<br><strong>横切关注点</strong>,特点:横向关系为主,分布在核心关注点的周围,能够切开封装对象,对内部重复的部分进行重新封装,降低耦合性,如权限认证、日志、事务,AOP可以分离系统中的关注点,达到更高效的开发和运行</p><h5 id="2-五种横切方案"><a href="#2-五种横切方案" class="headerlink" title="2.五种横切方案"></a>2.五种横切方案</h5><ol><li><p>前置通知</p></li><li><p>后置正常通知</p></li><li>后置异常通知</li><li>后置始终通知</li><li>环绕通知</li></ol><h5 id="3-八大核心概念"><a href="#3-八大核心概念" class="headerlink" title="3.八大核心概念"></a>3.八大核心概念</h5><ol><li><p>Joinpoint 连接点<br> AOP执行程序的特定位置</p></li><li><p>PointCut 切点<br> AOP通过切点来确定特定的连接点位置</p></li><li><p>Advice 增强<br> 织入目标类连接点上的一段代码,可以描述程序,也可以确定方位,</p><pre><code>只有通过切点信息和方位信息,才能确定特定连接点并执行增强逻辑</code></pre></li><li><p>Target 目标对象<br> 增强逻辑的织入目标类</p></li><li><p>Introduction 引介<br> 特殊增强,给指定类添加属性和方法,也可以动态的添加接口的实现业务逻辑</p></li><li><p>weaving 织入</p><p> 增强 添加到 目标类 的 连接点 的过程,将目标,增强和引介很好的结合在了一起,AOP常用的三种织入技术</p><pre><code>编译期织入,这要求使用特殊的Java编译器.</code></pre><p> ​        类装载期织入,这要求使用特殊的类装载器.</p><p> ​        动态代理织入,在运行期为目标类添加增强生成子类的方式.</p><pre><code>Spring采用动态代理织入,而AspectJ采用编译期织入和类装载器织入.</code></pre></li><li><p>Proxy  代理</p><p> 目标被增强织入后生成一个新的代理类,该代理类可能和原类是一个接口,也可能是原类的子类,可以采用和原类相同的方法调用</p></li><li><p>Aspect 切面</p><p> 由增强和切点组成, [既包含横切逻辑的定义,也包括连接点的定义] ,能够把这两种定义织入到指定连接点中</p></li></ol><h5 id="4-AOP底层调用的两种代理机制"><a href="#4-AOP底层调用的两种代理机制" class="headerlink" title="4.AOP底层调用的两种代理机制"></a>4.AOP底层调用的两种代理机制</h5><ul><li><strong>JDK动态代理:</strong>针对接口类产生代理</li><li><strong>CGlib动态代理:</strong>针对没有实现接口的类产生代理,应用的是底层字节码增强技术,生成当前类的子类对象</li></ul><h3 id="5-Spring深入拓展"><a href="#5-Spring深入拓展" class="headerlink" title="5.Spring深入拓展"></a>5.Spring深入拓展</h3><h4 id="1-利用后处理器扩展Spring容器…"><a href="#1-利用后处理器扩展Spring容器…" class="headerlink" title="1.利用后处理器扩展Spring容器…"></a>1.利用后处理器扩展Spring容器…</h4><h4 id="2-Spring的“零配置”支持-注解"><a href="#2-Spring的“零配置”支持-注解" class="headerlink" title="2.Spring的“零配置”支持(注解)"></a>2.Spring的“零配置”支持(注解)</h4><pre><code>**| Component | Controller | Service | Repository | Scope | Resource | Autowired | Qualifier | JsonIgnore |**</code></pre><h4 id="3-资源访问…"><a href="#3-资源访问…" class="headerlink" title="3.资源访问…"></a>3.资源访问…</h4><p><strong>深入拓展传送门:<a href="https://www.cnblogs.com/shijiaoyun/p/7458341.html" target="_blank" rel="noopener">https://www.cnblogs.com/shijiaoyun/p/7458341.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring基础原理&quot;&gt;&lt;a href=&quot;#Spring基础原理&quot; class=&quot;headerlink&quot; title=&quot;Spring基础原理&quot;&gt;&lt;/a&gt;Spring基础原理&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-Spring概念&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="Spring全家桶" scheme="http://yoursite.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-MVC基础原理</title>
    <link href="http://yoursite.com/2018/07/15/Spring-MVC%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/15/Spring-MVC基础原理/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2018-07-15T14:00:16.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-MVC基础原理"><a href="#1-Spring-MVC基础原理" class="headerlink" title="1.Spring-MVC基础原理"></a>1.Spring-MVC基础原理</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>优秀的Web框架,具有<strong>松散耦合</strong>,<strong>拔插组件结构</strong>,<strong>注解驱动</strong>,<strong>REST风格支持</strong>等特性,比其他web框架更具有扩展性和灵活性</p><p>在<strong>数据绑定,视图解析,本地化处理,静态资源处理</strong>上有不俗的表现,远超Struts2,WebWork等MVC框架</p><p><img src="https://i.imgur.com/0vWxf3N.png" alt="springmvc"></p><h3 id="2-MVC框架"><a href="#2-MVC框架" class="headerlink" title="2.MVC框架"></a>2.MVC框架</h3><p>MVC全称 Model veiw Controller(模型视图控制器)  <strong>软件级的解耦分离</strong></p><ul><li>M:主要包含<strong>service</strong>(核心业务逻辑)和<strong>dao</strong>(数据库访问)</li><li>V:静态资源,如<strong>HTML5,JS,CSS</strong>等</li><li>C:<strong>servlet</strong>(主要处理<strong>页面的转发和重定向</strong>,<strong>数据的接收</strong>,<strong>域对象的操作</strong>,)和<strong>jsp</strong>(本身也是servlet)</li></ul><p>MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在<strong>不依赖业务逻辑的情况下专注于视图设计</strong>。同时也<strong>让应用程序的测试更加容易</strong>。 </p><p>MVC 分层同时也简化了分组开发。不同的开发人员可同时开发<strong>视图</strong>、<strong>控制器逻辑</strong>和<strong>业务逻辑</strong>。 </p><p><strong>(扩展)</strong>Spring MVC是基于 Model 2实现的技术框架,Model 2是经典的MVC(model,view,control)模型在WEB应用中的变体.这个改变主要源于HTTP协议的无状态性,Model 2 的目的和MVC一样,也是利用处理器分离模型,视图和控制,达到不同技术层级间松散层耦合的效果,提高系统灵活性,复用性和可维护性.大多情况下,可以将Model 2 与 MVC等同起来. </p><p><strong>(扩展)三层架构基础</strong></p><ul><li><p><strong>物理三层架构:</strong>客户端(如浏览器)/Web服务器/数据库服务器</p></li><li><p><strong>逻辑三层架构:</strong>表现层/业务逻辑层/数据库访问层</p></li></ul><h3 id="3-Spring-MVC体系概述"><a href="#3-Spring-MVC体系概述" class="headerlink" title="3.Spring MVC体系概述"></a>3.Spring MVC体系概述</h3><p>Spring-MVC围绕着<strong>DispatcherServlet(前段控制器)</strong>这个核心展开,所有的前端请求都会<strong>拦截经过这里</strong>分发到Spring MVC的各个处理器中处理,<strong>(扩展)</strong>如注解驱动控制器,请求及响应的信息处理,视图解析,本地化解析,上传文件解析,异常处理及表单标签绑定内容等…</p><h3 id="4-Spring-MVC核心组件"><a href="#4-Spring-MVC核心组件" class="headerlink" title="4.Spring MVC核心组件"></a>4.Spring MVC核心组件</h3><ul><li><strong>DispatcherServlet：</strong>作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 </li><li><strong>HandlerMapping：</strong>通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 </li><li><strong>HandlAdapter：</strong>通过扩展处理器适配器，支持更多类型的处理器,调用处理器传递参数等工作! </li><li><strong>ViewResolver：</strong>通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。 </li></ul><h3 id="5-Spring-MVC执行流程"><a href="#5-Spring-MVC执行流程" class="headerlink" title="5.Spring MVC执行流程"></a>5.<strong>Spring MVC执行流程</strong></h3><p><img src="https://i.imgur.com/gfPibwt.png" alt="mvc流程"></p><h3 id="6-DispatcherServlet"><a href="#6-DispatcherServlet" class="headerlink" title="6.DispatcherServlet"></a>6.DispatcherServlet</h3><h4 id="1-核心"><a href="#1-核心" class="headerlink" title="1.核心"></a>1.核心</h4><ol><li>DispatcherServlet 是Spring-MVC的核心构成,负责协调所有mvc的处理器,</li><li><strong>DispatcherServlet可以和Spring-IoC无缝集成,获得Spring的所有好处</strong></li><li>使用时需要在web.xml中对DispatcherServlet进行配置</li></ol><h4 id="2-DispatcherServlet继承关系图"><a href="#2-DispatcherServlet继承关系图" class="headerlink" title="2.DispatcherServlet继承关系图"></a>2.DispatcherServlet继承关系图</h4><p><img src="https://i.imgur.com/isTWyBE.png" alt="继承关系图"></p><h4 id="3-DispatcherServlet的责任"><a href="#3-DispatcherServlet的责任" class="headerlink" title="3.DispatcherServlet的责任"></a>3.DispatcherServlet的责任</h4><p>主要负责调度Spring-mvc的工作,并控制MVC的流程</p><ol><li>文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；</li><li>通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）；</li><li>通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)；</li><li>通过ViewResolver解析逻辑视图名到具体视图实现；</li><li>本地化解析；</li><li>渲染具体的视图等；</li><li>如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。</li></ol><h4 id="4-DispatcherServlet核心代码"><a href="#4-DispatcherServlet核心代码" class="headerlink" title="4.DispatcherServlet核心代码"></a>4.DispatcherServlet核心代码</h4><h4 id="5-DispatcherServlet辅助类"><a href="#5-DispatcherServlet辅助类" class="headerlink" title="5.DispatcherServlet辅助类"></a>5.DispatcherServlet辅助类</h4><h4 id="传送门-https-xuzhongcn-github-io-top"><a href="#传送门-https-xuzhongcn-github-io-top" class="headerlink" title="传送门:https://xuzhongcn.github.io/#top"></a>传送门:<a href="https://xuzhongcn.github.io/#top" target="_blank" rel="noopener">https://xuzhongcn.github.io/#top</a></h4><h3 id="7-常用注解-实用重点"><a href="#7-常用注解-实用重点" class="headerlink" title="7.常用注解(实用重点)"></a>7.常用注解(实用重点)</h3><h4 id="1-RequestMapping-请求方式"><a href="#1-RequestMapping-请求方式" class="headerlink" title="1.@RequestMapping 请求方式"></a>1.@RequestMapping 请求方式</h4><h4 id="2-RequestParam-处理请求参数"><a href="#2-RequestParam-处理请求参数" class="headerlink" title="2.@RequestParam 处理请求参数"></a>2.@RequestParam 处理请求参数</h4><h4 id="3-PathVariable-路径传参"><a href="#3-PathVariable-路径传参" class="headerlink" title="3.@PathVariable 路径传参"></a>3.@PathVariable 路径传参</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Spring-MVC基础原理&quot;&gt;&lt;a href=&quot;#1-Spring-MVC基础原理&quot; class=&quot;headerlink&quot; title=&quot;1.Spring-MVC基础原理&quot;&gt;&lt;/a&gt;1.Spring-MVC基础原理&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="Spring全家桶" scheme="http://yoursite.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/07/14/Log%E6%97%A5%E5%BF%97%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/14/Log日志整理/</id>
    <published>2018-07-14T02:56:49.420Z</published>
    <updated>2018-07-14T02:58:13.900Z</updated>
    
    <content type="html"><![CDATA[<p>slf4j</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DonY15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018\7\14 0014</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger log = LoggerFactory.getLogger(test01.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"Here is some DEBUG"</span>);</span><br><span class="line">        log.info(<span class="string">"Here is some INFO"</span>);</span><br><span class="line">        log.warn(<span class="string">"Here is some WARN"</span>);</span><br><span class="line">        log.error(<span class="string">"Here is some ERROR"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;slf4j&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>服务器搭建(持续更新)</title>
    <link href="http://yoursite.com/2018/07/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/07/14/服务器搭建/</id>
    <published>2018-07-13T16:00:00.000Z</published>
    <updated>2018-07-14T12:19:03.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器搭建集合"><a href="#服务器搭建集合" class="headerlink" title="服务器搭建集合"></a>服务器搭建集合</h2><p>[TOC]</p><h3 id="1-ShadowsocksR多用户一件脚本"><a href="#1-ShadowsocksR多用户一件脚本" class="headerlink" title="1.ShadowsocksR多用户一件脚本"></a>1.ShadowsocksR多用户一件脚本</h3><p><strong>系统要求:</strong>CentOS 6+ / Debian 6+ / Ubuntu 14.04 +</p><p>脚本特点：</p><p>所有步骤都可以通过 Shell 脚本中文交互 操作。</p><ul><li>支持 限制 用户速度</li><li>支持 限制 用户设备数</li><li>支持 限制 用户总流量</li><li>支持 定时 流量清零</li><li>支持 显示 当前连接IP</li><li>支持 显示 SS/SSR连接+二维码</li><li>支持 一键安装 BBR</li><li>支持 一键安装 锐速</li><li>支持 一键安装 LotServer</li><li>支持 一键封禁 垃圾邮件(SMAP)/BT/PT</li></ul><p><strong>一键安装指令:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https://makeai.cn/bash/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh</span><br></pre></td></tr></table></figure><p><strong>文件位置</strong></p><p><strong>安装目录：</strong>/usr/local/shadowsocksr</p><p><strong>配置文件：</strong>/usr/local/shadowsocksr/user-config.json</p><p><strong>数据文件：</strong>/usr/local/shadowsocksr/mudb.json</p><ul><li><strong>启动 ShadowsocksR：</strong>service ssrmu start</li><li><strong>停止 ShadowsocksR：</strong>service ssrmu stop</li><li><strong>重启 ShadowsocksR：</strong>service ssrmu restart</li><li><strong>查看 ShadowsocksR状态：</strong>service ssrmu status</li></ul><p><strong>Linux中提示-bash: wget: command not found的解决方法</strong><br>    CentOS:yum install wget -y<br>    Debian/Ubuntu:apt-get install -y wget</p><p><strong>详细传送门:<a href="https://www.bbaaz.com/thread-7-1-1.html" target="_blank" rel="noopener">https://www.bbaaz.com/thread-7-1-1.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务器搭建集合&quot;&gt;&lt;a href=&quot;#服务器搭建集合&quot; class=&quot;headerlink&quot; title=&quot;服务器搭建集合&quot;&gt;&lt;/a&gt;服务器搭建集合&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-ShadowsocksR多用户一件脚本&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Zookeeper与Dubbo基础原理</title>
    <link href="http://yoursite.com/2018/07/08/Zookeeper%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/08/Zookeeper基础原理/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-12T06:15:08.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Zookeeper与Dubbo基础原理"><a href="#Zookeeper与Dubbo基础原理" class="headerlink" title="Zookeeper与Dubbo基础原理"></a>Zookeeper与Dubbo基础原理</h3><p>[TOC]</p><h4 id="Zookeeper-RPC框架"><a href="#Zookeeper-RPC框架" class="headerlink" title="Zookeeper(RPC框架)"></a>Zookeeper(RPC框架)</h4><p><strong>高效的分布式分布式应用协调服务,提供注册和负载均衡等–&gt;服务中心</strong></p><ul><li>zookeeper让调用者知道调用的哪台服务器地址,也是集群的管理者</li><li>Zookeeper具有心跳检测机制,当服务器挂掉时可以让调用者知道,从而切换请求服务器</li><li>Zookeeper具有高并发的横向扩展,在不改变代码的情况下对设备进行扩展</li></ul><p><strong>1.命名服务   2.配置管理   3.集群管理   4.分布式锁  5.队列管理</strong> </p><p>命名服务:在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现。 </p><p>配置管理:程序分散部署在多台机器上难以管理,可以将每台设备的信息存储在Zookeeper的目录节点中,然后相关程序对该目录进行监控,如果配置信息发生变化,则Zookeeper会发布新的配置</p><p>集群管理:(1)设备的加入(2)选举master(可以改变设备编号,编号第一位自动master(一种思路))</p><p>分布式锁:zookeeper是一致性的文件系统,锁服务可以分为两类，(1)保持独占，(2)控制时序。  </p><p>列队管理:</p><ol><li>同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。  </li><li>队列按照 FIFO 方式进行入队和出队操作。和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。   </li></ol><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ol><li>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper<strong>最重要的性能</strong>。 </li><li>可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。 </li><li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。  </li><li>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。  </li><li>原子性：更新只能成功或者失败，没有中间状态。  </li><li>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。  </li></ol><h5 id="Zookeeper工作原理"><a href="#Zookeeper工作原理" class="headerlink" title="Zookeeper工作原理"></a>Zookeeper工作原理</h5><p>​    Zookeeper 的核心是<strong>原子广播</strong>，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做<strong>Zab协议</strong>。Zab协议有两种模式，它们分别是<strong>恢复模式</strong>（选主）和<strong>广播模式</strong>（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态 </p><p>​    为了保证事务的<strong>顺序一致性</strong>，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。 </p><p><strong>(部分整理)</strong></p><p><strong>原文:<a href="https://blog.csdn.net/xqb_756148978/article/details/52259381" target="_blank" rel="noopener">https://blog.csdn.net/xqb_756148978/article/details/52259381</a></strong></p><h4 id="Dubbo-SOA基础框架"><a href="#Dubbo-SOA基础框架" class="headerlink" title="Dubbo(SOA基础框架)"></a>Dubbo(SOA基础框架)</h4><p><strong>管理中间层的框架,与注册中心搭配使用,如Zookeeper(最常用),使之具有Zookeeper负载均衡/资源同步等的特性</strong></p><p><strong>单一应用架构</strong>(ORM) –&gt;<strong>垂直应用架构</strong>(MVC)–&gt;<strong>分布式服务架构</strong>(RPC)–&gt;<strong>流动计算架构</strong>(SOA) </p><h5 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h5><ol><li>远程通讯 </li><li>集群容错 </li><li>自动发现 </li></ol><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li><strong>透明化的远程方法调用</strong>，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入   </li><li><strong>软负载均衡及容错机制</strong>，可在内网替代F5等硬件负载均衡器，降低成本，减少单点.</li><li><strong>服务自动注册与发现</strong>，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ol><p>Dubbo采用全spring配置方式,透明化接入,应用,没有API入侵</p><h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><p><img src="https://i.imgur.com/zNpr0bk.jpg" alt=""></p><pre><code>Provider: 暴露服务的服务提供方。</code></pre><p>​       Consumer: 调用远程服务的服务消费方。</p><p>​       Registry: 服务注册与发现的注册中心。</p><p>​       Monitor: 统计服务的调用次调和调用时间的监控中心.</p><p>​    Container]: 服务运行器。</p><h5 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a>调用关系说明：</h5><ol start="0"><li><p>服务容器负责启动，加载，运行服务提供者。</p></li><li><p>服务提供者在启动时，向注册中心注册自己提供的服务。</p></li><li><p>服务消费者在启动时，向注册中心订阅自己所需的服务。</p></li><li><p>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p></li><li><p>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p></li><li><p>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p></li></ol><p><strong>收藏Dubbo架构详解<a href="http://shiyanjun.cn/archives/325.html" target="_blank" rel="noopener">http://shiyanjun.cn/archives/325.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Zookeeper与Dubbo基础原理&quot;&gt;&lt;a href=&quot;#Zookeeper与Dubbo基础原理&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper与Dubbo基础原理&quot;&gt;&lt;/a&gt;Zookeeper与Dubbo基础原理&lt;/h3&gt;&lt;p&gt;[T
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>基础排序 组合</title>
    <link href="http://yoursite.com/2018/07/08/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%20%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2018/07/08/基础排序 组合/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-12T06:15:12.179Z</updated>
    
    <content type="html"><![CDATA[<p><strong>规范:()中,先写下,在写上</strong></p><p>[TOC]</p><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><p>转换为计算机写法<strong>A(n,m)</strong>     n在下  m在上</p><p>​    即:n个数中取m个来排序</p><h3 id="2-组合"><a href="#2-组合" class="headerlink" title="2.组合"></a>2.组合</h3><p>转换为计算机写法<strong>C(n,m)</strong>    n在下 m在上</p><p>​    即: 分子:n的阶乘,阶乘的个数为m</p><p>​          分母:m的阶乘</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;规范:()中,先写下,在写上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-排序&quot;&gt;&lt;a href=&quot;#1-排序&quot; class=&quot;headerlink&quot; title=&quot;1.排序&quot;&gt;&lt;/a&gt;1.排序&lt;/h3&gt;&lt;p&gt;转换为计算机写法&lt;s
      
    
    </summary>
    
      <category term="初等数学" scheme="http://yoursite.com/categories/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>实用工具类集合</title>
    <link href="http://yoursite.com/2018/07/08/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2018/07/08/实用工具类集合/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-12T06:15:14.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实用工具类集合"><a href="#实用工具类集合" class="headerlink" title="实用工具类集合"></a>实用工具类集合</h3><p>[TOC]</p><p><strong>简述</strong></p><p>该工具类集合章会持续更新,具体工具类会集成到我的GitHub仓库中</p><p><strong>传送门</strong></p><p><strong><a href="https://github.com/dony15/mymodes" target="_blank" rel="noopener">https://github.com/dony15/mymodes</a></strong></p><h4 id="1-js-utils-js"><a href="#1-js-utils-js" class="headerlink" title="1.js-utils.js"></a>1.js-utils.js</h4><p>常用js的前段封装</p><ol><li><p>XMLHttpRequest 原生ajax的获取 ,内置了Chrome和IE的兼容转换</p></li><li><p>图片上传功能前段,四个id解决 | 图片 | 表单 | 回显 | 的结合</p></li><li><p>验证码显示和输入框校验 两个id 一个url 即可解决 | 校验 | 提示 | 提交url |的结合</p></li><li><p>点击切换验证码 id和url </p></li></ol><h4 id="2-pattern-js"><a href="#2-pattern-js" class="headerlink" title="2.pattern.js"></a>2.pattern.js</h4><p>包含开发中各种验证常用的正则封装</p><h4 id="2-CollectionsFactory"><a href="#2-CollectionsFactory" class="headerlink" title="2.CollectionsFactory"></a>2.CollectionsFactory</h4><p>包含各种集合类型的构建,静态工具类,使代码看起来更加<strong>规范简洁</strong></p><h4 id="3-DownloadUtil"><a href="#3-DownloadUtil" class="headerlink" title="3.DownloadUtil"></a>3.DownloadUtil</h4><p>文件下载工具类,根据文件名或者文件路径获取文件进行下载(多场景的封装)</p><h4 id="3-FileUtil"><a href="#3-FileUtil" class="headerlink" title="3.FileUtil"></a>3.FileUtil</h4><p>非常实用的文件处理工具,如获取文件名/去重/清空但不删除文件夹/磁盘遍历/xml生成等等…</p><h4 id="4-FormatStyle"><a href="#4-FormatStyle" class="headerlink" title="4.FormatStyle"></a>4.FormatStyle</h4><p>文件容量单位的格式转换,主要解决特殊情况下<strong>因为数字太大导致java直接写无法识别的</strong></p><h4 id="5-IDUtils"><a href="#5-IDUtils" class="headerlink" title="5.IDUtils"></a>5.IDUtils</h4><p>ID的多种生成策略</p><h4 id="5-JsonUtils"><a href="#5-JsonUtils" class="headerlink" title="5.JsonUtils"></a>5.JsonUtils</h4><p>使用jackson,多种类型和json的转化封装 <strong>对象 | List</strong></p><h4 id="6-ResourcesUtil"><a href="#6-ResourcesUtil" class="headerlink" title="6.ResourcesUtil"></a>6.ResourcesUtil</h4><p>资源读取工具类,较为特殊,使用较少(主要是国际语言的匹配读取,现在前段控制即可)</p><h4 id="7-UtilFuns"><a href="#7-UtilFuns" class="headerlink" title="7.UtilFuns"></a>7.UtilFuns</h4><p>该工具类非常的丰富.各种SE的基础转换和时间/固定长度转换/编码解码等都有涉猎</p><h4 id="其他中文命名工具类不再解释-简单明了"><a href="#其他中文命名工具类不再解释-简单明了" class="headerlink" title="其他中文命名工具类不再解释(简单明了)"></a>其他中文命名工具类不再解释(简单明了)</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实用工具类集合&quot;&gt;&lt;a href=&quot;#实用工具类集合&quot; class=&quot;headerlink&quot; title=&quot;实用工具类集合&quot;&gt;&lt;/a&gt;实用工具类集合&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该工具类集合章会持续
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>工具类集合分析--接口</title>
    <link href="http://yoursite.com/2018/07/08/%E5%B7%A5%E5%85%B7%E7%B1%BB%E9%9B%86%E5%90%88%E5%88%86%E6%9E%90--%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/07/08/工具类集合分析--接口/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-12T06:15:22.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具类集合分析–接口"><a href="#工具类集合分析–接口" class="headerlink" title="工具类集合分析–接口"></a>工具类集合分析–接口</h3><p>[TOC]</p><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>使用接口作为工具类,一般分两种情况</p><p>​    (1)定义常量</p><p>​    (2)定义动态工具类</p><h4 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h4><h5 id="1-定义常量"><a href="#1-定义常量" class="headerlink" title="1.定义常量"></a>1.定义常量</h5><p>可以在工具类中快捷明了的定义常量来使用,因为接口中默认属性便是常量,如:</p><p>​    int HOTEL_STATUS_INVALID=0;//酒店失效</p><p>​    int HOTEL_STATUS_VALID=1;//酒店有效</p><p>当controller中往前端传递数据时,需要判断状态,而状态从controller中多次定义会导致观察不变,不利于交接和后期维护,此时便可以将状态抽出来存进接口工具类中,提高代码的<strong>可读性</strong>和<strong>开发效率</strong> (RestFull开发风格中,提高代码可读性尤为突出)</p><h5 id="2-定义动态工具类"><a href="#2-定义动态工具类" class="headerlink" title="2.定义动态工具类"></a>2.定义动态工具类</h5><p>当程序运行在不同的环境中时,因为程序对环境的耦合性,频繁的修改代码会大大降低开发效率,可以使用工具类接口的方式,将耦合性降低,如<strong>动态工具类</strong></p><p><strong>场景</strong></p><p>​    redis 单机版和集群版    (可以根据需要选择具体的方案,减少代码的修改量)</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;工具类集合分析–接口&quot;&gt;&lt;a href=&quot;#工具类集合分析–接口&quot; class=&quot;headerlink&quot; title=&quot;工具类集合分析–接口&quot;&gt;&lt;/a&gt;工具类集合分析–接口&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Solr基础原理</title>
    <link href="http://yoursite.com/2018/07/06/Solr%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/06/Solr基础原理/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-07-12T06:15:03.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Solr基础原理"><a href="#Solr基础原理" class="headerlink" title="Solr基础原理"></a>Solr基础原理</h3><p>[TOC]</p><h4 id="1-目录核心组成"><a href="#1-目录核心组成" class="headerlink" title="1.目录核心组成"></a>1.目录核心组成</h4><p><strong>1.core</strong></p><p>​    solr的索引库,可以理解为数据库,需要手动创建(文件夹),core可以根据需要建立多个索引库,索引库的内容可以在后台看到也可以在core中看到</p><p><strong>2.solrhome</strong></p><p>​    solr的配置目录,solr服务器所有的配置文件存放的目录(<strong>core创建在solrhome中</strong>)</p><p><strong>3.collection</strong></p><p>​    solr的逻辑索引(逻辑意义上的完整索引),由多个shard的组成,每个shard又由一个leadereplica和多个replica,每个replica都是物理索引,即每个replica都对应着一个core,collection本质是可以跨越多个核的索引,包含冗余的索引.</p><p><strong>参考<a href="https://blog.csdn.net/zhousenshan/article/details/51799567" target="_blank" rel="noopener">https://blog.csdn.net/zhousenshan/article/details/51799567</a></strong></p><h4 id="2-配置详解"><a href="#2-配置详解" class="headerlink" title="2.配置详解"></a>2.配置详解</h4><h5 id="1-配置中文分词"><a href="#1-配置中文分词" class="headerlink" title="1.配置中文分词"></a>1.配置中文分词</h5><ol><li><fieldtype name="text_ik" class="solr.TextField">   <!-- text_ik 中文分词包的引用名 --></fieldtype></li><li><analyzer class="org.wltea.analyzer.lucene.IKAnalyzer">  <!-- 中文分词包 --></analyzer></li><li></li><li><!-- 字段title 使用中文分词 stored="true"下载并索引 --></li><li><field name="item_title" type="text_ik" indexed="true" stored="true"> </field></li><li><!-- 字段price 使用long类型 --></li><li><field name="item_price" type="long" indexed="true" stored="true"></field></li><li><!-- city_id 使用long类型 --></li><li><field name="item_city_id" type="long" indexed="true" stored="true"> </field></li><li><!-- city_name 因为城市名固定,所以不需要分词,String即可 --></li><li><field name="item_city_name" type="string" indexed="true" stored="true"></field></li><li><!-- image 图片地址,String类型 --></li><li><field name="item_image" type="string" indexed="true" stored="true"></field></li><li><!-- content 中文分词 stored="false"(不下载,但可以索引) --></li><li><field name="item_content" type="text_ik" indexed="true" stored="false"></field></li><li><!-- item_keywords 自定义查询名(关键字);可以根据title||city_name||content来查询 --></li><li><field name="item_keywords" type="text_ik" indexed="true" stored="false" multivalued="true"></field></li><li><copyfield source="item_title" dest="item_keywords"></copyfield></li><li><copyfield source="item_city_name" dest="item_keywords"></copyfield></li><li><copyfield source="item_content" dest="item_keywords"></copyfield></li></ol><ol><li><!-- 默认使用item_keywords(Solr后台分词查询中显示自定义的字段) --></li><li><requesthandler name="/select" class="solr.SearchHandler"></requesthandler></li><li>​    &lt;!– default values for query parameters can be specified, these</li><li>​         will be overridden by parameters in the request</li><li>​      –&gt;</li><li>​     <lst name="defaults"></lst></li><li>​       <str name="echoParams">explicit</str></li><li>​       <str name="df">item_keywords</str></li><li>​        <int name="rows">10</int></li></ol><ol><li><!-- 默认使用item_keywords(开启查询) --></li><li><requesthandler name="/query" class="solr.SearchHandler"></requesthandler></li><li>​     <lst name="defaults"></lst></li><li>​       <str name="echoParams">explicit</str></li><li>​       <str name="wt">json</str></li><li>​       <str name="indent">true</str></li><li>​       <str name="df">item_keywords</str></li><li>​     </li><li></li></ol><h5 id="2-配置Solr-Dataimport"><a href="#2-配置Solr-Dataimport" class="headerlink" title="2.配置Solr Dataimport"></a>2.配置Solr Dataimport</h5><ol><li><!-- dataimport 开启Solr连接数据库功能 --></li><li><requesthandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler"> </requesthandler></li><li>​    <lst name="defaults">      </lst></li><li><!-- dataimport读取data-config.xml设定的JDBC配置文件 -->   </li><li>​         <str name="config">data-config.xml</str> </li><li>​              </li><li>  </li></ol><ol><li><dataconfig>       </dataconfig></li><li><!-- JDBC配置 --></li><li>​    <datasource type="JdbcDataSource" driver="com.mysql.jdbc.Driver" url="jdbc:mysql://localhost:3306/travel_db?characterEncoding=utf-8" user="root" password="root" batchsize="-1">   </datasource></li><li>​    <document>   </document></li><li><!-- 查询语句(全表查询)字段,并匹配分词中设定的name -->  </li><li>​        <entity name="hotel" query="select ID,TITLE,PRICE,IMAGE,CITY_NAME, CITY_ID from HOTEL" datasource="JdbcDataSource">        </entity></li><li>​            <field column="ID" name="id"> </field></li><li>​            <field column="TITLE" name="item_title"> </field></li><li>​                            <field column="PRICE" name="item_price"> </field></li><li>​                            <field column="CONTENT" name="item_content"></field></li><li><field column="IMAGE" name="item_image"></field></li><li>​                            <field column="CITY_NAME" name="item_city_name"></field></li><li><field column="CITY_ID" name="item_city_id"></field></li><li>​                </li><li>​            </li><li>  </li></ol><h5 id="3-Solr后台的使用"><a href="#3-Solr后台的使用" class="headerlink" title="3.Solr后台的使用"></a>3.Solr后台的使用</h5><p>第一次先Dataimport–&gt;Execute导入,然后Refresh刷新状态即可</p><p><strong>Query:查询功能</strong> </p><p>​    q  <em> ; </em>    –&gt;第一个 <em> 表示字段; 第二个 </em> 表示字段的内容;  </p><p>​    如    item_keywords:北京   分词中有”北京”关键字的内容</p><p>​        item_price:[* TO 200]  价格是200以内的内容</p><p>​        item_price:[100 TO 700]  价格是100-200的内容</p><h4 id="3-java中的作用"><a href="#3-java中的作用" class="headerlink" title="3.java中的作用"></a>3.java中的作用</h4><p>建立一个新的索引模块 index,接口层和实现发布层</p><p>写Solr<strong>更新</strong>和<strong>搜索</strong>两个方法dubbo发布即可在controller中使用</p><p>(一般与MQ一起使用,如activeMQ,见<strong>activeMQ基础与运用章节</strong>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Solr基础原理&quot;&gt;&lt;a href=&quot;#Solr基础原理&quot; class=&quot;headerlink&quot; title=&quot;Solr基础原理&quot;&gt;&lt;/a&gt;Solr基础原理&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;1-目录核心组成&quot;&gt;&lt;a href=&quot;#1-目录核心组成
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>FastDFS 基础原理</title>
    <link href="http://yoursite.com/2018/07/06/FastDfs%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/06/FastDfs基础原理/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-07-12T06:14:28.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FastDFS-基础原理"><a href="#FastDFS-基础原理" class="headerlink" title="FastDFS 基础原理"></a>FastDFS 基础原理</h2><p>[TOC]</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>Depth First Search </p><p><strong>无向图算法概念</strong>(一种递归原理)</p><p>先按照一条边进行搜索,当遇到第一个节点时,对它相邻的其他节点进行搜索并标记为已查找的节点(会查找完第一条节点的最深层后返回)<br>详细见算法目录(持续更新)</p><p><img src="http://i.imgur.com/vJ23ZgT.jpg" alt="&quot;无向图算法图片&quot;的图片搜索结果"></p><h3 id="FastDFS–结构"><a href="#FastDFS–结构" class="headerlink" title="FastDFS–结构"></a>FastDFS–结构</h3><h2 id="1">FastDFS 架构–结构</h2><p><strong>FastDFS服务有三个角色:跟踪服务器(tracker server)、存储服务器(storage server)和客户端(client)</strong></p><p>主要解决了海量数据存储问题 ,特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。 </p><h4 id="跟踪器Tracker"><a href="#跟踪器Tracker" class="headerlink" title="跟踪器Tracker :"></a>跟踪器Tracker :</h4><p>主要做调度工作，相当于mvc中的controller的角色，在访问上起负载均衡的作用。跟踪器和存储节点都可以由一台或多台服务器构成，跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务，其中<strong>跟踪器</strong>中的所有服务器都是<strong>对等</strong>的，可以根据服务器的压力情况随时增加或减少。 </p><p>跟踪器Tracker负责管理所有的Storage和group，本身不需要持久化任何数据,直接增加机器就可以拓展tracker,每个Storage在启动后会连接Tracker，并周期性保持联系.</p><h4 id="存储服务器Storage"><a href="#存储服务器Storage" class="headerlink" title="存储服务器Storage:"></a>存储服务器Storage:</h4><p>以group为最小单位,方便实现 应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数）,建议同一group内的配置尽量相同,减少资源浪费(storage依赖于本地文件系统)</p><h4 id="客户端Client"><a href="#客户端Client" class="headerlink" title="客户端Client:"></a>客户端Client:</h4><p><strong>基本文件访问接口:</strong>比如upload、download、append、delete等，以客户端库的方式提供给用户使用。 </p><h3 id="FastDFS–运行"><a href="#FastDFS–运行" class="headerlink" title="FastDFS–运行"></a>FastDFS–运行</h3><p><strong>tracker</strong></p><p>当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个trakcer。</p><p><strong>group</strong></p><p>当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group，支持如下选择group的规则：</p><ol><li>Round robin，所有的group间轮询 </li><li>Specified group，指定某一个确定的group </li><li>Load balance，剩余存储空间多多group优先</li></ol><p><strong>storage</strong></p><p>当选定group后，tracker会在group内选择一个storage server给客户端，支持如下选择storage的规则： </p><ol><li>Round robin，在group内的所有storage间轮询 </li><li>First server ordered by ip，按ip排序 </li><li>First server ordered by priority，按优先级排序（优先级在storage上配置）</li></ol><p><strong>storage path</strong></p><p>当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录，支持如下规则： </p><ol><li>Round robin，多个存储目录间轮询 </li><li>剩余存储空间最多的优先</li></ol><p><strong>Fileid</strong></p><p>选定存储目录之后，storage会为文件生一个Fileid，<br>由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，<br>然后将这个二进制串进行base64编码，转换为可打印的字符串。</p><p><strong>选择两级目录</strong></p><p>当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash（猜测），路由到其中一个子目录，然后将文件以fileid为文件名存储到该子目录下。</p><p><strong>生成文件名</strong> </p><p>当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。</p><p><strong>文件同步</strong></p><p>写文件时，客户端将文件写至group内一个storage server即认为写文件成功，<br>storage server写完文件后，会由后台线程将文件同步至 [同group] 内其他的storage server。<br>storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。</p><p><strong>Download file</strong></p><p>客户端upload file成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。</p><h3 id="FastDFS–特点"><a href="#FastDFS–特点" class="headerlink" title="FastDFS–特点"></a>FastDFS–特点</h3><h4 id="小文件合并存储"><a href="#小文件合并存储" class="headerlink" title="小文件合并存储"></a>小文件合并存储</h4><p><strong>解决问题:</strong></p><ol><li>本地文件系统inode数量有限，从而存储的小文件数量也就受到限制。 </li><li>多级目录+目录里很多文件，导致访问文件的开销很大（可能导致很多次IO） </li><li>按小文件存储，备份与恢复的效率低</li></ol><p>FastDFS在V3.0版本里引入小文件合并存储的机制，可将多个小文件存储到一个大的文件（trunk file），为了支持这个机制，FastDFS生成的文件fileid需要额外增加16个字节 </p><h4 id="HTTP访问支持"><a href="#HTTP访问支持" class="headerlink" title="HTTP访问支持"></a>HTTP访问支持</h4><p>客户端可以通过http协议来下载文件，tracker在接收到请求时，通过http的redirect机制将请求[重定向]至文件所在的storage上；除了内置的http协议外，FastDFS还提供了通过apache或nginx扩展模块下载文件的支持。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>group机制本身可用来做负载均衡，但这只是一种静态的负载均衡机制，需要预先知道应用的访问特性；同时group机制也导致不可能在group之间迁移数据来做动态负载均衡。</p><h3 id="FastDFS–使用小结"><a href="#FastDFS–使用小结" class="headerlink" title="FastDFS–使用小结"></a>FastDFS–使用小结</h3><ol><li>分别配置Tracker地址(上传存储使用)和Storage地址(响应回显使用)</li><li>接收前段file文件后,将名字拆分重塑后存储</li><li>响应url则拼接Storage地址生成</li><li>每次上传文件后都会返回一个地址，用户需要自己保存此地址。</li><li>前段设计:将整个编辑内容存进一个由事件控制的表单,当图片上传的时候不会影响到表单的完整性,而且可以依靠上传时间来动态生成回显方案,将url放进input中,清除不必要的组件(可能影响表单提交完整性的部分)</li><li>为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。</li></ol><p><strong>注意:spring-mvc中除了要配置上传解析器之外,还需要将String的字符串指定为UTF-8(默认8859-1)</strong></p><h3 id="FastDFS原理系列文章-转发"><a href="#FastDFS原理系列文章-转发" class="headerlink" title="FastDFS原理系列文章(转发)"></a>FastDFS原理系列文章(转发)</h3><p><strong><a href="https://blog.csdn.net/hfty290/article/details/42076205" target="_blank" rel="noopener">https://blog.csdn.net/hfty290/article/details/42076205</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FastDFS-基础原理&quot;&gt;&lt;a href=&quot;#FastDFS-基础原理&quot; class=&quot;headerlink&quot; title=&quot;FastDFS 基础原理&quot;&gt;&lt;/a&gt;FastDFS 基础原理&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;深度优先搜索&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>ActiveMQ基础与运用</title>
    <link href="http://yoursite.com/2018/07/06/activeMQ%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%90%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/06/activeMQ基础与运用/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2018-07-12T06:14:21.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ActiveMQ基础与运用"><a href="#ActiveMQ基础与运用" class="headerlink" title="ActiveMQ基础与运用"></a>ActiveMQ基础与运用</h3><p>[TOC]</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>消息队列:<strong>即时消息通信</strong>和<strong>延时消息通信</strong></p><p>ActiveMQ底层基于java的JMS实现,在没有JMS之前的系统存在很多缺陷:</p><ol><li>前后端同步问题,如果后台没有响应,则前段会一直阻塞等待</li><li>前后端生命周期耦合性太强,一方崩了则另一方也会崩</li><li>点对点通信,前段一次只能发送给某一个单独的服务对象,无法群发</li></ol><p><strong>JMS:</strong> (Java Message Service ) 通过消息中间件(MOM：Message Oriented Middleware )</p><p>将消息发送给单独的消息服务器中,消息服务器会将消息存放在若干的队列/主题中,在合适的时候将消息发送给接收者.<strong>发送和接收是异步的,无需阻塞等待</strong> 在pub/sub的模式下,可以将消息发送给多个接收者</p><p><strong>JMS类中定义了java访问中间件的接口,除此之外都是异常定义</strong></p><ol><li>Provider/MessageProvider：生产者 </li><li>Consumer/MessageConsumer：消费者 </li><li>PTP：Point To Point，点对点通信消息模型 </li><li>Pub/Sub：Publish/Subscribe，发布订阅消息模型 </li><li><strong>Queue</strong>：队列，目标类型之一，和PTP结合 </li><li><strong>Topic</strong>：主题，目标类型之一，和Pub/Sub结合 </li><li>ConnectionFactory：连接工厂，JMS用它创建连接 </li><li>Connnection：JMS Client到JMS Provider的连接 </li><li>Destination：消息目的地，由Session创建 </li><li><strong>Session</strong>：会话，由Connection创建，实质上就是发送、接受消息的一个线程，因此生产者、消费者都是Session创建的 </li></ol><h4 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h4><p><strong>| 异步处理 | 应用解耦 | 流量削锋 | 消息通讯 |</strong></p><p><strong>详情参考:<a href="https://blog.csdn.net/kingcat666/article/details/78660535" target="_blank" rel="noopener">https://blog.csdn.net/kingcat666/article/details/78660535</a></strong></p><h4 id="3-消息模式"><a href="#3-消息模式" class="headerlink" title="3.消息模式"></a>3.消息模式</h4><ul><li><strong>P2P模式(点对点)</strong></li><li><strong>Pub/Sub模式(发布订阅)</strong></li><li><strong>Push模式(推拉模式,消息更新C/S中)</strong></li></ul><h4 id="4-java中与Solr结合"><a href="#4-java中与Solr结合" class="headerlink" title="4.java中与Solr结合"></a>4.java中与Solr结合</h4><p>ActiveMQ以监视器的方式将信息与Solr结合使用…待更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ActiveMQ基础与运用&quot;&gt;&lt;a href=&quot;#ActiveMQ基础与运用&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ基础与运用&quot;&gt;&lt;/a&gt;ActiveMQ基础与运用&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;1-概念&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Shiro基础原理</title>
    <link href="http://yoursite.com/2018/07/04/Shiro%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/04/Shiro基础原理/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-14T15:31:37.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shiro基础原理"><a href="#Shiro基础原理" class="headerlink" title="Shiro基础原理"></a>Shiro基础原理</h2><p>[TOC]</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><strong>shiro是apache的一个开源框架，实现 |认证|授权|为核心的一系列权限管理框架.</strong></p><ul><li>Web 应用程序一般做法通过表单提交用户名及密码达到认证目的。 </li><li>“授权”即是否允许已认证用户访问受保护资源。 </li></ul><h3 id="2-对比"><a href="#2-对比" class="headerlink" title="2.对比"></a>2.对比</h3><p><strong>Shiro与Spring Security</strong></p><ol><li>简单性:shiro更加简单,更容易理解</li><li>灵活性:shiro可以使用在 |Web|EJB|IoC| 等大部分的应用环境,而Spring Security必须和Spring一起集成使用</li><li>拔插性:shiro干净的API(工具类集合)和设计模式(单例+工厂)使它可以方便的和许多其他框架整合,Spring Security则只能与Spring一起集成</li></ol><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成"></a>3.组成</h3><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/1b7bc2c3-9f2c-4ea2-8ed7-97820c205482/128/index_files/871676-20160722213407794-1894786938.png" alt="img"></p><h4 id="1-三个核心组件"><a href="#1-三个核心组件" class="headerlink" title="1.三个核心组件"></a>1.三个核心组件</h4><ol><li>Subject: 令牌与项目的登录关系,Shiro保证了项目整体的安全性,是<strong>Shiro对外API的核心</strong></li><li>Security Manager:负责安全认证预授权等  <strong>Shiro的核心</strong> </li><li>Realm:整个框架中<strong>必须</strong>由设计者自行实现的模块之一.并且Shiro支持多个<strong>Realm数据源</strong>,最为重要的一种实现方式—&gt;数据库查询,当需要多个数据库组合验证时,多个数据源的效果就体现出来</li></ol><hr><h4 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2.主要功能"></a>2.主要功能</h4><ol><li>Authentication:    身份认证</li><li>Authorization:  授权,权限验证</li><li>Session Manager: 会话管理</li><li>Cryptography:加密</li><li>Web Support: web支持</li><li>Caching:缓存</li><li>Concurrency:多线程验证</li><li>Testing:提供测试支持</li><li>Run As:允许一个用户假装另一个用户访问</li><li>Remember Me: 记住我</li></ol><h4 id="3-组件和内容流程分析"><a href="#3-组件和内容流程分析" class="headerlink" title="3.组件和内容流程分析"></a>3.组件和内容流程分析</h4><h5 id="1-subject"><a href="#1-subject" class="headerlink" title="1.subject"></a>1.subject</h5><p>外部API核心,存储用户数据和返回数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure><p><strong>获得Subject的方法,有了Subject才能和Shiro做深入的交互</strong></p><h5 id="2-SessionManager"><a href="#2-SessionManager" class="headerlink" title="2.SessionManager"></a>2.SessionManager</h5><ol><li><p>Shiro的Session提供了HttpSession常规的大部分功能,但是又有区别,即:Session不依赖于<strong>HTTP环境</strong>,可以在程序任何地方使用</p></li><li><p>Shiro的Session可以在任何的环境下使用<strong>相同的API</strong>,而且是<strong>自动启动SessionManager</strong></p></li></ol><p>如果希望在*<em>当前与应用程序会话期间</em>,为用户提供内容,则可以设置Session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session session = currentUser.getSession();</span><br><span class="line">session.setAttribute( &quot;someKey&quot;, &quot;aValue&quot; );</span><br></pre></td></tr></table></figure><h5 id="3-登录认证Authentication"><a href="#3-登录认证Authentication" class="headerlink" title="3.登录认证Authentication"></a>3.登录认证Authentication</h5><p>Shiro的认证功能,会根据Subject的信息进行判断,如果认证过,则直接进入/如果没认证,则需要先认证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ( !currentUser.isAuthenticated() ) &#123;</span><br><span class="line">    //collect user principals and credentials in a gui specific manner</span><br><span class="line">    //such as username/password html form, X509 certificate, OpenID, etc.</span><br><span class="line">    //We&apos;ll use the username/password example here since it is the most common.</span><br><span class="line">    //(do you know what movie this is from? ;)</span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">    //this is all you have to do to support &apos;remember me&apos; (no config - built in!):</span><br><span class="line">    token.setRememberMe(true);</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UsernamePasswordToken</strong>(username/password)</p><p>以特定的方式收集用户的<strong>主体</strong>和<strong>凭证</strong></p><p><strong>Remember Me</strong>  no config - built in!(true/false)</p><p>Shiro内置功能,记住用户(详情待更新)</p><p><strong>登录尝试失败的反馈–异常</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    currentUser.login( token );</span><br><span class="line">    //if no exception, that&apos;s it, we&apos;re done!</span><br><span class="line">&#125; catch ( UnknownAccountException uae ) &#123;</span><br><span class="line">    //username wasn&apos;t in the system, show them an error message?</span><br><span class="line">&#125; catch ( IncorrectCredentialsException ice ) &#123;</span><br><span class="line">    //password didn&apos;t match, try again?</span><br><span class="line">&#125; catch ( LockedAccountException lae ) &#123;</span><br><span class="line">    //account for that username is locked - can&apos;t login.  Show them a message?</span><br><span class="line">&#125;</span><br><span class="line">    ... more types exceptions to check if you want ...</span><br><span class="line">&#125; catch ( AuthenticationException ae ) &#123;</span><br><span class="line">    //unexpected condition - error?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shiro中使用多种异常完善认证</strong></p><ul><li>将Subject的.login(token)进行捕获,从而的到许多种异常提醒,根据相应的异常判断用户登录的错误信息</li><li>注意:Shiro有丰富的认证异常设定并支持自定义异常,在Realm中通过判断条件,抛出异常的方式,可以在Controller中接收需要的异常数据来完善程序的开发</li></ul><hr><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/b9f81ac7-ad34-4adc-b4c2-cb2f73a4f2dd/128/index_files/48cae49c-8924-4a4e-8efd-bdbf38f07c97.jpg" alt="img">    </p><ol><li><strong>注意:Shiro不会自己维护用户|权限;</strong></li><li><strong>需要开发者去 设计|提供 ;</strong></li><li><strong>然后通过接口注入给Shiro即可</strong></li></ol><h3 id="4-源码"><a href="#4-源码" class="headerlink" title="4.源码"></a>4.源码</h3><h4 id="Token认证"><a href="#Token认证" class="headerlink" title="Token认证"></a>Token认证</h4><p><strong>JdbcRealm</strong></p><p>Shiro –&gt;JdbcRealm封装的固定sql</p><p> [1.封装根据用户名查询密码的SQL语句]</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The default query used to retrieve account data for the user.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_AUTHENTICATION_QUERY = <span class="string">"select password from users where username = ?"</span>;</span><br></pre></td></tr></table></figure><pre><code>[2.盐加密&amp;&amp;authenticationQuery验证查询(判断)] </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the salt style.  See &#123;<span class="doctag">@link</span> #saltStyle&#125;.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> saltStyle new SaltStyle to set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSaltStyle</span><span class="params">(SaltStyle saltStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.saltStyle = saltStyle;</span><br><span class="line">        <span class="keyword">if</span> (saltStyle == SaltStyle.COLUMN &amp;&amp; authenticationQuery.equals(DEFAULT_AUTHENTICATION_QUERY)) &#123;</span><br><span class="line">            authenticationQuery = DEFAULT_SALTED_AUTHENTICATION_QUERY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  [3.发现源代码中使用预编译的原生JDBC,并根据索引查找对比,所以要求自定义语句时不能乱写,根据规则走] </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ps = conn.prepareStatement(authenticationQuery);</span><br><span class="line">            ps.setString(1, username);</span><br><span class="line"></span><br><span class="line">            // Execute query</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">            // Loop over results - although we are only expecting one result, since usernames should be unique</span><br><span class="line">            boolean foundResult = false;</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">                // Check to ensure only one row is processed</span><br><span class="line">                if (foundResult) &#123;</span><br><span class="line">                    throw new AuthenticationException(&quot;More than one user row found for user [&quot; + username + &quot;]. Usernames must be unique.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                result[0] = rs.getString(1);     //索引查询</span><br><span class="line">                if (returningSeparatedSalt) &#123;</span><br><span class="line">                    result[1] = rs.getString(2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                foundResult = true;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>new SimpleAuthenticationInfo()(存放唯一认证) 源码分析</strong></p><p>principal: 整个Shiro中唯一的标识符,可以存用户名,也可以存ID</p><p>credentials: 唯一标识符的密码</p><p>realmName: 当前数据源的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAuthenticationInfo</span><span class="params">(Object principal, Object credentials, String realmName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.principals = <span class="keyword">new</span> SimplePrincipalCollection(principal, realmName);</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\Desktop\20180122131153906.png" alt="20180122131153906"></p><p>使用了工厂模式来对SecurityManager进行生成和配置  </p><p>生成过程是使用<strong>单例+工厂</strong> </p><p>提供对外的<strong>工具类</strong>来使用，包含获取SecurityManager的方法和获取Subject的方法  </p><p><img src="C:\Users\Administrator\Desktop\3.png" alt="3"></p><p>(代码略)</p><p>subject的使用是通过传入AuthenticationToken接口（注意是接口，其实扩展接口rememnverMeaut…和HostAutho…），</p><p>该接口目前的实现类是UserPasswordToken，当然也可以自己扩展实现自定义的认证Token </p><h4 id="测试加密算法"><a href="#测试加密算法" class="headerlink" title="测试加密算法"></a>测试加密算法</h4><p><strong>盐值加密如果几个人密码一样，那么加密后的密码则一致。这样不安全，要解决这个问题，可以在密码上加盐。一般会选择不重复的值作为盐值，例如 用户名。</strong>(部分代码)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line">        <span class="comment">//第一个参数：散列算法</span></span><br><span class="line">        <span class="comment">//第二个参数：明文，原始密码</span></span><br><span class="line">        <span class="comment">//第三个参数：盐，通过使用随机数</span></span><br><span class="line">        <span class="comment">//第四个参数：散列的次数，比如散列两次，相当 于md5(md5(''))</span></span><br><span class="line">        SimpleHash simpleHash = <span class="keyword">new</span> SimpleHash(<span class="string">"md5"</span>, source, salt, hashIterations);</span><br><span class="line">        String md5 =  simpleHash.toString();</span><br><span class="line">        System.out.println(md5);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shiro-realm-md5.ini</span><br><span class="line">---------------------</span><br><span class="line">[main]</span><br><span class="line">定义凭证匹配器</span><br><span class="line">credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line">散列算法</span><br><span class="line">credentialsMatcher.hashAlgorithmName=md5</span><br><span class="line">散列次数</span><br><span class="line">credentialsMatcher.hashIterations=<span class="number">1024</span></span><br><span class="line">开启加盐（无需设置，realm中使用的SimpleAuthenticationInfo 是 SaltedAuthenticationInfo 接口的实现类，默认开启的加盐功能）</span><br><span class="line">credentialsMatcher.hashSalted=<span class="keyword">true</span></span><br><span class="line">自定义 realm</span><br><span class="line">customRealm=com.qfedu.shirodemo.realm.CustomRealmMd5</span><br><span class="line">customRealm.credentialsMatcher=$credentialsMatcher</span><br><span class="line">将realm设置到securityManager，相当 于spring中注入</span><br><span class="line">securityManager.realms=$customRealm</span><br></pre></td></tr></table></figure><h4 id="授权流程原理"><a href="#授权流程原理" class="headerlink" title="授权流程原理"></a>授权流程原理</h4><p><strong>授权</strong></p><p>授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</p><p><strong>主体（Subject）</strong></p><p>主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。</p><p><strong>资源</strong></p><p>在应用中用户可以访问的任何东西，比如JSP 页面、某些数据、某个业务方法等等都是资源。用户只要授权后才能访问。</p><p><strong>角色</strong></p><p>角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。</p><p>典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。</p><p><strong>权限</strong></p><p>权限表示在应用中用户能不能访问某个资源，</p><p>如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）打印文档等等。。。</p><h5 id="判断是否授权的方式"><a href="#判断是否授权的方式" class="headerlink" title="判断是否授权的方式"></a>判断是否授权的方式</h5><p>Shiro 支持三种方式的授权判断：</p><p><strong>编程式</strong></p><p>通过写if/else 授权代码块完成：</p><p>Subject subject = SecurityUtils.getSubject();</p><p>if(subject.hasRole(“admin”)) {</p><p>​      //有权限</p><p>} else {</p><p>​     //无权限</p><p>}</p><p><strong>注解式</strong></p><p>通过在执行的Java方法上放置相应的注解完成：</p><p>@RequiresRoles(“admin”)</p><p>public void hello() {</p><p>   //有权限</p><p>}</p><p>没有权限将抛出相应的异常；</p><p><strong>JSP 标签</strong></p><p>在JSP 页面通过相应的标签完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!— 有权限—&gt;</span><br><span class="line"></span><br><span class="line">&lt; /shiro:hasRole &gt;</span><br></pre></td></tr></table></figure><h5 id="自定义realm授权"><a href="#自定义realm授权" class="headerlink" title="自定义realm授权"></a>自定义realm授权</h5><p><strong>从认证的realm拷贝，改变继承的抽象父类，添加新的方法</strong></p><h3 id="5-程序分析"><a href="#5-程序分析" class="headerlink" title="5.程序分析"></a>5.程序分析</h3><p><strong>程序分析：从应用程序角度的来观察如何使用Shiro完成工作</strong> </p><ol><li>应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager； </li><li>我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</li><li>可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject； </li></ol><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/e66c475a-c763-4097-85a0-b0219938fe7f/128/index_files/4a5f51ff-ef16-4a61-a834-9a9b06da850b.jpg" alt="img"></p><p><strong>Shiro内部结构</strong></p><p><img src="file:///C:/Users/Administrator/Documents/My%20Knowledge/temp/1b7bc2c3-9f2c-4ea2-8ed7-97820c205482/128/index_files/9b959a65-799d-396e-b5f5-b4fcfe88f53c.png" alt="img"></p><p><strong>详细原理深入和运用:<a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/2018398</a></strong></p><h3 id="6-Shiro认证技巧整理"><a href="#6-Shiro认证技巧整理" class="headerlink" title="6.Shiro认证技巧整理"></a>6.Shiro认证技巧整理</h3><h4 id="工具类接口的使用"><a href="#工具类接口的使用" class="headerlink" title="工具类接口的使用"></a>工具类接口的使用</h4><p>建立一个工具类接口Constants,以常量字符串的方式,专门存放Shiro中自定义的<strong>标识符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Constants &#123;</span><br><span class="line">    // md5(用户密码+PASSWORD_SALT_KEY)保存到数据库中。</span><br><span class="line">    String PASSWORD_SALT_KEY = &quot;Shiro.admin.2017&quot;;</span><br><span class="line">    //Shiro的session中存放用户的key</span><br><span class="line">    String SESSION_USER_KEY = &quot;SESSION_USER_KEY&quot;;</span><br><span class="line">    //redis中存放的用户权限菜单的key</span><br><span class="line">    String SESSION_USER_MANU = &quot;SESSION_USER_MANU&quot;;</span><br><span class="line">    //Shiro存放的角色信息</span><br><span class="line">    String SESSION_USER_ROLE = &quot;SESSION_USER_ROLE&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口工具类的思路不仅限于Shiro,灵活的定义接口,将冗余和容易混淆的部分抽离出来统一管理,可以极大的提高开发和维护的效率</strong></p><h4 id="认证优化技巧"><a href="#认证优化技巧" class="headerlink" title="认证优化技巧"></a>认证优化技巧</h4><p>Controller层登录方法中,接收到用户名和密码后先进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">if (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">    ...认证</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接获取subject,先进性判断该用户是否认证过,如果认证过则直接跳出即可</p><p>如果没有认证过,再进入认证环节</p><p>该逻辑可以减少服务器和数据库的压力,提高服务器的并发能力</p><h4 id="shiro-xml-拦截器设置"><a href="#shiro-xml-拦截器设置" class="headerlink" title="..shiro.xml 拦截器设置"></a>..shiro.xml 拦截器设置</h4><p><strong>Shiro主过滤器本身功能十分强大,其强大之处就在于它支持任何基于URL路径表达式的、自定义的过滤器的执行</strong></p><ul><li>/login.html=anon 静态资源的方式屏蔽过滤器</li><li>/**=authc 该路径下需要认证才能访问</li><li>…</li></ul><p>过滤器的完整参考：</p><p><a href="http://blog.csdn.net/jadyer/article/details/12172839" target="_blank" rel="noopener">http://blog.csdn.net/jadyer/article/details/12172839</a></p><h4 id="登录认证使用原理"><a href="#登录认证使用原理" class="headerlink" title="登录认证使用原理"></a>登录认证使用原理</h4><p><strong>动态权限控制</strong></p><p><strong>RBAC（Role-Based Access Control ）基于角色的访问控制</strong></p><ol><li>配置好环境和工具类</li><li>自定义Realm和异常</li><li>service中添加通过用户名查找用户信息</li><li>在Controller层认证登录</li><li><ul><li>UsernamePasswordToken token = new UsernamePasswordToken(name, password);</li><li>Subject subject = SecurityUtils.getSubject();</li><li>ubject.login(token);</li></ul></li><li>将真正的验证交给封装的底层–&gt;AuthenticationToken实现.(自定义Realm中)</li><li>通过此时token的username去数据库查询用户信息</li><li>用户信息存在,则存入SimpleAuthenticationInfo,否则  抛出用户对应的异常</li></ol><p><strong>Shiro的分布式认证结构(shiro认证将账号密码的比较环节封装到AuthenticationToken中)</strong></p><p>​    Realm放在Controller中,在分布式中Controller使用Dubbo服务端接口,而dubbo接口通过service实现类来发布,这个角度看realm与dao隔层交互设计不太合理</p><p>​    验证成功则返回SimpleAuthenticationInfo(存放唯一标识(id或者username),密码,Realm名</p><h3 id="7-Shiro授权技巧整理"><a href="#7-Shiro授权技巧整理" class="headerlink" title="7.Shiro授权技巧整理"></a>7.Shiro授权技巧整理</h3><ol><li>通过用户登录的唯一标识principals 查找到用户有哪些菜单权限(ID)</li><li>将这些ID存到SimpleAuthorizationInfo中</li><li>在自定义ShiroFilterFactoryBean中获取所有菜单列表,并将id加入到section中</li><li>底层自动对比,哪些ID用户有,则允许访问,没有的话”authc”拦截</li><li>Controller中查询用户拥有的菜单数据返回前段即可,此时没有权限的数据已经被拦截</li></ol><h4 id="易错集合"><a href="#易错集合" class="headerlink" title="易错集合"></a>易错集合</h4><h5 id="1-授权URL"><a href="#1-授权URL" class="headerlink" title="1.授权URL"></a>1.授权URL</h5><p>​    注意使用Shiro权限设置后的url如果需要访问,逻辑路径需要放在 <strong>前端</strong> 拼接,(后台对逻辑路径没有识别,也没有必要识别,不能将逻辑路径放在后台和数据库中)</p><h5 id="2-权限顺序"><a href="#2-权限顺序" class="headerlink" title="2.权限顺序"></a>2.权限顺序</h5><p>​    运行时先执行<strong>MyRealm</strong>中的权限,然后拼接<strong>MyShiroFilterFactoryBean</strong>中的权限</p><p>​    注意:限制范围较大的往后排,特别是全部拦截的/<strong> 如果需要的话尽量放在</strong>MyShiroFilterFactoryBean**中</p><h3 id="8-Remember-me功能简述"><a href="#8-Remember-me功能简述" class="headerlink" title="8.Remember me功能简述"></a>8.Remember me功能简述</h3><p>Shiro的Remember Me可以很轻松的实现自动登录的功能,方便快捷</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line">if(loginForm.getRememberMe() != null &amp;&amp; &quot;Y&quot;.equals(loginForm.getRememberMe()))&#123;</span><br><span class="line">token.setRememberMe(true);</span><br><span class="line">&#125;</span><br><span class="line">subject.login(token);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/** = user</span><br></pre></td></tr></table></figure><p>Remember Me只需要在登录时将token的RememberMe功能开启,本来的拦截级别为/ <strong> = authc 将拦截设置(降级)为</strong>user级别**即可使用</p><p>Remember Me功能开启使用后,Shiro会生成一个叫<strong>RememberMe</strong>的Cookie保存在浏览器中,当subject.loginout退出或者过期后失效,改参数是base64加密的字符串如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名称：rememberMe</span><br><span class="line">内容：6gYvaCGZaDXt1c0xwriXj/Uvz6g8OMT3VSaAK4WL0Fvqvkcm0nf3CfTwkWWTT4EjeSS/EoQjRfCPv4WKUXezQDvoNwVgFMtsLIeYMAfTd17ey5BrZQMxW+xU1lBSDoEM1yOy/i11ENh6eXjmYeQFv0yGbhchGdJWzk5W3MxJjv2SljlW4dkGxOSsol3mucoShzmcQ4VqiDjTcbVfZ7mxSHF/0M1JnXRphi8meDaIm9IwM4Hilgjmai+yzdVHFVDDHv/vsU/fZmjb+2tJnBiZ+jrDhl2Elt4qBDKxUKT05cDtXaUZWYQmP1bet2EqTfE8eiofa1+FO3iSTJmEocRLDLPWKSJ26bUWA8wUl/QdpH07Ymq1W0ho8EIdFhOsELxM66oMcj7a/8LVzypJXAXZdMFaNe8cBSN2dXpv4PwiktCs3J9P9vP4XrmYees5x27UmXNqYFk86xQhRjFdJsw5A9ctDKXzPYvJmWFouo3qT5hugX0uxWALCfWg8MHJnG9w7QgVKM8oy3Xy4Ut8lSvYlA==</span><br></pre></td></tr></table></figure><p>Shiro的RememberMe设计时!=已经登录,因为该cookie被序列化后可以不同的浏览器之间访问,并且可能被黑客复制截取等,因此使用该功能的话尽量以非关键性资源为主,当牵扯到<strong>资金</strong>等关键资源时,选择再次登录即可</p><p>开发时如果使用Session域对象,则自动登录后Session中不会再有数据,如果需要用到,那么需要重写isAccessAllowed 方法</p><p><strong>详细参考自:<a href="https://blog.csdn.net/nsrainbow/article/details/36945267/" target="_blank" rel="noopener">https://blog.csdn.net/nsrainbow/article/details/36945267/</a></strong></p><p><strong>(本次Remember Me尚未指定配置更改,待更新)</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Shiro基础原理&quot;&gt;&lt;a href=&quot;#Shiro基础原理&quot; class=&quot;headerlink&quot; title=&quot;Shiro基础原理&quot;&gt;&lt;/a&gt;Shiro基础原理&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; cl
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis基础原理</title>
    <link href="http://yoursite.com/2018/07/04/Redis%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/04/Redis基础原理/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-15T05:11:16.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis基础原理"><a href="#Redis基础原理" class="headerlink" title="Redis基础原理"></a>Redis基础原理</h3><p>[TOC]</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p><strong>NoSQL</strong></p><p>非关系型数据库,Redis是非关系型数据库中的<strong>键值存储数据库</strong></p><p><strong>应用</strong></p><p>处理高并发/海量数据的访问,内容缓存</p><p><strong>优点</strong></p><ol><li>快速查询,支持横向扩充(集群)和纵向扩充(加强设备)</li><li>一主多从,读写分离</li><li>哨兵机制,检测选举</li><li>集群机制,多主多从,数据高可用,分布式存储</li></ol><p><strong>缺点</strong></p><p>​    存储缺少结构化(难以构建关系型理数据库模型)</p><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>最简单的KV存储,value可以是String也可以是数字等</p><p><strong>场景</strong></p><p>kv字符串结构等,非常普遍</p><p><strong>指令</strong></p><p>​    SET key value                   设置key=value </p><p>​    GET key                         或者键key对应的值 </p><p>​    GETRANGE key start end          得到字符串的子字符串存放在一个键 </p><p>​    GETSET key value                设置键的字符串值，并返回旧值 </p><p>​    GETBIT key offset               返回存储在键位值的字符串值的偏移 </p><p>​    MGET key1 [key2..]              得到所有的给定键的值 </p><p>​    SETBIT key offset value         设置或清除该位在存储在键的字符串值偏移 </p><p>​    SETEX key seconds value         键到期时设置值 </p><p>​    SETNX key value                 设置键的值，只有当该键不存在 </p><p>​    SETRANGE key offset value       覆盖字符串的一部分从指定键的偏移 </p><p>​    STRLEN key                      得到存储在键的值的长度 </p><p>​    MSET key value [key value…]   设置多个键和多个值 </p><p>​    MSETNX key value [key value…] 设置多个键多个值，只有在当没有按键的存在时 </p><p>​    PSETEX key milliseconds value   设置键的毫秒值和到期时间 </p><p>​    INCR key                        增加键的整数值一次 INCRBY key increment            由给定的数量递增键的整数值 </p><p>​    INCRBYFLOAT key increment       由给定的数量递增键的浮点值</p><p>​    DECR key                        递减键一次的整数值 </p><p>​    DECRBY key decrement            由给定数目递减键的整数值 </p><p>​    APPEND key value                追加值到一个键 </p><p>​    ——–操作管理———-</p><ul><li><p>DEL key                         如果存在删除键 </p></li><li><p>DUMP key                        返回存储在指定键的值的序列化版本 </p></li><li><p>EXISTS key                      此命令检查该键是否存在 </p></li><li><p>EXPIRE key seconds              指定键的过期时间</p></li><li><p>EXPIREAT key timestamp          指定的键过期时间。在这里，时间是在Unix时间戳格式 </p></li><li><p>PEXPIRE key milliseconds        设置键以毫秒为单位到期 </p></li><li><p>PEXPIREAT key milliseconds-timestamp        设置键在Unix时间戳指定为毫秒到期 </p></li><li><p>KEYS pattern                    查找与指定模式匹配的所有键 </p></li><li><p>MOVE key db                     移动键到另一个数据库 </p></li><li><p>PERSIST key                     移除过期的键 </p></li><li><p>PTTL key                        以毫秒为单位获取剩余时间的到期键。 </p></li><li><p>TTL key                         获取键到期的剩余时间。 </p></li><li><p>RANDOMKEY                       从Redis返回随机键 </p></li><li><p>RENAME key newkey               更改键的名称 </p></li><li><p>RENAMENX key newkey             重命名键，如果新的键不存在 </p></li><li><p>TYPE key                        返回存储在键的数据类型的值。 </p></li></ul><h5 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h5><p>字符串列表,非常重要的Redis类型,本质是双向链表,支持反向查询和遍历,更加方便,但是会额外增加内存开销(存储双向链表),redis内部的<strong>发送缓冲队列</strong>使用的就是List结构</p><p><strong>场景</strong></p><p>如twitter的关注列表和粉丝列表,实现轻量级的消息队列等</p><p><strong>指令</strong></p><ul><li>BLPOP<br>BLPOP key1 [key2 ] timeout 取出并获取列表中的第一个元素，或阻塞，直到有可用</li><li>BRPOP<br>BRPOP key1 [key2 ] timeout 取出并获取列表中的最后一个元素，或阻塞，直到有可用</li><li>BRPOPLPUSH<br>BRPOPLPUSH source destination timeout 从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用</li><li>LINDEX<br>LINDEX key index 从一个列表其索引获取对应的元素</li><li>LINSERT<br>LINSERT key BEFORE|AFTER pivot value 在列表中的其他元素之后或之前插入一个元素</li><li>LLEN<br>LLEN key 获取列表的长度</li><li>LPOP<br>LPOP key 获取并取出列表中的第一个元素</li><li>LPUSH<br>LPUSH key value1 [value2] 在前面加上一个或多个值的列表</li><li>LPUSHX<br>LPUSHX key value 在前面加上一个值列表，仅当列表中存在</li><li>LRANGE<br>LRANGE key start stop 从一个列表获取各种元素</li><li>LREM<br>LREM key count value 从列表中删除元素</li><li>LSET<br>LSET key index value 在列表中的索引设置一个元素的值</li><li>LTRIM<br>LTRIM key start stop 修剪列表到指定的范围内</li><li>RPOP<br>RPOP key 取出并获取列表中的最后一个元素</li><li>RPOPLPUSH<br>RPOPLPUSH source destination 删除最后一个元素的列表，将其附加到另一个列表并返回它</li><li>RPUSH<br>RPUSH key value1 [value2] 添加一个或多个值到列表</li><li>RPUSHX<br>RPUSHX key value 添加一个值列表，仅当列表中存在</li></ul><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。 </p><p><strong>场景</strong></p><p>可以方便的存储用户信息,用户ID为Key,用户信息序列化为value存储</p><p><strong>指令</strong></p><ul><li>HDEL<br>HDEL key field[field…] 删除对象的一个或几个属性域，不存在的属性将被忽略</li><li>HEXISTS<br>HEXISTS key field 查看对象是否存在该属性域</li><li>HGET<br>HGET key field 获取对象中该field属性域的值</li><li>HGETALL<br>HGETALL key 获取对象的所有属性域和值</li><li>HINCRBY<br>HINCRBY key field value 将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用</li><li>HINCRBYFLOAT<br>HINCRBYFLOAT key field increment 将该对象中指定域的值增加给定的浮点数</li><li>HKEYS<br>HKEYS key 获取对象的所有属性字段</li><li>HVALS<br>HVALS key 获取对象的所有属性值</li><li>HLEN<br>HLEN key 获取对象的所有属性字段的总数</li><li>HMGET<br>HMGET key field[field…] 获取对象的一个或多个指定字段的值</li><li>HSET<br>HSET key field value 设置对象指定字段的值</li><li>HMSET<br>HMSET key field value [field value …] 同时设置对象中一个或多个字段的值</li><li>HSETNX<br>HSETNX key field value 只在对象不存在指定的字段时才设置字段的值</li><li>HSTRLEN<br>HSTRLEN key field 返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0.</li><li>HSCAN<br>HSCAN key cursor [MATCH pattern] [COUNT count] 类似SCAN命令</li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>存储数据不重复,set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 </p><p><strong>场景</strong></p><p>set和list的功能类似,但是set加载的列表自动排重,当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 </p><p>在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 </p><p><strong>指令</strong></p><ul><li>SADD<br>SADD key member [member …] 添加一个或者多个元素到集合(set)里</li><li>SACRD<br>SCARD key 获取集合里面的元素数量</li><li>SDIFF<br>SDIFF key [key …] 获得队列不存在的元素</li><li>SDIFFSTORE<br>SDIFFSTORE destination key [key …] 获得队列不存在的元素，并存储在一个关键的结果集</li><li>SINTER<br>SINTER key [key …] 获得两个集合的交集</li><li>SINTERSTORE<br>SINTERSTORE destination key [key …] 获得两个集合的交集，并存储在一个集合中</li><li>SISMEMBER<br>SISMEMBER key member 确定一个给定的值是一个集合的成员</li><li>SMEMBERS<br>SMEMBERS key 获取集合里面的所有key</li><li>SMOVE<br>SMOVE source destination member 移动集合里面的一个key到另一个集合</li><li>SPOP<br>SPOP key [count] 获取并删除一个集合里面的元素</li><li>SRANDMEMBER<br>SRANDMEMBER key [count] 从集合里面随机获取一个元素</li><li>SREM<br>SREM key member [member …] 从集合里删除一个或多个元素，不存在的元素会被忽略</li><li>SUNION<br>SUNION key [key …] 添加多个set元素</li><li>SUNIONSTORE<br>SUNIONSTORE destination key [key …] 合并set元素，并将结果存入新的set里面</li><li>SSCAN<br>SSCAN key cursor [MATCH pattern][COUNT count] 迭代set里面的元素</li></ul><h5 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h5><p>set的有序版,由HaspMap和跳跃表组成</p><p><strong>场景</strong></p><p>用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列。 </p><p><strong>指令</strong></p><ul><li>ZADD<br>ZADD key score1 member1 [score2 member2] 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数</li><li>ZCARD<br>ZCARD key 得到的有序集合成员的数量</li><li>ZCOUNT<br>ZCOUNT key min max 计算一个有序集合成员与给定值范围内的分数</li><li>ZINCRBY<br>ZINCRBY key increment member 在有序集合增加成员的分数</li><li>ZINTERSTORE<br>ZINTERSTORE destination numkeys key [key …] 多重交叉排序集合，并存储生成一个新的键有序集合。</li><li>ZLEXCOUNT<br>ZLEXCOUNT key min max 计算一个给定的字典范围之间的有序集合成员的数量</li><li>ZRANGE<br>ZRANGE key start stop [WITHSCORES] 由索引返回一个成员范围的有序集合（从低到高）</li><li>ZRANGEBYLEX<br>ZRANGEBYLEX key min max [LIMIT offset count]返回一个成员范围的有序集合（由字典范围）</li><li>ZRANGEBYSCORE<br>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列</li><li>ZRANK<br>ZRANK key member 确定成员的索引中有序集合</li><li>ZREM<br>ZREM key member [member …] 从有序集合中删除一个或多个成员，不存在的成员将被忽略</li><li>ZREMRANGEBYLEX<br>ZREMRANGEBYLEX key min max 删除所有成员在给定的字典范围之间的有序集合</li><li>ZREMRANGEBYRANK<br>ZREMRANGEBYRANK key start stop 在给定的索引之内删除所有成员的有序集合</li><li>ZREMRANGEBYSCORE<br>ZREMRANGEBYSCORE key min max 在给定的分数之内删除所有成员的有序集合</li><li>ZREVRANGE<br>ZREVRANGE key start stop [WITHSCORES] 返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分</li><li>ZREVRANGEBYSCORE<br>ZREVRANGEBYSCORE key max min [WITHSCORES] 返回一个成员范围的有序集合，以socre排序从高到低</li><li>ZREVRANK<br>ZREVRANK key member 确定一个有序集合成员的索引，以分数排序，从高分到低分</li><li>ZSCORE<br>ZSCORE key member 获取给定成员相关联的分数在一个有序集合</li><li>ZUNIONSTORE<br>ZUNIONSTORE destination numkeys key [key …] 添加多个集排序，所得排序集合存储在一个新的键</li><li>ZSCAN<br>ZSCAN key cursor [MATCH pattern] [COUNT count] 增量迭代排序元素集和相关的分数</li></ul><p>**Redis过期策略:<a href="https://www.jb51.net/article/103236.htm" target="_blank" rel="noopener">https://www.jb51.net/article/103236.htm</a></p><h4 id="3-Redis运用"><a href="#3-Redis运用" class="headerlink" title="3.Redis运用"></a>3.Redis运用</h4><p>实际开发中,经常会用到集合(list读取较快)来存储缓存数据,但是Redis只支持List<string>,不能直接支持List<object>,因此需要制作工具类来转换Json类型读写</object></string></p><ol><li>导入POM</li><li>导入JsonUtils工具类(将Object/List &lt;Object &gt;转化为字符串)</li><li>导入Redis工具类接口/实现接口</li><li>导入配置文件spring-redis/redis.properties</li><li>service中注入使用即可</li></ol><p><strong>注意spring的加载机制:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Could not resolve placeholder &apos;USER_LIST&apos; in string value &quot;$&#123;USER_LIST&#125;&quot;</span><br></pre></td></tr></table></figure><p>Spring容器采用反射扫描的发现机制，在探测到Spring容器中有一个org.springframework.beans.factory.config.PropertyPlaceholderConfigurer的Bean就会停止对剩余PropertyPlaceholderConfigurer的扫描（Spring 3.1已经使用PropertySourcesPlaceholderConfigurer替代PropertyPlaceholderConfigurer了）</p><p>所以根据加载的顺序，配置的第二个property-placeholder就被没有被spring加载，我想引入的config-wxapp.properties就没有被引入，所以在使用@Value注入的时候占位符就解析不了…解决方法就是把2个property-placeholder注解配置合并在一起就好了 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis基础原理&quot;&gt;&lt;a href=&quot;#Redis基础原理&quot; class=&quot;headerlink&quot; title=&quot;Redis基础原理&quot;&gt;&lt;/a&gt;Redis基础原理&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; cl
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/07/03/hello-world/"/>
    <id>http://yoursite.com/2018/07/03/hello-world/</id>
    <published>2018-07-03T15:51:12.163Z</published>
    <updated>2018-07-05T12:34:12.004Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GitHub 博客快速搭建</title>
    <link href="http://yoursite.com/2018/07/02/GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/07/02/GitHub博客搭建/</id>
    <published>2018-07-01T16:00:00.000Z</published>
    <updated>2018-07-12T06:14:45.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitHub-博客快速搭建"><a href="#GitHub-博客快速搭建" class="headerlink" title="GitHub 博客快速搭建"></a>GitHub 博客快速搭建</h3><p>[TOC]</p><p><strong>环境:Win7</strong></p><p><strong>搭建流程</strong></p><p>Node.js | Hexo | Next(themes) </p><p><strong>基础</strong></p><ol><li>首先安装Node.js 注意<strong>Path指定位置</strong>(影响到balabala一些配置的存放的位置,默认C盘,建议改)</li><li>Node.js安装好后,选择一个文件夹安装Hexo(此处为<strong>搭建Blog的位置</strong>)</li><li>将GitHub账号的博客地址添加到Hexo的配置文件中(根目录 <strong>_config.yml</strong>),并将部署方式改为Git(老版本是GitHub方式)</li><li>根据指令部署后即可完成基础的博客搭建,此时查看博客仓库是否上传了静态资源(如果上传了则代表搭建成功)</li><li>短暂的延迟后进入博客网页即可看到搭建的博客</li><li>写博客的方式–&gt;将编写的md文章放在posts下,然后 hexo g d 部署一下即可(每次方式用这个指令就可以上传文章了,文章会被自适应解析)</li></ol><p><strong>参考<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a></strong></p><hr><p><strong>进阶</strong></p><p>Hexo中的themes是主题设定的位置,可以选择主题,教程中选择Next的基础主题(没有追求可以凑合用( • ̀ω•́ )✧)</p><p>themes中的(<strong>_config.yml</strong>)是主题的配置,里面可以根据提示做自己的简单配置,包括菜单的增减和修改,布局等等,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br></pre></td></tr></table></figure><p>根据教程和注释完成自己的布局即可</p><p><strong>参考<a href="http://www.cnblogs.com/fengxiongZz/p/7707568.html" target="_blank" rel="noopener">http://www.cnblogs.com/fengxiongZz/p/7707568.html</a></strong></p><hr><p><strong>进阶加强</strong></p><p>完成这些想玩点花的话可以去官网或者GitHub找喜欢的themes修改使用,教程百度一大堆( • ̀ω•́ )✧</p><p><strong>一大波官网主题:<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></strong></p><p><strong>第三方的插件口头整合</strong></p><ol><li>第三方登录(Github)</li><li>评论功能</li><li>站内搜索</li><li>站内统计</li><li>交互式背景</li><li>网易云播放器插件</li><li>将网站的所有图片通过url委托给第三方云图片服务器(七牛云存储10G免费)</li><li>…</li></ol><hr><p><strong>维护技巧</strong></p><p>当不能保证在同一台电脑上传文章时,可以选择master分离的方式或者将博客部署在自己的远程服务器上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GitHub-博客快速搭建&quot;&gt;&lt;a href=&quot;#GitHub-博客快速搭建&quot; class=&quot;headerlink&quot; title=&quot;GitHub 博客快速搭建&quot;&gt;&lt;/a&gt;GitHub 博客快速搭建&lt;/h3&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境:Wi
      
    
    </summary>
    
      <category term="搭建" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>FreeMarker结合Nginx|FTP基础使用</title>
    <link href="http://yoursite.com/2018/07/02/FreeMarker%E5%92%8CNginx_FTP%E5%8E%9F%E7%90%86%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/02/FreeMarker和Nginx_FTP原理使用/</id>
    <published>2018-07-01T16:00:00.000Z</published>
    <updated>2018-07-12T06:14:34.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FreeMarker结合Nginx-FTP基础使用"><a href="#FreeMarker结合Nginx-FTP基础使用" class="headerlink" title="FreeMarker结合Nginx|FTP基础使用"></a>FreeMarker结合Nginx|FTP基础使用</h3><p>[TOC]</p><p>目前做页面模板引擎主流使用<strong>Thymeleaf</strong>(效率更高),本文主要介绍<strong>FreeMarker</strong>的相关知识</p><p><strong>传送门:Thymeleaf基础原理<a href="https://blog.csdn.net/abap_brave/article/details/53009149" target="_blank" rel="noopener">https://blog.csdn.net/abap_brave/article/details/53009149</a></strong></p><p><strong>传送门:Thymeleaf快速使用<a href="https://blog.csdn.net/u014042066/article/details/75614906" target="_blank" rel="noopener">https://blog.csdn.net/u014042066/article/details/75614906</a></strong></p><h4 id="1-FreeMarker"><a href="#1-FreeMarker" class="headerlink" title="1.FreeMarker"></a>1.FreeMarker</h4><h5 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h5><ol><li>FreeMarker是一个模板引擎,一个基于模板生成文件的通用工具,由<strong>纯java</strong>代码编写</li><li>FreeMarker不是一个Web框架,而是<strong>适合Web框架</strong>的一个组件</li><li>FreeMarker与容器无关,更加<strong>通用</strong>,而且免费</li></ol><p>数值类型:<strong>| String | 数值(不区分浮点) | boolean | 日期 | 集合 |</strong>等大部分类型</p><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><ol><li>引入jar包</li><li>建立模板</li><li>进行输出</li></ol><h4 id="2-FTP结合"><a href="#2-FTP结合" class="headerlink" title="2.FTP结合"></a>2.FTP结合</h4><h5 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h5><p>FTP连接分主动模式和被动模式</p><p><strong>主动模式(port)</strong>使用N(发送数据) 和N+1(发送FTP命令)两个端口,一般20 21</p><p>固定端口,可能造成数据被拦截窃取</p><p><strong>被动模式(pasv)</strong>使用21 和P&gt;1024所有端口</p><p>不固定大范围端口,可能造服务器服务器被攻击</p><p><strong>解决方案分析:<a href="https://blog.csdn.net/u014774781/article/details/48376633" target="_blank" rel="noopener">https://blog.csdn.net/u014774781/article/details/48376633</a></strong></p><p><strong>FTP传送门(待更新)</strong></p><h5 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2.使用"></a>2.使用</h5><p>FreeMarker生成静态页面后,可以通过FTP发送到服务器指定的位置存放</p><h4 id="3-Nginx结合"><a href="#3-Nginx结合" class="headerlink" title="3.Nginx结合"></a>3.Nginx结合</h4><h5 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h5><p>Nginx是一个Http服务器,可以将服务器上的<strong>静态文件通过Http协议</strong>展现给客户端</p><h5 id="2-使用-2"><a href="#2-使用-2" class="headerlink" title="2.使用"></a>2.使用</h5><p>Nginx将FreeMarker发送来的静态页面以url的方式发送到客户端完成一套静态部署</p><p><strong>Nginx传送门(待更新)</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;FreeMarker结合Nginx-FTP基础使用&quot;&gt;&lt;a href=&quot;#FreeMarker结合Nginx-FTP基础使用&quot; class=&quot;headerlink&quot; title=&quot;FreeMarker结合Nginx|FTP基础使用&quot;&gt;&lt;/a&gt;FreeMarker结
      
    
    </summary>
    
      <category term="组件" scheme="http://yoursite.com/categories/%E7%BB%84%E4%BB%B6/"/>
    
    
  </entry>
  
</feed>
