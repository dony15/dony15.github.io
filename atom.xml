<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DonY15</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-23T12:49:31.019Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>宝全哥哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NIO基础入门(一)之缓冲区Buffer</title>
    <link href="http://yoursite.com/2018/10/23/NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%80)%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BABuffer/"/>
    <id>http://yoursite.com/2018/10/23/NIO基础入门(一)之缓冲区Buffer/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-23T12:49:31.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO基础入门-一-之缓冲区Buffer"><a href="#NIO基础入门-一-之缓冲区Buffer" class="headerlink" title="NIO基础入门(一)之缓冲区Buffer"></a>NIO基础入门(一)之缓冲区Buffer</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>NIO(none blocking IO ) 非阻塞IO,多路复用(JDK1.4)</p><p>对I/O不足的补全,提供了高速.<strong>面向模块</strong>的I/O</p><p>将I/O操作最耗时的<strong>填充和提取缓冲区</strong>操作转移回操作系统,大大提高效率</p><h3 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h3><p>短数据,长连接</p><p>如Websocket,dubbo等,多种框架都有所集成</p><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成"></a>3.组成</h3><ol><li>缓冲区(Buffers)</li><li>通道(Channels)</li><li>文件锁定和内存映射文件(File locking and memory-mapped files)</li><li>套接字(socket)</li><li>选择器(selectors)</li><li>正则表达式(Regular expressions)</li><li>字符集(Character sets)</li></ol><h3 id="4-缓冲区"><a href="#4-缓冲区" class="headerlink" title="4.缓冲区"></a>4.缓冲区</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.<strong>简介</strong></h4><p>I/O的基础,所谓的输入输出,无非是把数据转移或转出缓冲区</p><ol><li>写(排干净)</li><li>读(塞满)</li></ol><p><strong>缓冲区:</strong> 固定数量的<strong>数据容器</strong>,作用是<strong>存储器</strong>或<strong>分段运输区</strong></p><h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.<strong>分类</strong></h4><ul><li>直接缓冲区</li><li>间接缓冲区</li><li>视图缓冲区</li></ul><h4 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3.工作流程"></a>3.<strong>工作流程</strong></h4><p>进程调用read()方法,向系统发出调用,要求填满(填入)缓冲区<strong>(控制权移交给内核,也称为陷阱)</strong></p><p>内核向磁盘控制器发出命令,要求从磁盘读取数据</p><p>磁盘控制器读取数据到<strong>内核空间</strong>的缓冲区中(如果数据不在内核空间,进程将被挂起,直到数据读入内核空间)</p><p>通过read()方法,将内核空间缓冲区中的数据复制,填入到<strong>用户空间</strong>的缓冲区中</p><p><strong>用户空间</strong>:如JVM等常规进程所在区域,非特权区域,无法直接访问硬件设备</p><p><strong>内核空间</strong>:如操作系统所在区域,直接与硬件设备可见,I/O都是直接或间接通过内和空间操作</p><p>分以上两个空间,主要是考虑进程请求的<strong>大小</strong>或<strong>非对齐</strong>数据块等问题,添加中间过度进行重新组合转换,<strong>内核</strong>充当中间人的角色</p><h4 id="4-发散和汇聚"><a href="#4-发散和汇聚" class="headerlink" title="4.发散和汇聚"></a>4.发散和汇聚</h4><p>许多操作系统把组装/分解过程进行得更加高效.根据发散/汇聚的概念,进程只需要将一个系统调动,就能把<strong>一连串缓冲区地址</strong>传给操作系统,然后<strong>内核</strong>可以根据<strong>顺序的多个缓冲区</strong>地址进行<strong>填充</strong>或<strong>排干</strong></p><ol><li>读的时候把数据<strong>发散到</strong>多个用户空间缓冲区</li><li>写的时候吧多个用户空间缓冲区数据<strong>汇聚排出</strong></li></ol><p>减少系统调用次数,提高性能</p><h4 id="5-虚拟内存"><a href="#5-虚拟内存" class="headerlink" title="5.虚拟内存"></a>5.虚拟内存</h4><p>虚拟地址取代物理内存地址</p><p>分为两类特性:</p><ol><li><strong>一个以上</strong>的虚拟地址可以<strong>指向同一个物理内存地址</strong></li><li>虚拟内存空间可大于实际可用的硬件内存</li></ol><h4 id="6-内存空间多重映射"><a href="#6-内存空间多重映射" class="headerlink" title="6.内存空间多重映射"></a>6.<strong>内存空间多重映射</strong></h4><p>设备控制器不能通过<strong>DMA</strong>直接存储到用户空间,</p><p>但是,如上<strong>第一类特性</strong>所说,把<strong>内核空间</strong>与<strong>用户空间</strong>的虚拟地址映<strong>射到同一个物理地址</strong>,</p><p>这样DMA硬件(只能访问物理内存地址)就可以<strong>填充对内核与用户空间同时可见的缓存区</strong></p><h4 id="7-内存页"><a href="#7-内存页" class="headerlink" title="7.内存页"></a>7.<strong>内存页</strong></h4><p>虚拟内存的第二类特性(寻址空间大于物理内存),</p><p>虚拟内存分页(经常称为交换,真正的交换实在进程层完成,而非页面层)</p><p>本质上说,物理内存充当分页的高速缓存,实际数据被存储到外部虚拟内存中,</p><p>在使用数据时,数据将会被再次交换到物理内存中</p><p>所有<strong>磁盘I/O</strong>都是在<strong>页面层</strong>完成</p><h4 id="8-MMU内存管理单元"><a href="#8-MMU内存管理单元" class="headerlink" title="8.MMU内存管理单元"></a>8.<strong>MMU内存管理单元</strong></h4><p>CPU的子系统,内存管理单元子系统,逻辑上位于CPU和物理内存之间,</p><p>包含虚拟地址向物理地址转换时所需的映射信息,</p><p>CPU可以快速的通过MMU进行映射查找,如果查询不到,则MMU向CPU提交页错误,</p><p>页错误会随机产生一个系统调用(陷阱),把控制权转移给内核</p><h4 id="9-文件I-O"><a href="#9-文件I-O" class="headerlink" title="9.文件I/O"></a>9.<strong>文件I/O</strong></h4><p>文件I/O时文件系统,与磁盘是两个概念</p><p><strong>磁盘:</strong>把数据存储在扇区上,属于硬件设备,对文件内容一无所知,<strong>只提供数据存取窗口</strong>,与内存相似,都是存储器</p><p><strong>文件系统:</strong>是<strong>更高级的抽象</strong>,是<strong>安排/解释磁盘数据</strong>的独特方式,代码中的交互是与文件系统打交道,而非磁盘,如:</p><p>文件名/路径/大小/文件属性等抽象概念</p><h4 id="10-内存映射文件"><a href="#10-内存映射文件" class="headerlink" title="10.内存映射文件"></a>10.<strong>内存映射文件</strong></h4><p><strong>传统文件I/O</strong>是通过发布read()/write()系统调用来传输数据,<strong>需要进行copy</strong></p><p><strong>内存映射I/O</strong>可以屏蔽copy,将内核系统页与用户空间的缓冲映射到同一片物理内存地址直接使用,<strong>减少copy的过程</strong></p><p><strong>文件锁定</strong></p><p>分为独占锁和共享锁,一个线程读取该文件时,限制其他线程的操作</p><h4 id="11-缓冲区家族"><a href="#11-缓冲区家族" class="headerlink" title="11.缓冲区家族"></a>11.<strong>缓冲区家族</strong></h4><ul><li><code>ByteBuffer</code></li><li><code>CharBuffer</code></li><li><code>ShortBuffer</code></li><li><code>IntBuffer</code></li><li><code>LongBuffer</code></li><li><code>FloatBuffer</code></li><li><code>DoubleBuffer</code></li></ul><p><strong><a href="https://colobu.com/2014/10/20/java-buffer-basic/" target="_blank" rel="noopener">https://colobu.com/2014/10/20/java-buffer-basic/</a></strong> </p><h4 id="12-属性"><a href="#12-属性" class="headerlink" title="12.属性"></a>12.属性</h4><p><strong>容量(Capacity)</strong></p><p>创建时设定,不能修改</p><p><strong>上界(Limit)</strong></p><p>缓冲区中,存在元素的计数</p><p><strong>位置(Position)</strong></p><p>下一个要被读或写的元素索引,位置自动由相应的get()和put()更新</p><p><strong>标记(Mark)</strong></p><p>备忘位置标记,</p><p>mark()设定mark=postion</p><p>reset()设定position=mark </p><p><strong>未读/写数量remaining()</strong></p><p>返回position与limit的差</p><p><strong>重置reset()</strong></p><p>将position的值设置为mark的值,这个方法不会改变mark的值,也不会丢弃mark的值</p><p><strong>清空clear()</strong></p><p>清空缓冲区,position设置为0,limit设置为capacity,mark设置被丢弃</p><p><strong>翻转flip()</strong> </p><p>将limit设置为position的值,将position设置为0,如果设置了mark会被丢弃,一般在填充完毕后读写数据调用</p><p><strong>回退rewind()</strong></p><p>position设置为0,limit不变,与翻转类似</p><p><strong>array() 返回底层数组实现</strong></p><p>底层如果不是数组实现,或者是只读,可能抛出异常</p><p><strong>arrayOffset ()</strong></p><p>Buffer第一个元素在数组中的偏移量,position+arrayOffset()的值</p><p><strong>hasArray()</strong></p><p>判断Buffer是否有底层数组实现</p><p><strong>hasRemaining</strong></p><p>判断position和limit之前是否还有元素</p><p><strong>isReadOnly()是否只读</strong></p><p><strong>isDirect</strong></p><p>buffer判断是否为<strong>直接缓冲区</strong></p><p><strong>创建缓冲区allocate/allocateDirect/warp</strong></p><p>创建HeapByteBuffer/DirectByteBuffer/HeapByteBuffer类</p><p><strong>以下不等式在任何情况下都成立</strong></p><p><strong>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong></p><h4 id="13-注意"><a href="#13-注意" class="headerlink" title="13.注意:"></a>13.<strong>注意:</strong></h4><p><strong>容量虽然是固定的,但其他三个属性可以再使用缓冲区时改变</strong></p><p><strong>buffer允许级联调用:buffer.mark().position(5).reset();</strong></p><h4 id="14-示例"><a href="#14-示例" class="headerlink" title="14.示例"></a>14.<strong>示例</strong></h4><h5 id="A-间接缓冲区"><a href="#A-间接缓冲区" class="headerlink" title="A.间接缓冲区"></a>A.<strong>间接缓冲区</strong></h5><p><strong>获取缓冲池内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String temp=&quot;打破玉笼飞彩凤,顿开金锁走蛟龙&quot;;</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">byteBuffer.put(temp.getBytes());</span><br><span class="line">byte[] array = byteBuffer.array();</span><br><span class="line">System.out.println(new String(array));</span><br></pre></td></tr></table></figure><p><strong>比较缓冲池中的内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String temp1=&quot;打破玉笼飞彩凤,顿开金锁走蛟龙&quot;;</span><br><span class="line">String temp2=&quot;打破玉笼飞彩凤,顿开金锁走蛟龙&quot;;</span><br><span class="line">ByteBuffer byteBuffer1 = ByteBuffer.allocate(1024);</span><br><span class="line">ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);</span><br><span class="line">byteBuffer1.put(temp1.getBytes());</span><br><span class="line">byteBuffer2.put(temp2.getBytes());</span><br><span class="line">System.out.println(byteBuffer1.equals(byteBuffer2)); //true</span><br><span class="line">System.out.println(byteBuffer1.compareTo(byteBuffer2)); //0 相等</span><br></pre></td></tr></table></figure><p><strong>相等条件:</strong></p><ol><li>两个对象类型相同</li><li>两个对象都剩余同样数量的元素</li><li>在每个缓冲区中应被Get()函数返回的剩余数据元素序列必须一致</li></ol><p><strong>如果不满足任意一条,都会返回false</strong></p><p><strong>批量移动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String temp=&quot;飞雪连天射白鹿,笑书神侠倚碧鸳&quot;;</span><br><span class="line">char[] chars = temp.toCharArray();</span><br><span class="line">CharBuffer charBuffer = CharBuffer.wrap(chars,0,chars.length);//相当于allocate,底层HeapCharBuffer</span><br><span class="line">System.out.println(charBuffer.array());</span><br></pre></td></tr></table></figure><h5 id="B-直接字节缓冲区"><a href="#B-直接字节缓冲区" class="headerlink" title="B.直接字节缓冲区"></a>B.<strong>直接字节缓冲区</strong></h5><p><strong>allocateDirect();</strong></p><p>直接使用本地I/O操作,减少一层copy动作,是JVM中可用的最高效I/O机制</p><p>非直接字节缓冲区可以被传递给通道,但是这样消耗性能,如果向一个通道传递一个非直接字节缓冲对象,可能隐含如下操作:</p><ol><li>创建一个临时的直接ByteBuffer对象</li><li>将非直接缓冲区内容复制到临时缓冲中</li><li>使用临时缓冲区执行低层次的I/O操作</li><li>临时缓冲区对象离开作用于,最终成为被回收的无用数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String temp = &quot;This is new message&quot;;</span><br><span class="line">       byte[] bytes = temp.getBytes();</span><br><span class="line">       ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);</span><br><span class="line">       byteBuffer.put(bytes);</span><br><span class="line"></span><br><span class="line">       byte[] resultByte = new byte[2];//中文会被切坏,此处仅演示功能,不能直接使用</span><br><span class="line">       int count=0;</span><br><span class="line">       for (int i = 0; i&lt;byteBuffer.position(); i++) &#123;</span><br><span class="line">           if (byteBuffer.position()&gt;=resultByte.length)&#123;</span><br><span class="line">               System.out.print(new String(resultByte)); </span><br><span class="line">               count=0;</span><br><span class="line">           &#125;</span><br><span class="line">           resultByte[count]=byteBuffer.get(i);</span><br><span class="line">           count++;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO基础入门-一-之缓冲区Buffer&quot;&gt;&lt;a href=&quot;#NIO基础入门-一-之缓冲区Buffer&quot; class=&quot;headerlink&quot; title=&quot;NIO基础入门(一)之缓冲区Buffer&quot;&gt;&lt;/a&gt;NIO基础入门(一)之缓冲区Buffer&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="I/O" scheme="http://yoursite.com/categories/I-O/"/>
    
    
  </entry>
  
  <entry>
    <title>NIO基础入门(二)之通道Channel</title>
    <link href="http://yoursite.com/2018/10/23/NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%8C)%E4%B9%8B%E9%80%9A%E9%81%93Channel/"/>
    <id>http://yoursite.com/2018/10/23/NIO基础入门(二)之通道Channel/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-23T12:53:26.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO基础入门-二-之通道Channel"><a href="#NIO基础入门-二-之通道Channel" class="headerlink" title="NIO基础入门(二)之通道Channel"></a>NIO基础入门(二)之通道Channel</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>nio的第二个创新<strong>Channel</strong>,既不是扩展也不是增强,而是全新的与I/O服务的直接连接</p><p>Channel通常位于字节缓冲区和通道另一边的实体(文件/套接字等)之间有效的数据传输</p><p>如</p><p>通道两端为缓冲区,是通道<strong>发送</strong>和<strong>接收</strong>数据的端点,假设为<strong>A/B</strong></p><ol><li><p><strong>A端</strong>:一个数据被填充到缓冲区中,接着将缓冲区中的数据冲到通道中–&gt;到达通道<strong>B端</strong></p></li><li><p><strong>B端</strong>:flip翻转缓冲区(打开盖子)并清空</p></li></ol><p>与缓冲区不同,通道<strong>API主要由接口指定</strong>,<strong>不同的操作系统上的实现会有根本性差异</strong></p><p>所以通道的<strong>API仅仅描述可以做什么</strong></p><p>(实现经常使用操作系统的本地代码,通道接口允许以一种受控且可移植的方式来访问底层I/O服务)</p><p><strong>通道的单/双向</strong></p><p>通道可以是单向(unidirectional)或者双向的(bidirectional)</p><p>一个channel类实现<strong>ReadableByteChannel</strong>接口提供的read()方法</p><p>另一个channel类实现<strong>WritableByteChannel</strong>接口提供的write()方法</p><p>那么这两个管道都是<strong>单向的,</strong></p><p>如果一个类同时实现这两个接口,那么他就是<strong>双向的</strong>,可以双向传输数据</p><h3 id="2-Channel源码"><a href="#2-Channel源码" class="headerlink" title="2.Channel源码"></a>2.Channel源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Channel extends Closeable &#123;</span><br><span class="line">public boolean isOpen();</span><br><span class="line">public void close() throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在顶级接口中,只有<strong>打开判断</strong>和<strong>关闭通道</strong>两个方法,所有有趣的实现都在他的子接口和实现类中</p><p>大部分通道是可中断的,只要有实现<strong>InterruptibleChannel</strong>可中断接口</p><p>Channel接口引申出的其他接口都是<strong>面向字节的子接口,</strong>包括Writable ByteChannel和ReadableByteChannel等</p><p>通道只能在字节缓冲区上操作,层次结构表名其他类型的通道也可以从Channel接口引申,都是字节实现,因为操作系统都是以字节实现底层I/O接口的</p><h3 id="3-类型"><a href="#3-类型" class="headerlink" title="3.类型"></a>3.类型</h3><p><strong>JDK1.4</strong></p><p><strong>文件通道:</strong></p><p>FileChannel</p><p><strong>套接字通道:</strong></p><p>SocketChannel</p><p>ServerSocketChannel</p><p>DatagramChannel</p><p><strong>JDK1.7以后完善AIO增加类型</strong></p><p><strong>nio2 增加回调</strong></p><p><strong>CompletionHandler</strong></p><p><strong>文件通道:</strong></p><p>AsynchronousFileChannel 异步文件IO</p><p><strong>套接字通道</strong></p><p>AsynchronousSocketChannel  客户端</p><p>AsynchronousServerSocketChannel 服务器</p><h3 id="4-通道操作"><a href="#4-通道操作" class="headerlink" title="4.通道操作"></a>4.通道操作</h3><p>FileChannel对象只能通过一个打开的<strong>RamdomAccessFile/FileInputStream</strong>或者<strong>FileOutputStream</strong>对象上调用</p><p>getChannel()方法来获取,而不能直接创建一个FileChannel对象</p><p><strong>建立连接</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"> socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8000));</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(new InetSocketAddress(&quot;localhost&quot;,8001));</span><br><span class="line"></span><br><span class="line">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">datagramChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8002));</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = new FileInputStream(&quot;d:\\test.txt&quot;);</span><br><span class="line">        FileChannel channel = inputStream.getChannel();</span><br></pre></td></tr></table></figure><p><strong>文件读写</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">File src = new File(&quot;d:\\testdd.txt&quot;);</span><br><span class="line">File target = new File(&quot;d:\\testddTarget.txt&quot;);</span><br><span class="line">//if 判断略</span><br><span class="line">FileInputStream fis = null;</span><br><span class="line">FileOutputStream fos=null;</span><br><span class="line">FileChannel cfis=null;</span><br><span class="line">FileChannel cfos=null;</span><br><span class="line">try &#123;</span><br><span class="line">    fis = new FileInputStream(src);</span><br><span class="line">    fos = new FileOutputStream(target);</span><br><span class="line">     cfis = fis.getChannel();</span><br><span class="line">     cfos = fos.getChannel();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);</span><br><span class="line">    while (cfis.read(byteBuffer)&gt;0)&#123;</span><br><span class="line">        byteBuffer.flip();    //注意,读写转换一定要翻转,否则写出去的是乱码或者空占位</span><br><span class="line">        cfos.write(byteBuffer);</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (cfis.isOpen())    //通道需要关闭,因为通道无法复用</span><br><span class="line">        cfis.close();</span><br><span class="line">        if (cfos.isOpen())</span><br><span class="line">        cfos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;写出成功&quot;);</span><br></pre></td></tr></table></figure><h3 id="5-Channel矢量I-O"><a href="#5-Channel矢量I-O" class="headerlink" title="5.Channel矢量I/O"></a>5.<strong>Channel矢量I/O</strong></h3><p><strong>Scatter/Gather</strong></p><p>简单而强大的概念,可以在多个缓冲区上实现一个简单的I/O操作</p><p>对于write而言:数据从几个缓冲区中<strong>按顺序抽取</strong>(gather)并沿着通道发送</p><p>对于read而言:从通道中读取的数据会<strong>按顺序散布</strong>(Scatter)到多个缓冲区,将每个缓冲区<strong>填满</strong>直至<strong>通道中的数据</strong>或者<strong>缓冲区最大空间</strong>消耗完</p><p><strong>注意:缓冲区本身并不具备Scatter/Gather</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">File src = new File(&quot;d:\\testdd.txt&quot;);</span><br><span class="line">        File target = new File(&quot;d:\\testddTarget.txt&quot;);</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        FileOutputStream fos=null;</span><br><span class="line">        FileChannel cfis=null;</span><br><span class="line">        FileChannel cfos=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis = new FileInputStream(src);</span><br><span class="line">            fos = new FileOutputStream(target);</span><br><span class="line">            cfis = fis.getChannel();</span><br><span class="line">            cfos = fos.getChannel();</span><br><span class="line">            ByteBuffer byteBuffer1 = ByteBuffer.allocateDirect(1024);</span><br><span class="line">            ByteBuffer byteBuffer2 = ByteBuffer.allocateDirect(1024*16);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            ByteBuffer[] byteBuffers=&#123;byteBuffer1,byteBuffer2&#125;;    //合并</span><br><span class="line"></span><br><span class="line">            while (cfis.read(byteBuffers)&gt;0)&#123;    //Scatter注入</span><br><span class="line">                byteBuffer1.flip();</span><br><span class="line">                byteBuffer2.flip();</span><br><span class="line">                cfos.write(byteBuffers);    //gather抽取</span><br><span class="line">                byteBuffer1.clear();</span><br><span class="line">                byteBuffer2.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (cfis.isOpen())</span><br><span class="line">                    cfis.close();</span><br><span class="line">                if (cfos.isOpen())</span><br><span class="line">                    cfos.close();</span><br><span class="line">                fis.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;写出成功&quot;);</span><br></pre></td></tr></table></figure><h3 id="6-文件通道"><a href="#6-文件通道" class="headerlink" title="6.文件通道"></a>6.文件通道</h3><p>对于文件通道来说,总司阻塞式的,因此不能被置于非阻塞模式(由文件I/O性质决定)</p><p>对于文件I/O而言,最强大之处在于异步I/O,他可以允许一个进程操作一个或多个I/O操作,即<strong>AIO</strong></p><p><strong>FileChannel</strong>对象是线程安全的,<strong>多个进程(进程级别和线程)</strong>可以在<strong>同一个</strong>实例(<strong>磁盘文件</strong>)上并发调用方法而不会有任何问题</p><p>但是影响通道位置和大小的操作都是单线程,这些操作同时最多只有一个执行,再多尝试会产生阻塞</p><p><strong>IO VS NIO1 VS NIO2</strong></p><p><a href="https://www.jianshu.com/p/1e55c6705392" target="_blank" rel="noopener">https://www.jianshu.com/p/1e55c6705392</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO基础入门-二-之通道Channel&quot;&gt;&lt;a href=&quot;#NIO基础入门-二-之通道Channel&quot; class=&quot;headerlink&quot; title=&quot;NIO基础入门(二)之通道Channel&quot;&gt;&lt;/a&gt;NIO基础入门(二)之通道Channel&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="I/O" scheme="http://yoursite.com/categories/I-O/"/>
    
    
  </entry>
  
  <entry>
    <title>NIO基础入门(三)之文件锁定与内存映射文件</title>
    <link href="http://yoursite.com/2018/10/23/NIO%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%89)%E4%B9%8B%E6%96%87%E4%BB%B6%E9%94%81%E5%AE%9A%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/10/23/NIO基础入门(三)之文件锁定与内存映射文件/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2018-10-23T12:57:08.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO基础入门-三-之文件锁定与内存映射文件"><a href="#NIO基础入门-三-之文件锁定与内存映射文件" class="headerlink" title="NIO基础入门(三)之文件锁定与内存映射文件"></a>NIO基础入门(三)之文件锁定与内存映射文件</h2><p>[TOC]</p><h3 id="1-概括"><a href="#1-概括" class="headerlink" title="1.概括"></a>1.概括</h3><p><strong>文件锁定:</strong>JDK1.4之前,Java I/O模型未能提供文件锁定,1.4以后发布</p><p>作用:集成许多其他非java程序时,需要使用文件锁定,他除了锁定外还可以判优(判断多个访问请求的优先级)一个大系统的多个java组件访问顺序.</p><p><strong>内存映射文件:</strong>FileChannel类中提供一个map()的方法,该方法可以在一个打开的文件和一个特殊类型的ByteBuffer之间建立一个虚拟内存映射.</p><p>即:在FileChannel上调用map()方法,会创建一个由磁盘文件支持的虚拟内存映射(virtual memory mapping) ,并在这块内存空间外部封装一个<strong>MappedByteBuffer</strong>对象</p><p>内存映射文件不需要将数据Copy到内核空间,直接读写,速度更快</p><p><strong>性能对比:</strong>本地磁盘文件复制,17MB文本为例,内存映射大概20-90毫秒,而通道耗时40-100毫秒(测试通道大小设置为略大于文本长度的最佳效率,如果指定缓存池为1024,则速度更慢400-900毫秒,频繁复制清空缓冲区导致)</p><h3 id="2-文件锁定"><a href="#2-文件锁定" class="headerlink" title="2.文件锁定"></a>2.文件锁定</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2-1.概念"></a>2-1.概念</h4><p>文件锁定的锁可以是<strong>共享锁</strong>(Shared),也可以是<strong>独占锁</strong>(exclusive)</p><p>文件锁定特性很大程度上依赖<strong>本地操作系统</strong>实现,并非所有操作系统都支持共享锁,</p><p>但是不支持共享锁的系统,会被<strong>自动提升为独占锁</strong>,因此大多数情况使用共享锁即可(<strong>交换机也可以单槽向多槽自动提升</strong>)</p><p>文件锁定是与<strong>文件本身</strong>关联,<strong>并非单个文件句柄或者通道</strong></p><p><strong>文件锁定判优:</strong>只对进程级别判优,对线程级别无效</p><p><strong>注意:</strong>文件锁定属于进程级别锁定,JVM内部无法锁定(锁定的是文件)</p><p><strong>即:</strong></p><p>JVM中一个线程使用独占锁,JVM内部另一个线程也能访问</p><p>如果此时JVM外部访问该文件,则进入阻塞等待</p><h4 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2-2.方法"></a>2-2.方法</h4><p><strong>lock()</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final FileLock lock() throws IOException &#123;</span><br><span class="line">     return lock(0L, Long.MAX_VALUE, false);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不带参数默认锁定整个文件,也可以指定大小锁定</p><p> <strong>第一个参数</strong>:指定锁定起点: position</p><p> <strong>第二个参数</strong>:指定size,锁定大小(锁定范围可以任意指定,可以比文件还要大,这样未有位置也会被锁定,未被锁定的范围则不受文件锁定保护)</p><p> <strong>第三个参数</strong>:是否开启Shared共享锁,true共享锁/false独占锁</p><p><strong>trylock()</strong>非阻塞锁定,如果返回不及时,会返回null</p><p>lock衍生方法略…</p><h3 id="3-内存映射文件"><a href="#3-内存映射文件" class="headerlink" title="3.内存映射文件"></a>3.内存映射文件</h3><p><strong>3-1.概念</strong></p><p>如上所说,内存映射的方式效率有时候更高于通道(数据越大越明显)</p><p>不需要做明确的系统操作(那会消耗很大的时间)</p><p>系统操作的虚拟内存可以缓存内存页,这些页(虚拟内存)是<strong>系统内存来缓存的</strong>,<strong>不会消耗java内存堆</strong></p><p><strong>3-2.方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract MappedByteBuffer map(MapMode mode,long position, long size)throws IOException;</span><br></pre></td></tr></table></figure><p><strong>第一个参数MapMode</strong>:指定内存映射策略</p><p> <code>MapMode READ_ONLY //只读,force操作无法在该策略下生效`</code>MapMode READ_WRITE //读写<code></code>MapMode PRIVATE  //私有副本拷贝页,所有操作不影响本地文件,修改的是内存副本,如果内存清空会丢失,force操作无法在该策略下生效`</p><p><strong>第二个参数position</strong>:映射文件的起始位置,0是从头开始,与lock参数相同意思</p><p><strong>第三个参数size</strong>:cap,映射容量,与lock参数相同意思,<strong>通道.size 映射整个文件</strong></p><p><strong>没有unmap()方法</strong></p><p>也就是说,一个映射一旦建立之后将保持有效,直到MappedByteBuffer对象被垃圾回收为止.</p><p><strong>注意:</strong>同锁不一样的是,内存映射并没有绑定在通道上,关闭通道也不会对内存映射造成破坏,只有丢弃缓冲区本身才会破坏映射</p><p>内存映射可以和Gather/Scatter结合.SocketChannel之类通道的read()和write()方法也可以有效的进行传递(具备ByteBuffer的功能)</p><p><strong>load()方法</strong></p><p>将磁盘数据读取到内存,有的操作系统可能不会自动读取到内存(win7可以自动读取),因此可以使用load方法</p><p><strong>过程:</strong></p><p>类似打开一个文件:文件先被定位,然后创建一个文件句柄,准备好之后就可以通过这个句柄来访问文件数据,虚拟内存系统将根据指定需要,将文件中相应区域的数据读进来,因为将文件读到内存中也需要一次或多次,如果将所有数据读到内存中,那么<strong>相当于文件的所有页是常住内存,那么他的访问速度就和基于内存的缓冲区一样了</strong></p><p>未完.待补充;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NIO基础入门-三-之文件锁定与内存映射文件&quot;&gt;&lt;a href=&quot;#NIO基础入门-三-之文件锁定与内存映射文件&quot; class=&quot;headerlink&quot; title=&quot;NIO基础入门(三)之文件锁定与内存映射文件&quot;&gt;&lt;/a&gt;NIO基础入门(三)之文件锁定与内存映射
      
    
    </summary>
    
      <category term="I/O" scheme="http://yoursite.com/categories/I-O/"/>
    
    
  </entry>
  
  <entry>
    <title>Concurrent并发包入门(四)之Executor</title>
    <link href="http://yoursite.com/2018/10/19/Concurrent%E5%B9%B6%E5%8F%91%E5%8C%85%E5%85%A5%E9%97%A8(%E5%9B%9B)%E4%B9%8BExecutor/"/>
    <id>http://yoursite.com/2018/10/19/Concurrent并发包入门(四)之Executor/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-10-23T12:40:54.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="concurrent并发包入门-四-之Executor"><a href="#concurrent并发包入门-四-之Executor" class="headerlink" title="concurrent并发包入门(四)之Executor"></a>concurrent并发包入门(四)之Executor</h2><p><strong>任务执行和调度的框架</strong></p><p><img src="file:///C:/Users/Administrator/Documents/My Knowledge/temp/cf5088ed-5e84-42e2-a158-d4d19058c818/128/index_files/879896-20160624162220547-1137214388.jpg" alt="img"></p><p><strong>Executor接口:</strong>顶级接口,只有一个方法,<strong>execute(Runnable command)</strong>;</p><p><strong>Executor优点:</strong></p><p>任务提交过程与执行过程解耦,用户只需要<strong>关心如何定义好任务</strong>即可</p><p><strong>Executors类:</strong>相当于<strong>工具类</strong>,类似Conllections,创建</p><ul><li>ExecutorService</li><li>ScheduledExecutorService</li><li>ThreadFactory</li><li>Callable等对象</li></ul><h3 id="Executors线程池"><a href="#Executors线程池" class="headerlink" title="Executors线程池"></a><strong>Executors线程池</strong></h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newCachedThreadPool 大小不受限,当线程释放时,可重用该线程,自动终止并从缓存中移除那些已有 60 秒钟未被使用的线程</span><br><span class="line">newFixedThreadPool  大小固定,无可用线程时,任务等待,直到有可用现成 如,建立5个固定线程容量:Executors.newFixedThreadPool(5)</span><br><span class="line">newSingleThreadExecutor 单线程,任务依次执行</span><br><span class="line">newScheduledThreadPool  创建定长线程池,支持定时及周期性任务执行</span><br></pre></td></tr></table></figure><h3 id="示例newCachedThreadPool"><a href="#示例newCachedThreadPool" class="headerlink" title="示例newCachedThreadPool"></a>示例newCachedThreadPool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoExecutor</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/19 17:50</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoExecutor &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        cachedThreadPool.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;newCachedThreadPool-&gt;Runnable execute:This is Runnable Thread,no The return value&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; submit = cachedThreadPool.submit(new CallableDemo());</span><br><span class="line">        System.out.println(&quot;newCachedThreadPool-&gt;Callable submit:&quot;+submit.get());</span><br><span class="line">        Future&lt;?&gt; submit1 = cachedThreadPool.submit(new RunnableDemo());</span><br><span class="line">        System.out.println(&quot;newCachedThreadPool-&gt;Runnable submit:&quot;+submit1.get()); //null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CallableDemo implements Callable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        return &quot;This is Callable Thread&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RunnableDemo implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;This is Runnable Thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例newFixedThreadPool"><a href="#示例newFixedThreadPool" class="headerlink" title="示例newFixedThreadPool"></a>示例newFixedThreadPool</h3><p>创建可重用的固定线程数的线程池,以共享的无界队列方式运行</p><h3 id="示例newScheduledThreadPool"><a href="#示例newScheduledThreadPool" class="headerlink" title="示例newScheduledThreadPool"></a><strong>示例newScheduledThreadPool</strong></h3><h4 id="1-shedule-Runnable-command-long-delay-TimeUnit-unit"><a href="#1-shedule-Runnable-command-long-delay-TimeUnit-unit" class="headerlink" title="1.shedule(Runnable command, long delay, TimeUnit unit);"></a>1.shedule(Runnable command, long delay, TimeUnit unit);</h4><p>一次性延时,后续线程将不再延时 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread=new Thread(()-&gt; &#123;</span><br><span class="line">                System.out.println(&quot;开始运动&quot;+Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">            executor.execute(thread);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="2-sheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit"><a href="#2-sheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit" class="headerlink" title="2.sheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)"></a>2.sheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</h4><p>执行给定的初始化延时时间initialDelay后,间隔period时间重复执行,频率优先,按照任务开始时间计算间隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);         </span><br><span class="line">Thread thread=new Thread(()-&gt; System.out.println(&quot;开始运动&quot;));</span><br><span class="line">threadPool.scheduleAtFixedRate(thread,5,1,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h4 id="3-scheduleWithFixDelay-Runnable-command-long-initialDelay-long-period-TimeUnit-unit"><a href="#3-scheduleWithFixDelay-Runnable-command-long-initialDelay-long-period-TimeUnit-unit" class="headerlink" title="3.scheduleWithFixDelay(Runnable command, long initialDelay, long period, TimeUnit unit)"></a>3.scheduleWithFixDelay(Runnable command, long initialDelay, long period, TimeUnit unit)</h4><p>执行给定的初始化延时时间initialDelay后,间隔period时间重复执行,间隔优先,按照[本次任务结束时间]和[下次任务开始时间]计算间隔</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(5);         </span><br><span class="line">Thread thread=new Thread(()-&gt; System.out.println(&quot;开始运动&quot;));</span><br><span class="line">threadPool.scheduleWithFixedDelay(thread,5,1,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="示例newSingleThreadExecutor"><a href="#示例newSingleThreadExecutor" class="headerlink" title="示例newSingleThreadExecutor"></a>示例newSingleThreadExecutor</h3><p>创建单线程化的线程池,只会用唯一的工作线程来执行任务,保证所有任务按照指定的顺序(<strong>FIFO,FILO,优先级</strong>)执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Thread thread=new Thread(()-&gt; &#123;</span><br><span class="line">                System.out.println(&quot;开始运动&quot;+Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">            executor.execute(thread);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/lpjishu/article/details/53083614" target="_blank" rel="noopener">https://blog.csdn.net/lpjishu/article/details/53083614</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;concurrent并发包入门-四-之Executor&quot;&gt;&lt;a href=&quot;#concurrent并发包入门-四-之Executor&quot; class=&quot;headerlink&quot; title=&quot;concurrent并发包入门(四)之Executor&quot;&gt;&lt;/a&gt;concu
      
    
    </summary>
    
      <category term="JAVA并发编程" scheme="http://yoursite.com/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Concurrent并发包入门(三)之Synchronizers</title>
    <link href="http://yoursite.com/2018/10/19/Concurrent%E5%B9%B6%E5%8F%91%E5%8C%85%E5%85%A5%E9%97%A8(%E4%B8%89)%E4%B9%8BSynchronizers/"/>
    <id>http://yoursite.com/2018/10/19/Concurrent并发包入门(三)之Synchronizers/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-10-23T12:34:36.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concurrent并发包入门-三-之Synchronizers"><a href="#Concurrent并发包入门-三-之Synchronizers" class="headerlink" title="Concurrent并发包入门(三)之Synchronizers"></a>Concurrent并发包入门(三)之Synchronizers</h2><p>[TOC]</p><h3 id="线程同步工具"><a href="#线程同步工具" class="headerlink" title="线程同步工具"></a>线程同步工具</h3><ol><li>闭锁 CountDownLatch</li><li>栅栏 CyclicBarrier</li><li>信号量 Semaphore</li><li>交换器 Exchanger</li><li>BlockingQueue(查看第二章即可)</li></ol><h3 id="1-CountDownLatch-闭锁"><a href="#1-CountDownLatch-闭锁" class="headerlink" title="1.CountDownLatch 闭锁"></a>1.CountDownLatch 闭锁</h3><p>java.util.concurrent.CountDownLatch是一个并发构造,允许一个或多个线程等待一系列指定操作完成后,继续线程执行.</p><p>CountDownLatch内部包含一个指定的计数器,一开始初始化为一个整数,发生一个事件,则调用一次countDown方法,计数器减一,直到计数器为0时,才继续执行<br><img src="https://i.imgur.com/o7PgHYj.jpg" alt=""></p><p><strong>FutureTask也可以用作闭锁,其get方法会等待任务完成后返回结果,否则一直阻塞</strong></p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h4><p><strong>实现最大的并行性</strong></p><p><strong>开始执行前等待n个线程完成各自任务,如:</strong></p><p>多线程下载任务,每个线程下载一部分,最后一个线程合并拼接</p><p><strong>死锁/并发问题检测</strong></p><p>n个线程访问共享资源,每次测试阶段的线程数目是不同的,最后产生死锁或者并发问题检测</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a><strong>源码</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) 指定计数器构造</span><br><span class="line">private final Sync sync; //异步操作</span><br></pre></td></tr></table></figure><p><strong>await方法</strong></p><p>进入等待的方法,计数器归零后执行该线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">     sync.acquireSharedInterruptibly(1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="await调用acquireSharedInterruptibly方法"><a href="#await调用acquireSharedInterruptibly方法" class="headerlink" title="await调用acquireSharedInterruptibly方法"></a>await调用<strong>acquireSharedInterruptibly</strong>方法</h5><p>线程中断或超时时,抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="acquireSharedInterruptibly调用doAcquireSharedInterruptibly-arg-方法"><a href="#acquireSharedInterruptibly调用doAcquireSharedInterruptibly-arg-方法" class="headerlink" title="acquireSharedInterruptibly调用doAcquireSharedInterruptibly(arg);方法"></a>acquireSharedInterruptibly调用<strong>doAcquireSharedInterruptibly(arg);</strong>方法</h5><p>调用AQS共享锁,读不上锁,写加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Acquires in shared interruptible mode.</span><br><span class="line">     * @param arg the acquire argument</span><br><span class="line">     */</span><br><span class="line">    private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        final Node node = addWaiter(Node.SHARED);</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head) &#123;</span><br><span class="line">                    int r = tryAcquireShared(arg);</span><br><span class="line">                    if (r &gt;= 0) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = null; // help GC</span><br><span class="line">                        failed = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="await-long-timeout-TimeUnit-unit-方法"><a href="#await-long-timeout-TimeUnit-unit-方法" class="headerlink" title="await(long timeout,TimeUnit unit)方法"></a><strong>await(long timeout,TimeUnit unit)方法</strong></h5><p>调用可中断共享超时锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean await(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="countDown方法"><a href="#countDown方法" class="headerlink" title="countDown方法"></a><strong>countDown方法</strong></h5><p>计数器的数量其实是锁的数量,每次调用,则释放一个共享锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">       sync.releaseShared(1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="getCount方法"><a href="#getCount方法" class="headerlink" title="getCount方法"></a><strong>getCount方法</strong></h5><p>通过异步查看当前存在锁的数量(计时器剩余数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public long getCount() &#123;</span><br><span class="line">    return sync.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoCountDownLatch</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/16 10:11</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoCountDownLatch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(3);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(&quot;操作完成,提交!&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;1操作,连接&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;2操作,业务&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(countDownLatch.getCount()); //1  即计数器还剩1</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;3操作,业务完成&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-CyclicBarrier-栅栏"><a href="#2-CyclicBarrier-栅栏" class="headerlink" title="2.CyclicBarrier 栅栏"></a>2.CyclicBarrier 栅栏</h3><p><strong>CyclicBarrier</strong>是一个同步机制,可以对算法线程实现同步</p><p>内部由ReeantrantLock,Condition,计数器count控制线程执行</p><p>与CountDownLatch区别在于CyclicBarrier<strong>可重用</strong></p><p>所有的线程都执行到栅栏位置后,才能继续往下执行,否则阻塞等待其他线程</p><p>通过调用await()方法即可(重载超时方法)<br><img src="https://i.imgur.com/1JO5JZ8.jpg" alt=""></p><h5 id="释放条件"><a href="#释放条件" class="headerlink" title="释放条件"></a><strong>释放条件</strong></h5><ol><li>最后一个调用await()方法到达CyclicBarrier</li><li>当前线程被其他线程打断(其他线程调用本线程的interrupt方法)</li><li>其他等待栅栏的线程被打断</li><li>其他等待栅栏的线程超时释放</li><li>外部调用了栅栏的CyclicBarrier.rest()方法</li></ol><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a><strong>场景</strong></h4><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a><strong>源码</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties) &#123;    //构造,指定线程数量</span><br><span class="line">        this(parties, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;    //构造,指定线程数和栅栏线程Runnable</span><br><span class="line">        if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">        this.parties = parties;</span><br><span class="line">        this.count = parties;</span><br><span class="line">        this.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line">                        </span><br><span class="line">private final ReentrantLock lock = new ReentrantLock(); //全局重入锁</span><br><span class="line">private final Condition trip = lock.newCondition(); //控制线程等待</span><br><span class="line">private final int parties; //栅栏数量</span><br><span class="line">private final Runnable barrierCommand; //到达CyclicBarrier时运行线程(到达栅栏时)</span><br><span class="line">private Generation generation = new Generation(); //初始化 generation</span><br><span class="line">private int count; //计数器</span><br><span class="line">                        </span><br><span class="line">    private void nextGeneration() &#123;    //生成下一个Generation</span><br><span class="line">        // signal completion of last generation</span><br><span class="line">        //唤醒所有等待的线程来获取 AQS 的state的值</span><br><span class="line">        trip.signalAll();</span><br><span class="line">        // set up next generation</span><br><span class="line">        //重新赋值计算器</span><br><span class="line">        count = parties;</span><br><span class="line">        //重新初始化generation</span><br><span class="line">        generation = new Generation();</span><br><span class="line">    &#125;</span><br><span class="line">                        </span><br><span class="line">   private void breakBarrier() &#123;    //当等待线程中断或超时时,唤醒所有等待中的线程</span><br><span class="line">        generation.broken = true;</span><br><span class="line">        count = parties;</span><br><span class="line">        trip.signalAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a><strong>await</strong>方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return dowait(false, 0L);</span><br><span class="line">        &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">            throw new Error(toe); // cannot happen</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public int await(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException,</span><br><span class="line">               BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        return dowait(true, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dowait方法-主要阻塞方法-await调用它-CyclicBarrier核心方法"><a href="#dowait方法-主要阻塞方法-await调用它-CyclicBarrier核心方法" class="headerlink" title="dowait方法(主要阻塞方法,await调用它)CyclicBarrier核心方法"></a><strong>dowait方法(主要阻塞方法,await调用它)CyclicBarrier核心方法</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private int dowait(boolean timed, long nanos)</span><br><span class="line">        throws InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;    //获取重入锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            final Generation g = generation; </span><br><span class="line"></span><br><span class="line">            if (g.broken)    //判断 generation 是否已经 broken</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            if (Thread.interrupted()) &#123;    //判断线程是否中断或超时,进行breakBarrier</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int index = --count;    //没有问题,则未执行的线程数减一,减到0表示等待线程都执行完毕</span><br><span class="line">            if (index == 0) &#123;  // tripped</span><br><span class="line">                boolean ranAction = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    final Runnable command = barrierCommand; //最后一个到达的线程执行command</span><br><span class="line">                    if (command != null) </span><br><span class="line">                        command.run();  </span><br><span class="line">                    ranAction = true;</span><br><span class="line">                    nextGeneration();    //更新generation</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // loop until tripped, broken, interrupted, or timed out</span><br><span class="line">            //自旋</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (!timed)</span><br><span class="line">                        trip.await();  //如果没有设置timeout,则一直等待</span><br><span class="line">                    else if (nanos &gt; 0L)//设置超时,进行超时等待</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                    if (g == generation &amp;&amp; ! g.broken) &#123; //等待过程线程被中断,则直接唤醒所有等待线程</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        throw ie;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // We&apos;re about to finish waiting even if we had not</span><br><span class="line">                        // been interrupted, so this interrupt is deemed to</span><br><span class="line">                        // &quot;belong&quot; to subsequent execution.</span><br><span class="line">                        Thread.currentThread().interrupt();    //中断,此处是为了让外界知道自己被中断过,因为此处breakBarrier激活了线程,所以这里中断对本线程没有影响</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (g.broken)     //barrierbraken异常抛出</span><br><span class="line">                    throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                if (g != generation) //所有线程到达barrier直接返回</span><br><span class="line">                    return index;</span><br><span class="line"></span><br><span class="line">                if (timed &amp;&amp; nanos &lt;= 0L) &#123; //等待超时直接抛出异常,重置generation</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw new TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(); //释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="CyclicBarrier一般方法"><a href="#CyclicBarrier一般方法" class="headerlink" title="CyclicBarrier一般方法"></a><strong>CyclicBarrier一般方法</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   //判断barrier是否broken=true </span><br><span class="line">public boolean isBroken() &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return generation.broken;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//重置barrier</span><br><span class="line">    public void reset() &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            breakBarrier();   // break the current generation</span><br><span class="line">            nextGeneration(); // start a new generation</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //主要用于调试,返回当前阻塞剩余的线程数</span><br><span class="line">  public int getNumberWaiting() &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return parties - count;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoCyclicBarrier</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/16 11:01</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoCyclicBarrier &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;线程1开始运行&quot;);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(&quot;线程1运行中&quot;);</span><br><span class="line">                Thread.sleep(10000);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(&quot;线程1结束运行&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;线程2开始运行&quot;);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(&quot;线程2运行中&quot;);</span><br><span class="line">                //java.util.concurrent.TimeoutException</span><br><span class="line">                //java.util.concurrent.BrokenBarrierException</span><br><span class="line">                cyclicBarrier.await(5, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(&quot;线程2结束运行&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Semaphore-信号量"><a href="#3-Semaphore-信号量" class="headerlink" title="3.Semaphore 信号量"></a>3.Semaphore 信号量</h3><p>Semaphore类是一个计数信号量,从概念上看,信号量维护了一个许可集,两个主要方法</p><ol><li>acquire()获得一个许可</li><li>release()释放一个许可</li></ol><p>在许可可用前,会阻塞每一个acquire</p><p>调用时,使用release方法添加一个许可,获得许可的线程被释放,未获得许可的线程仍然阻塞</p><p>主要用于<strong>限量控制并发执行</strong>代码的工具类,内部通过一个permit来定义并发执行的数量,理解为限制数量的ReadLock获取</p><p><strong>Semaphore通过Sync(AQS的继承类)代理来实现</strong></p><p><strong>支持公平和非公平模式</strong>,都是在AQS子类中,主要区分在tryAcquire中</p><h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a><strong>场景</strong></h4><ol><li>比如停车场停车信号,假设只有一个车位,同时来了两辆车,则只能释放一辆车进去,另一辆车需要等该车离开后才能进入</li><li>实现资源池</li><li>数据库连接池</li><li>线程池</li><li>对象池 ObjectCache</li><li>等等</li></ol><p><img src="https://i.imgur.com/1C0wtjI.jpg" alt=""></p><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a><strong>源码</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Sync sync;    //所有机制都通过AQS子类Sync来实现</span><br></pre></td></tr></table></figure><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a><strong>构造</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   public Semaphore(int permits) &#123; //调用非平锁,传入同时允许的最大许可数</span><br><span class="line">       sync = new NonfairSync(permits);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public Semaphore(int permits, boolean fair) &#123; //true调用公平锁,传入同时允许的最大许可数</span><br><span class="line">       sync = fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="Sync内部类"><a href="#Sync内部类" class="headerlink" title="Sync内部类"></a><strong>Sync内部类</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID = 1192457210091910933L;</span><br><span class="line"></span><br><span class="line">        Sync(int permits) &#123; //permits许可数</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int getPermits() &#123; //返回剩余许可数</span><br><span class="line">            return getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int nonfairTryAcquireShared(int acquires) &#123;  //传入acquires的许可数(permits)</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int available = getState();    //获得剩余许可数</span><br><span class="line">                int remaining = available - acquires; //许可数少于0时,停止自旋,跳出</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryReleaseShared(int releases) &#123; //传入释放许可数(releases)</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState(); //获得剩余许可数</span><br><span class="line">                int next = current + releases; //剩余许可数+允许释放许可数=下次释放数量,如果下次释放量小于剩余当前剩余量,则抛出异常,否则置换状态后,返回true</span><br><span class="line">                if (next &lt; current) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">                if (compareAndSetState(current, next))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void reducePermits(int reductions) &#123; //减少permits</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                int next = current - reductions;</span><br><span class="line">                if (next &gt; current) // underflow</span><br><span class="line">                    throw new Error(&quot;Permit count underflow&quot;);</span><br><span class="line">                if (compareAndSetState(current, next))</span><br><span class="line">                    return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         //将permit置为0</span><br><span class="line">        final int drainPermits() &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int current = getState();</span><br><span class="line">                if (current == 0 || compareAndSetState(current, 0))</span><br><span class="line">                    return current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="NonfairSync-FairSync方法"><a href="#NonfairSync-FairSync方法" class="headerlink" title="NonfairSync/FairSync方法"></a><strong>NonfairSync/FairSync</strong>方法</h5><p><strong>非公平锁/公平锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//非公平锁</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = -2694183684443567898L;</span><br><span class="line"></span><br><span class="line">        NonfairSync(int permits) &#123;</span><br><span class="line">            super(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//公平锁</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">        FairSync(int permits) &#123;</span><br><span class="line">            super(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                if (hasQueuedPredecessors())</span><br><span class="line">                    return -1;</span><br><span class="line">                int available = getState();</span><br><span class="line">                int remaining = available - acquires;</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="主要方法acquire-release"><a href="#主要方法acquire-release" class="headerlink" title="主要方法acquire/release"></a>主要方法<strong>acquire/release</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">      sync.acquireSharedInterruptibly(1);    //许可数,默认加1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> public void release() &#123;</span><br><span class="line">      sync.releaseShared(1); //释放数,默认减1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过AQS中的tate来控制permit的获取控制,类似一个限制数量的ReadLock,大量调用AQS</p><h5 id="示例一个线程中"><a href="#示例一个线程中" class="headerlink" title="示例一个线程中"></a><strong>示例一个线程中</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: Semaphore</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/16 13:33</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoSemaphore &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore = new Semaphore(1, true);//许可集中一次只允许存在并释放一个许可线程,开启公平模式</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            executorService.execute(new SemapRunnable(semaphore));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SemapRunnable implements Runnable &#123;</span><br><span class="line">    private Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    public SemapRunnable(Semaphore semaphore) &#123;</span><br><span class="line">        this.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;acquire加入许可集&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;释放线程许可&quot;);</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例两个线程中"><a href="#示例两个线程中" class="headerlink" title="示例两个线程中"></a>示例<strong>两个线程中</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: Semaphore</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/16 13:33</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoSemaphore &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Semaphore semaphore = new Semaphore(1, true);//许可集中一次只允许存在并释放一个许可线程,开启公平模式</span><br><span class="line">        new Thread(new SemapRunnable(semaphore)).start();</span><br><span class="line">        new Thread(new SemapRunnableRelease(semaphore)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SemapRunnable implements Runnable &#123;</span><br><span class="line">    private Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    public SemapRunnable(Semaphore semaphore) &#123;</span><br><span class="line">        this.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;acquire加入许可集&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SemapRunnableRelease implements Runnable &#123;</span><br><span class="line">    private Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    public SemapRunnableRelease(Semaphore semaphore) &#123;</span><br><span class="line">        this.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;释放线程许可&quot;);</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Exchanger-交换机"><a href="#4-Exchanger-交换机" class="headerlink" title="4.Exchanger 交换机"></a>4.Exchanger 交换机</h3><p>两个线程都达到共同的同步点(都执行到exchanger.exchange时刻),发生数据交换,否则等待到其他线程到达</p><p>当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。可以看成一个<strong>双向栅栏</strong></p><p>双向数据传输</p><ul><li>单槽(两个线程交换,高并发时性能低)机制(低并发使用)slotExchange</li><li>多槽(多个线程交换,线程间不影响)机制(高并发使用)arenaExchange</li><li>多槽的优先级更高,在单槽中也有特殊情况(线程竞争导致CAS失败)初始化,从而路由到多槽机制</li></ul><p>(单槽向多槽自动切换,这两个方法是私有的)</p><p><img src="https://i.imgur.com/jvriLCn.jpg" alt=""></p><h4 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a><strong>场景</strong></h4><p>常见在生产者-消费者 模型中,用于数据同步<br><img src="https://i.imgur.com/hmYcpPg.png" alt=""></p><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a><strong>源码</strong></h4><p>依赖ThreadLocal<node></node></p><p><strong>如图,创建一个ThreadLocal对象,并设置初始值,用来存储本地Node</strong></p><p>node对象就是线程交换时,实际存储数据的容器,A线程数据存在item中,则B线程的数据存在match中,称为匹配,parked线程对象是用来挂起线程使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended static final class Node &#123;</span><br><span class="line">       int index;              // Arena index node在Arena数组下标</span><br><span class="line">       int bound;              // Last recorded value of Exchanger.bound 交换机最后记录</span><br><span class="line">       int collides;           // Number of CAS failures at current bound  CAS失败记录</span><br><span class="line">       int hash;               // Pseudo-random for spins    伪随机的自旋数</span><br><span class="line">       Object item;            // This thread&apos;s current item 这个线程的数据项</span><br><span class="line">       volatile Object match;  // Item provided by releasing thread 别的线程提供的元素,也就是释放他的线程提供的数据item</span><br><span class="line">       volatile Thread parked; // Set to this thread when parked, else null 当阻塞时,设置此线程,不阻塞就不必要(会自旋)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="Exchanger属性"><a href="#Exchanger属性" class="headerlink" title="Exchanger属性"></a><strong>Exchanger</strong>属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> private static final int ASHIFT = 7;</span><br><span class="line">private static final int MMASK = 0xff;</span><br><span class="line">private static final int SEQ = MMASK + 1;</span><br><span class="line"> private static final int NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">static final int FULL = (NCPU &gt;= (MMASK &lt;&lt; 1)) ? MMASK : NCPU &gt;&gt;&gt; 1;</span><br><span class="line">private static final int SPINS = 1 &lt;&lt; 10;</span><br><span class="line">private static final Object NULL_ITEM = new Object();</span><br><span class="line">private static final Object TIMED_OUT = new Object();</span><br><span class="line">private final Participant participant; //线程状态(可监测交换节点,进行交换机制判断使用)</span><br><span class="line"> private volatile Node[] arena; //多槽机制数组</span><br><span class="line"> private volatile Node slot;    //单槽机制数组</span><br><span class="line">private volatile int bound;    //统计记录数</span><br></pre></td></tr></table></figure><h5 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a><strong>构造</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Exchanger() &#123;</span><br><span class="line">    participant = new Participant();    //创建新的线程状态(交换机)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class Participant extends ThreadLocal&lt;Node&gt; &#123; //交换机继承ThreadLocal</span><br><span class="line">    public Node initialValue() &#123; return new Node(); &#125; //创建ThreadLocal本地副本的Node对象,隔离线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="slotExchange-单槽交换方法"><a href="#slotExchange-单槽交换方法" class="headerlink" title="slotExchange 单槽交换方法"></a><strong>slotExchange</strong> 单槽交换方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private final Object slotExchange(Object item, boolean timed, long ns) &#123; //交换数据/是否开启超时/超时时间设置,默认0L</span><br><span class="line">       Node p = participant.get();    //当前线程携带的交换节点</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       if (t.isInterrupted()) // preserve interrupt status so caller can recheck    //线程中断状态检查</span><br><span class="line">           return null;</span><br><span class="line"></span><br><span class="line">       for (Node q;;) &#123;</span><br><span class="line">           if ((q = slot) != null) &#123;    //slot!=null,说明有线程已经到达节点并占用了slot</span><br><span class="line">               if (U.compareAndSwapObject(this, SLOT, q, null)) &#123;</span><br><span class="line">                   Object v = q.item; //获取交换数据</span><br><span class="line">                   q.match = item;   //设置交换数据</span><br><span class="line">                   Thread w = q.parked; </span><br><span class="line">                   if (w != null) //如果线程已经阻塞,则添加许可,唤醒此槽位线程</span><br><span class="line">                       U.unpark(w);</span><br><span class="line">                   return v;</span><br><span class="line">               &#125;</span><br><span class="line">               // create arena on contention, but continue until slot null</span><br><span class="line">               //如果cpu核数超过1,且bound为0时创建arena数组,并将bound设置为SEQ大小</span><br><span class="line">               if (NCPU &gt; 1 &amp;&amp; bound == 0 &amp;&amp;</span><br><span class="line">                   U.compareAndSwapInt(this, BOUND, 0, SEQ))</span><br><span class="line">                   arena = new Node[(FULL + 2) &lt;&lt; ASHIFT];    //如果多个配对线程竞争修改slot槽位,导致某个线程CAS修改slot失败,就会初始化arena多槽数组,进入arenaExchange</span><br><span class="line">           &#125;</span><br><span class="line">           else if (arena != null) //单槽交换中途出现初始化arena的操作,多槽数组不为空时,需要重新路由到多槽交换</span><br><span class="line">               return null; // caller must reroute to arenaExchange</span><br><span class="line">           else &#123;</span><br><span class="line">               p.item = item;</span><br><span class="line">               if (U.compareAndSwapObject(this, SLOT, null, p)) //将slot槽占用</span><br><span class="line">                   break;</span><br><span class="line">               p.item = null; //CAS操作失败,继续下一次自旋</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //执行到这说明当前线程已经到达,且已经占用了slot槽,需要等待配对线程到达</span><br><span class="line">       // await release</span><br><span class="line">       int h = p.hash;</span><br><span class="line">       long end = timed ? System.nanoTime() + ns : 0L;</span><br><span class="line">       int spins = (NCPU &gt; 1) ? SPINS : 1;  //自旋次数(和CPU核数有关)</span><br><span class="line">       Object v;    </span><br><span class="line">       while ((v = p.match) == null) &#123;    //p.match==null表示,匹配的线程还没到达</span><br><span class="line">           if (spins &gt; 0) &#123;        //优化操作:自旋过程中随机释放cpu</span><br><span class="line">               h ^= h &lt;&lt; 1; h ^= h &gt;&gt;&gt; 3; h ^= h &lt;&lt; 10;</span><br><span class="line">               if (h == 0)</span><br><span class="line">                   h = SPINS | (int)t.getId();</span><br><span class="line">               else if (h &lt; 0 &amp;&amp; (--spins &amp; ((SPINS &gt;&gt;&gt; 1) - 1)) == 0)</span><br><span class="line">                   Thread.yield();</span><br><span class="line">           &#125;</span><br><span class="line">           else if (slot != p)    //配对线程已经到达,但尚未做好准备,仍需要自旋一会</span><br><span class="line">               spins = SPINS;</span><br><span class="line">           else if (!t.isInterrupted() &amp;&amp; arena == null &amp;&amp;</span><br><span class="line">                    (!timed || (ns = end - System.nanoTime()) &gt; 0L)) &#123;    //如果自旋了很久,还是等不到匹配,则阻塞当前线程(优化)</span><br><span class="line">               U.putObject(t, BLOCKER, this);</span><br><span class="line">               p.parked = t;</span><br><span class="line">               if (slot == p)</span><br><span class="line">                   U.park(false, ns);    //阻塞当前线程</span><br><span class="line">               p.parked = null;</span><br><span class="line">               U.putObject(t, BLOCKER, null);</span><br><span class="line">           &#125;</span><br><span class="line">           else if (U.compareAndSwapObject(this, SLOT, p, null)) &#123;</span><br><span class="line">               v = timed &amp;&amp; ns &lt;= 0L &amp;&amp; !t.isInterrupted() ? TIMED_OUT : null; //超时或者其他(中断,取消),给其他线程腾出slot</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       U.putOrderedObject(p, MATCH, null);</span><br><span class="line">       p.item = null;</span><br><span class="line">       p.hash = h;</span><br><span class="line">       return v;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="arena多槽机制"><a href="#arena多槽机制" class="headerlink" title="arena多槽机制"></a>arena多槽机制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 多槽交换</span><br><span class="line"> *</span><br><span class="line"> * @param item 待交换的数据</span><br><span class="line"> * @return 其它配对线程的数据; 如果被中断返回null, 如果超时返回TIMED_OUT(一个Obejct对象)</span><br><span class="line"> */</span><br><span class="line">private final Object arenaExchange(Object item, boolean timed, long ns) &#123;</span><br><span class="line">    Node[] a = arena;</span><br><span class="line">    Node p = participant.get();                     // 当前线程携带的交换结点</span><br><span class="line">    for (int i = p.index; ; ) &#123;                     // 当前线程的arena索引</span><br><span class="line">        int b, m, c;</span><br><span class="line">        long j;</span><br><span class="line"></span><br><span class="line">        // 从arena数组中选出偏移地址为(i &lt;&lt; ASHIFT) + ABASE的元素, 即真正可用的Node</span><br><span class="line">        Node q = (Node) U.getObjectVolatile(a, j = (i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line"></span><br><span class="line">        if (q != null &amp;&amp; U.compareAndSwapObject(a, j, q, null)) &#123;   // CASE1: 槽不为空，说明已经有线程到达并在等待了</span><br><span class="line">            Object v = q.item;                     // 获取已经到达的线程所携带的值</span><br><span class="line">            q.match = item;                        // 把当前线程携带的值交换给已经到达的线程</span><br><span class="line">            Thread w = q.parked;                   // q.parked指向已经到达的线程</span><br><span class="line">            if (w != null)</span><br><span class="line">                U.unpark(w);                       // 唤醒已经到达的线程</span><br><span class="line">            return v;</span><br><span class="line">        &#125; else if (i &lt;= (m = (b = bound) &amp; MMASK) &amp;&amp; q == null) &#123;       // CASE2: 有效槽位位置且槽位为空</span><br><span class="line">            p.item = item;</span><br><span class="line">            if (U.compareAndSwapObject(a, j, null, p)) &#123;            // 占用该槽位, 成功</span><br><span class="line">                long end = (timed &amp;&amp; m == 0) ? System.nanoTime() + ns : 0L;</span><br><span class="line">                Thread t = Thread.currentThread();</span><br><span class="line">                for (int h = p.hash, spins = SPINS; ; ) &#123;               // 自旋等待一段时间,看看有没其它配对线程到达该槽位</span><br><span class="line">                    Object v = p.match;</span><br><span class="line">                    if (v != null) &#123;                                    // 有配对线程到达了该槽位</span><br><span class="line">                        U.putOrderedObject(p, MATCH, null);</span><br><span class="line">                        p.item = null;</span><br><span class="line">                        p.hash = h;</span><br><span class="line">                        return v;   // 返回配对线程交换过来的值</span><br><span class="line">                    &#125; else if (spins &gt; 0) &#123;</span><br><span class="line">                        h ^= h &lt;&lt; 1;</span><br><span class="line">                        h ^= h &gt;&gt;&gt; 3;</span><br><span class="line">                        h ^= h &lt;&lt; 10;</span><br><span class="line">                        if (h == 0)                // initialize hash</span><br><span class="line">                            h = SPINS | (int) t.getId();</span><br><span class="line">                        else if (h &lt; 0 &amp;&amp;          // approx 50% true</span><br><span class="line">                                (--spins &amp; ((SPINS &gt;&gt;&gt; 1) - 1)) == 0)</span><br><span class="line">                            Thread.yield();        // 每一次等待有两次让出CPU的时机</span><br><span class="line">                    &#125; else if (U.getObjectVolatile(a, j) != p)       // 优化操作:配对线程已经到达, 但是还未完全准备好, 所以需要再自旋等待一会儿</span><br><span class="line">                        spins = SPINS;</span><br><span class="line">                    else if (!t.isInterrupted() &amp;&amp; m == 0 &amp;&amp;</span><br><span class="line">                            (!timed || (ns = end - System.nanoTime()) &gt; 0L)) &#123;      // 等不到配对线程了, 阻塞当前线程</span><br><span class="line">                        U.putObject(t, BLOCKER, this);</span><br><span class="line">                        p.parked = t;                           // 在结点引用当前线程，以便配对线程到达后唤醒我</span><br><span class="line">                        if (U.getObjectVolatile(a, j) == p)</span><br><span class="line">                            U.park(false, ns);</span><br><span class="line">                        p.parked = null;</span><br><span class="line">                        U.putObject(t, BLOCKER, null);</span><br><span class="line">                    &#125; else if (U.getObjectVolatile(a, j) == p &amp;&amp;</span><br><span class="line">                            U.compareAndSwapObject(a, j, p, null)) &#123;    // 尝试缩减arena槽数组的大小</span><br><span class="line">                        if (m != 0)                // try to shrink</span><br><span class="line">                            U.compareAndSwapInt(this, BOUND, b, b + SEQ - 1);</span><br><span class="line">                        p.item = null;</span><br><span class="line">                        p.hash = h;</span><br><span class="line">                        i = p.index &gt;&gt;&gt;= 1;        // descend</span><br><span class="line">                        if (Thread.interrupted())</span><br><span class="line">                            return null;</span><br><span class="line">                        if (timed &amp;&amp; m == 0 &amp;&amp; ns &lt;= 0L)</span><br><span class="line">                            return TIMED_OUT;</span><br><span class="line">                        break;                     // expired; restart</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else                                 // 占用槽位失败</span><br><span class="line">                p.item = null;</span><br><span class="line">        &#125; else &#123;                                   // CASE3: 无效槽位位置, 需要扩容</span><br><span class="line">            if (p.bound != b) &#123;</span><br><span class="line">                p.bound = b;</span><br><span class="line">                p.collides = 0;</span><br><span class="line">                i = (i != m || m == 0) ? m : m - 1;</span><br><span class="line">            &#125; else if ((c = p.collides) &lt; m || m == FULL ||</span><br><span class="line">                    !U.compareAndSwapInt(this, BOUND, b, b + SEQ + 1)) &#123;</span><br><span class="line">                p.collides = c + 1;</span><br><span class="line">                i = (i == 0) ? m : i - 1;          // cyclically traverse</span><br><span class="line">            &#125; else</span><br><span class="line">                i = m + 1;                         // grow</span><br><span class="line">            p.index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="exchange方法"><a href="#exchange方法" class="headerlink" title="exchange方法"></a><strong>exchange方法</strong></h5><p>如果slotExchange有结果,则不执行arenaExchange,</p><p>如果slot被占用,则进入arenaExchange</p><p>该方法的返回值就是对方线程的数据,会存到本A线程item中,此时B线程的match存储A线程的item数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public V exchange(V x) throws InterruptedException &#123;</span><br><span class="line">       Object v;</span><br><span class="line">       Object item = (x == null) ? NULL_ITEM : x; // translate null args</span><br><span class="line"></span><br><span class="line">       //arena(多槽数组)不为null,但返回null,说明线程中断了</span><br><span class="line">       //如果slotExchange(单槽数组)不为null时,说明slot有效,返回false,反之进入if</span><br><span class="line">       if ((arena != null ||(v = slotExchange(item, false, 0L)) == null) &amp;&amp;</span><br><span class="line">       //如果线程中断或者返回null,则进入if</span><br><span class="line">           ((Thread.interrupted() || (v = arenaExchange(item, false, 0L)) == null)))</span><br><span class="line">           throw new InterruptedException();</span><br><span class="line">       return (v == NULL_ITEM) ? null : (V)v;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>上部代码判断流程图</strong></p><p><img src="https://i.imgur.com/qIzO8PX.png" alt=""></p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoExchanger</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/16 14:43</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoExchanger &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Exchanger&lt;Object&gt; exchanger = new Exchanger&lt;&gt;();</span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String name=&quot;线程1:&quot;;</span><br><span class="line"></span><br><span class="line">                Object exchange = exchanger.exchange(&quot;线程1的内容&quot;);</span><br><span class="line">                System.out.println(name+exchange); //线程1:线程2的内容</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ).start();</span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String name=&quot;线程2:&quot;;</span><br><span class="line"></span><br><span class="line">                Object exchange = exchanger.exchange(&quot;线程2的内容&quot;);</span><br><span class="line">                System.out.println(name+exchange); //线程2:线程1的内容</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优秀传送门"><a href="#优秀传送门" class="headerlink" title="优秀传送门"></a>优秀传送门</h3><p><a href="https://www.cnblogs.com/chenpi/p/5614290.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenpi/p/5614290.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Concurrent并发包入门-三-之Synchronizers&quot;&gt;&lt;a href=&quot;#Concurrent并发包入门-三-之Synchronizers&quot; class=&quot;headerlink&quot; title=&quot;Concurrent并发包入门(三)之Synchroni
      
    
    </summary>
    
      <category term="JAVA并发编程" scheme="http://yoursite.com/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Concurrent并发包入门(二)之BlockingQueue</title>
    <link href="http://yoursite.com/2018/10/15/Concurrent%E5%B9%B6%E5%8F%91%E5%8C%85%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2018/10/15/Concurrent并发包入门(二)/</id>
    <published>2018-10-14T16:00:00.000Z</published>
    <updated>2018-10-23T12:34:24.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concurrent并发包入门-二-之BlockingQueue"><a href="#Concurrent并发包入门-二-之BlockingQueue" class="headerlink" title="Concurrent并发包入门(二)之BlockingQueue"></a>Concurrent并发包入门(二)之BlockingQueue</h2><p>[TOC]</p><h3 id="1-BlockingQueue-阻塞队列"><a href="#1-BlockingQueue-阻塞队列" class="headerlink" title="1.BlockingQueue 阻塞队列"></a>1.BlockingQueue 阻塞队列</h3><ol><li>数组阻塞队列 ArrayBlockingQueue</li><li>延迟队列 DelayQueue</li><li>链阻塞队列 LinkedBlockingQueue</li><li>具有优先级的阻塞队列 PriorityBlockingQueue</li><li>同步队列 SynchronousQueue</li><li>阻塞双端队列 BlockingDeque</li><li>链阻塞双端队列 LinkedBlockingDeque</li></ol><h3 id="2-并发包使用"><a href="#2-并发包使用" class="headerlink" title="2.并发包使用"></a>2.并发包使用</h3><p><strong>BlockingQueue(接口) 阻塞队列</strong></p><p><img src="https://i.imgur.com/Yae19B4.jpg" alt=""></p><h4 id="场景"><a href="#场景" class="headerlink" title="场景:"></a><strong>场景</strong>:</h4><p>BlockingQueue通常用于一个线程生产对象,另一个线程消费对象(生产者与消费者模式)</p><p>处理数据比较消耗时间，线程独占，生产数据不需要即时的反馈等</p><p>一个线程负责生产对象,将新生产的对象插入队列中,队列是有限的,到达队列临界点后,新生产的对象会处于阻塞状态中,直到队列有对象被消耗</p><p>一个线程负责消费对象,将队列中的对象按照顺序消费,直到队列中没有对象,则消费者处于阻塞状态,直到队列中被插入新的对象</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h4><table><thead><tr><th>~</th><th>抛异常</th><th>特定值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>put(o)</td><td>offer(o,timeout,timeUnit)</td></tr><tr><td>移除</td><td>remove(o)指定</td><td>poll(o)头部</td><td>take(o)头部</td><td>poll(timeout,timeunit)</td></tr><tr><td>检查</td><td>element(o)</td><td>peek(o)</td><td>~</td><td>~</td></tr></tbody></table><p><strong>抛异常:</strong>如果试图的操作无法立即执行,则该方法抛出一个异常</p><p><strong>特定值:</strong>如果试图的操作无法立即执行,则该方法返回一个特定值(一般true/false)</p><p><strong>阻塞:</strong>如果试图的操作无法立即执行,则该方法产生阻塞,直到能执行</p><p><strong>超时:</strong>如果试图的操作无法立即执行,则该方法产生阻塞,直到能成功或者超时,返回一个特定值来判断是否成功</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a><strong>注意:</strong></h4><p>无法向BolckingQueue中插入null,否则将抛出NullPointerException</p><p>可以访问BlockingQueue中所有的元素,不仅仅是开始和结束,如remove(o)移除指定元素(效率很低,不建议做该操作)</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h4><p><img src="https://i.imgur.com/Igabn7T.jpg" alt=""></p><p>BlockingQueue是个接口,可以使用它的实现来使用,concurrent包中有如下几个实现类:</p><h4 id="2-1-ArrayBlockingQueue"><a href="#2-1-ArrayBlockingQueue" class="headerlink" title="2-1.ArrayBlockingQueue"></a><strong>2-1.ArrayBlockingQueue</strong></h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassMame</span>: DemoArrayBlockingQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 宝全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/10/11 10:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArrayBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BlockingQueue queue=<span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ArrayBlockingQueueProvide(queue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ArrayBlockingQueueConsumer(queue)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueProvide</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue queue=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueueProvide</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">"1逻辑"</span>);</span><br><span class="line">            queue.put(<span class="string">"2逻辑"</span>);</span><br><span class="line">            queue.put(<span class="string">"3逻辑"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue queue=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueueConsumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1逻辑</span></span><br><span class="line"><span class="comment">        2逻辑</span></span><br><span class="line"><span class="comment">        3逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayBlockingQueue部分源码属性"><a href="#ArrayBlockingQueue部分源码属性" class="headerlink" title="ArrayBlockingQueue部分源码属性"></a><strong>ArrayBlockingQueue部分源码属性</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final Object[] items;    //队列数组</span><br><span class="line">int takeIndex;    //拿出下标</span><br><span class="line">int putIndex;    //插入下标</span><br><span class="line">int count;    //元素统计</span><br><span class="line">final ReentrantLock lock;    //重入锁 ,注意:插入和取出用的是同一把锁,因此同一时刻不会一起执行</span><br><span class="line">private final Condition notEmpty; //消费者takes操作(如await开头阻塞,signal开头唤醒)</span><br><span class="line">private final Condition notFull; //提供者puts操作(如await开头阻塞,signal开头唤醒)</span><br></pre></td></tr></table></figure><h5 id="阻塞插入"><a href="#阻塞插入" class="headerlink" title="阻塞插入"></a><strong>阻塞插入</strong></h5><p><strong>put</strong>方法源码(如果立即添加不成功,进入阻塞) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);    //判断非空</span><br><span class="line">    final ReentrantLock lock = this.lock; //重入锁,保证代码块安全</span><br><span class="line">    lock.lockInterruptibly();    //加锁,中断或超时等抛异常</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length) //队列满时</span><br><span class="line">            notFull.await();    //进入阻塞</span><br><span class="line">        enqueue(e);    //加入队列</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();  //释放锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enqueue(e)</strong>源码(加入队列)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    final Object[] items = this.items; //取得队列(本质是Obj数组)</span><br><span class="line">    items[putIndex] = x;    //putIndex为添加元素下标</span><br><span class="line">    if (++putIndex == items.length) //如果数组容量装满时进入判断</span><br><span class="line">        putIndex = 0; //下标重新从0开始,因为队列的容量在声明时已经固定,通过下标清0的方法不断循环</span><br><span class="line">    count++;    //未消费消息数+1;</span><br><span class="line">    notEmpty.signal();    //唤醒等待消费元素的线程,上菜了!( • ̀ω•́ )✧</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="阻塞取出"><a href="#阻塞取出" class="headerlink" title="阻塞取出"></a><strong>阻塞取出</strong></h5><p><strong>take</strong>方法源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0)    //当队列中没有元素时,进入阻塞</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return dequeue();    //返回移除元素信息</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dequeue</strong>方法源码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private E dequeue() &#123;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    E x = (E) items[takeIndex];    //获取当前元素</span><br><span class="line">    items[takeIndex] = null;</span><br><span class="line">    if (++takeIndex == items.length)</span><br><span class="line">        takeIndex = 0;</span><br><span class="line">    count--;  ////未消费消息数-1;</span><br><span class="line">    if (itrs != null) //itrs为迭代器,通过迭代器操作来移除队列的头元素</span><br><span class="line">        itrs.elementDequeued(); </span><br><span class="line">    notFull.signal(); //唤醒等待非满条件的线程进入,吃完了!( • ̀ω•́ )✧</span><br><span class="line">    return x; //返回移除的元素信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非阻塞插入"><a href="#非阻塞插入" class="headerlink" title="非阻塞插入"></a><strong>非阻塞插入</strong></h5><p><strong>add</strong>方法源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        if (offer(e))    //直接调用offer(e)方法,立即返回状态,成功则返回成功,失败则抛出异常</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>offer</strong>方法源码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);   </span><br><span class="line">    final ReentrantLock lock = this.lock; </span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count == items.length) //数组满了直接返回false,否则返回true</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非阻塞取出"><a href="#非阻塞取出" class="headerlink" title="非阻塞取出"></a><strong>非阻塞取出</strong></h5><p><strong>poll</strong>方法源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count == 0) ? null : dequeue();    //如果没有,返回空,如果有,返回元素信息</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不超时阻塞插入"><a href="#不超时阻塞插入" class="headerlink" title="不超时阻塞插入"></a><strong>不超时阻塞插入</strong></h5><p><strong>offer(o,timeout,timeutil)</strong>源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    long nanos = unit.toNanos(timeout);    //获取超时时间</span><br><span class="line">    final ReentrantLock lock = this.lock;    //上锁</span><br><span class="line">    lock.lockInterruptibly();    //中断或超时抛出异常</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length) &#123; //如果队列满了</span><br><span class="line">            if (nanos &lt;= 0) //如果超时时间到了,返回false</span><br><span class="line">                return false;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos); //如果超时时间没到,进入限时阻塞</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);   </span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();    //释放重入锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不超时阻塞取出"><a href="#不超时阻塞取出" class="headerlink" title="不超时阻塞取出"></a><strong>不超时阻塞取出</strong></h5><p><strong>poll(o,timeout,timeUnit)</strong>方法源码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0) &#123;    //如果没有元素,则进入判断</span><br><span class="line">            if (nanos &lt;= 0)</span><br><span class="line">                return null;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        return dequeue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                          //同不超时阻塞插入原理</span><br></pre></td></tr></table></figure><p>走一波瞎**想的场景,伪工具类吧= = .</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">package com.dony15.blockingQueue;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoArrayBlockingQueue</span><br><span class="line"> * @Description: 边学边用,于是,就有了这么一个废物工具,多线程异步使我们不需要过多考虑性能,分类写到不同的地方,中断异常提醒</span><br><span class="line"> *                  BlockingQueue中ArrayBlockingQueue并非性能最高的方案,后续更新</span><br><span class="line">            ArrayBlockingQueue缺点:读写只能同时发生一个(底层靠同一把重入锁和两个方法来保证数据安全)</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/11 10:16</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoArrayBlockingQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DonY15.writeLog(&quot;1&quot;, &quot;2&quot;, 123, true, &apos;c&apos;, &quot;谢大脚&quot;, 12.554);</span><br><span class="line">        DonY15.outFile(&quot;本地E盘&quot;, &quot;邮箱:666@qq.com&quot;, &quot;地址:127.0.0.1:6666&quot;, &quot;手机号:110&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 工具类:可批量加入XXX信息</span><br><span class="line"> *</span><br><span class="line"> * 效果:</span><br><span class="line"> * 1.适合信息比较大,数量较多容易产生阻塞(多线程缓解)</span><br><span class="line"> * 2.该信息可以确保顺序(CLH列队实现,这个可以有)</span><br><span class="line"> * 3.该信息不要求即时同步</span><br><span class="line"> * 4.该信息属于共享信息,不需要绑定用户(目测绑定也不好实现,ArrayBlockingQueue两个线程比较合适,测试如果多个线程读写可能会丢数据= = .反正有一些发出去了,收不到,而且那样做,顺序性的特点也会丢失)</span><br><span class="line"> * 5.该信息需要写到不同的地方(本地/邮箱/XX服务器/XX短信)(伪代码概括)</span><br><span class="line"> * 6.可以归类,用途:将不同类型信息发送到不同的数据库位置存储,提高阅读效率??吧(这些功能也不是BlockQueue的特性= = .)</span><br><span class="line"> */</span><br><span class="line">class DonY15 &#123;</span><br><span class="line">    //使用数组阻塞队列</span><br><span class="line">    private static BlockingQueue queue = new ArrayBlockingQueue(1024);</span><br><span class="line"></span><br><span class="line">    //加工接收消息</span><br><span class="line">    public static void writeLog(Object... arg) &#123;</span><br><span class="line">        new Thread(new ArrayBlockingQueueProvide(queue, arg)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //消费消息到指定位置</span><br><span class="line">    public static void outFile(String localPath, String emailPath, String serverAddress, String phone) &#123;</span><br><span class="line">        new Thread(new ArrayBlockingQueueConsumer(queue, localPath, emailPath, serverAddress, phone)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 提供者</span><br><span class="line"> */</span><br><span class="line">class ArrayBlockingQueueProvide implements Runnable &#123;</span><br><span class="line">    private BlockingQueue queue = null;</span><br><span class="line">    private LinkedList arg = new LinkedList();</span><br><span class="line"></span><br><span class="line">    public ArrayBlockingQueueProvide(BlockingQueue queue, Object... args) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        if (args != null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">            for (Object arg : args) &#123;</span><br><span class="line">                this.arg.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            queue.put(arg);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 消费者</span><br><span class="line"> */</span><br><span class="line">class ArrayBlockingQueueConsumer implements Runnable &#123;</span><br><span class="line">    private BlockingQueue queue = null;</span><br><span class="line">    private String localPath;</span><br><span class="line">    private String emailPath;</span><br><span class="line">    private String serverAddress;</span><br><span class="line">    private String phone;</span><br><span class="line"></span><br><span class="line">    public ArrayBlockingQueueConsumer(BlockingQueue queue, String localPath, String emailPath, String serverAddress, String phone) &#123;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.localPath = localPath;</span><br><span class="line">        this.emailPath = emailPath;</span><br><span class="line">        this.serverAddress = serverAddress;</span><br><span class="line">        this.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                LinkedList takes = (LinkedList) queue.take();</span><br><span class="line">                System.out.println(&quot;------------------[根据信息分类功能]--------------------&quot;);</span><br><span class="line">                for (Object takeData : takes) &#123;</span><br><span class="line">                    if (takeData instanceof String) &#123;</span><br><span class="line">                        System.out.println(&quot;这是字符串信息:&quot; + takeData);</span><br><span class="line">                    &#125; else if (takeData instanceof Integer) &#123;</span><br><span class="line">                        System.out.println(&quot;这是整型信息:&quot; + takeData);</span><br><span class="line">                    &#125; else if (takeData instanceof Character) &#123;</span><br><span class="line">                        System.out.println(&quot;这是字符信息:&quot; + takeData);</span><br><span class="line">                    &#125; else if (takeData instanceof Boolean) &#123;</span><br><span class="line">                        System.out.println(&quot;这是布尔信息:&quot; + takeData);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;这TM是垃圾,不分了!--&gt;&quot; + takeData);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;------------------[根据需求分发功能]--------------------&quot;);</span><br><span class="line">                System.out.println(takes + &quot;这条信息是写往:&quot; + localPath);</span><br><span class="line">                System.out.println(takes + &quot;这条信息是写往:&quot; + emailPath);</span><br><span class="line">                System.out.println(takes + &quot;这条信息是写往:&quot; + serverAddress);</span><br><span class="line">                System.out.println(takes + &quot;这条信息是写往:&quot; + phone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-PriorityBlockingQueue"><a href="#2-2-PriorityBlockingQueue" class="headerlink" title="2-2.PriorityBlockingQueue"></a>2-2.PriorityBlockingQueue</h4><p>无界并发队列,使用了和 PriorityQueue 一样的排序规则,无法向队列中插入null值.</p><p><strong>比PriorityQueue额外增加阻塞效果</strong></p><p><strong>优先级队列:</strong>是一个基于<strong>堆</strong>的<strong>无界并发安全</strong>的优先级队列</p><p><strong>优先级队列比较规则:</strong>当前对象和其他对象做比较，当前<strong>优先级大就返回-1</strong>，<strong>优先级小就返回1</strong></p><p><strong>注意:</strong></p><ol><li>插入到PriorityBlockingQueue的元素必须实现Comparable接口或者构造中传入Comparator</li><li>PriorityBlockingQueue对于具有相同优先级的元素并不强制任何特定行为(不会按照先进先出原则)</li><li>从PriorityBlockingQueue中获取Iterator遍历元素,并不能保证按照优先级顺序</li></ol><p><strong>源码:</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_INITIAL_CAPACITY = 11; //默认容量</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //可分配最大队列容量,-8是VM实现数组头的内容</span><br><span class="line">private transient Object[] queue; //队列元素数组。平衡二叉堆实现，父节点下标是n，左节点则是2n+1，右节点是2n+2。最小的元素在最前面</span><br><span class="line">private transient int size; //当前队列中元素个数</span><br><span class="line">private transient Comparator&lt;? super E&gt; comparator; //决定队列中元素顺序的比较器</span><br><span class="line">private final ReentrantLock lock; //所有public方法的锁(重入锁)</span><br><span class="line">private final Condition notEmpty; //队列为空时阻塞</span><br><span class="line">private transient volatile int allocationSpinLock; //扩容数组分配资源时的自旋锁,CAS需要</span><br><span class="line">private PriorityQueue&lt;E&gt; q; //只用于序列化的时候,为了兼容之前的版本(只有在序列化和反序列化时不为null)</span><br></pre></td></tr></table></figure><p><strong>offer和add(直接返回offer)方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null) //不支持插入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    int n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    while ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    try &#123;</span><br><span class="line">        Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">        if (cmp == null)</span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        else</span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        size = n + 1;</span><br><span class="line">        notEmpty.signal();    //队列为空时阻塞</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><p>元素实现<strong>Comparable<t></t></strong>接口</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class City implements Comparable&lt;City&gt;&#123;</span><br><span class="line">    private int priority;</span><br><span class="line">    private String name;</span><br><span class="line">    private String desc;</span><br><span class="line">    //getter setter略</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(City o) &#123;</span><br><span class="line">//        return (this.priority&gt;o.priority)?1:(this.priority&lt;o.priority)?-1:0;</span><br><span class="line">        return Integer.compare(this.priority, o.priority);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;City&#123;&quot; +</span><br><span class="line">                &quot;priority=&quot; + priority +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, desc=&apos;&quot; + desc + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PriorityBlockingQueue示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoPriorityBlockingQueue</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/15 15:54</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoPriorityBlockingQueue &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        PriorityBlockingQueue&lt;Object&gt; queue = new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(new City(10,&quot;北京&quot;,&quot;北京好&quot;));</span><br><span class="line">        queue.put(new City(100,&quot;上海&quot;,&quot;上海好&quot;));</span><br><span class="line">        queue.offer(new City(101,&quot;南京&quot;,&quot;南京好&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(queue.take());</span><br><span class="line">        System.out.println(queue.take());</span><br><span class="line">        System.out.println(queue.take());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-DelayQueue"><a href="#2-3-DelayQueue" class="headerlink" title="2-3.DelayQueue"></a><strong>2-3.DelayQueue</strong></h4><p><img src="https://i.imgur.com/mY0upaA.png" alt=""></p><p>DelayQueue中内部使用的是<strong>PriorityQueue</strong>存放数据，使用ReentrantLock实现线程同步，阻塞队列。</p><p><strong>DelayQueue = BlockingQueue + PriorityQueue + Delayed</strong></p><p><strong>注意:</strong>队列里面的元素要实现<strong>Delayed</strong>接口,一个是获取<strong>当前剩余时间</strong>的接口，一个是<strong>元素时间比较</strong>的接口.</p><p><strong>优先级的队列:</strong>比较的基准为<strong>时间</strong></p><p><strong>框架:</strong>TimerThread底层使用(ScheduledThreadPoolExecutor)</p><p><strong>场景:</strong></p><p><strong>a)关闭空闲连接(如一些客户端连接,空闲过久后移除)</strong></p><p><strong>b)缓存(缓存中的对象,超过空闲时间,需要从缓存中移除)</strong></p><p><strong>c)任务超时处理(网络协议滑动窗口请求应答交互,超时处理)</strong></p><p><strong>DelayQueue源码解析</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final transient ReentrantLock lock = new ReentrantLock(); //可重入锁</span><br><span class="line">private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;(); //调用PriorityQueue,优先级队列</span><br><span class="line">private Thread leader = null;</span><br><span class="line">private final Condition available = lock.newCondition();  //阻塞线程</span><br></pre></td></tr></table></figure><p><strong>Delayed接口(源码)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Delayed extends Comparable&lt;Delayed&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the remaining delay associated with this object, in the</span><br><span class="line">     * given time unit.</span><br><span class="line">     * @param unit the time unit</span><br><span class="line">     * @return the remaining delay; zero or negative values indicate</span><br><span class="line">     * that the delay has already elapsed</span><br><span class="line">     */</span><br><span class="line">    long getDelay(TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>offer操作</strong></p><p>offer底层调用<strong>PriorityQueue</strong>优先级队列,所以peek不一定是当前添加的元素,如果peek(检测是否为当前头元素)为true,说明当前元素e的优先级最小,即将过期,激活available变量条件队列里的线程,通知队列中的所有元素</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">     final ReentrantLock lock = this.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     try &#123;</span><br><span class="line">         q.offer(e);</span><br><span class="line">         if (q.peek() == e) &#123;</span><br><span class="line">             leader = null;</span><br><span class="line">             available.signal();</span><br><span class="line">         &#125;</span><br><span class="line">         return true;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>put操作</strong></p><p><strong>put直接调用offer方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) &#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>take()方法</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            E first = q.peek(); //获取但不移除头元素</span><br><span class="line">            if (first == null) //如果没有头元素,则进行阻塞</span><br><span class="line">                available.await();</span><br><span class="line">            else &#123;</span><br><span class="line">                long delay = first.getDelay(NANOSECONDS); //获取头元素过期时间</span><br><span class="line">                if (delay &lt;= 0) //如果过期时间到了,则移除该元素,否则进入阻塞</span><br><span class="line">                    return q.poll();</span><br><span class="line">                first = null; // don&apos;t retain ref while waiting</span><br><span class="line">                if (leader != null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; q.peek() != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>poll方法</strong></p><p><strong>立即获取头元素,如果队列为空或者该元素未过期,则直接返回null</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">     final ReentrantLock lock = this.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     try &#123;</span><br><span class="line">         E first = q.peek();    //获取队列头部元素</span><br><span class="line">         if (first == null || first.getDelay(NANOSECONDS) &gt; 0) //精确到纳秒</span><br><span class="line">             return null;</span><br><span class="line">         else</span><br><span class="line">             return q.poll();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>超时时间内,获取队列头元素信息,否则返回null</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            if (first == null) &#123;</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return null;</span><br><span class="line">                else</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                long delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                if (delay &lt;= 0)</span><br><span class="line">                    return q.poll();</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return null;</span><br><span class="line">                first = null; // don&apos;t retain ref while waiting</span><br><span class="line">                if (nanos &lt; delay || leader != null)</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                else &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        long timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (leader == thisThread)</span><br><span class="line">                            leader = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (leader == null &amp;&amp; q.peek() != null)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><p>需要实现Delayed接口,实现获取<strong>剩余时间</strong>和<strong>比较时间</strong>方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DelayeDto implements Delayed &#123;</span><br><span class="line"></span><br><span class="line">    private final long delayTime; //延迟时间</span><br><span class="line"></span><br><span class="line">    private final long expire;  //过期时间</span><br><span class="line"></span><br><span class="line">    private String data;    //数据</span><br><span class="line"></span><br><span class="line">    public DelayeDto(String data,long delayTime) &#123;</span><br><span class="line">        this.delayTime = delayTime;</span><br><span class="line">        expire = System.currentTimeMillis()+delayTime;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 剩余时间</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">        return unit.convert(this.expire-System.currentTimeMillis(),unit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 比较优先级</span><br><span class="line">     * @param o</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Delayed o) &#123;</span><br><span class="line">        return (int) (this.getDelay(TimeUnit.MILLISECONDS)-o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;DelayeDto&#123;&quot; +</span><br><span class="line">                &quot;delayTime=&quot; + delayTime +</span><br><span class="line">                &quot;, expire=&quot; + expire +</span><br><span class="line">                &quot;, data=&apos;&quot; + data + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><p>根据设置的过期时间顺序来获取元素,不一定是直接获取列表第一个元素,当时间相同时,根据加入顺序来获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoDelayQueue</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/15 13:37</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line">public class DemoDelayQueue &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">        BlockingQueue queue = new DelayQueue();</span><br><span class="line">                               </span><br><span class="line">        DelayeDto delayeDto1 = new DelayeDto(&quot;123&quot;, 200);</span><br><span class="line">        DelayeDto delayeDto2 = new DelayeDto(&quot;456&quot;, 1000);</span><br><span class="line">                               </span><br><span class="line">        queue.offer(delayeDto1);</span><br><span class="line">        queue.offer(delayeDto2);</span><br><span class="line">                               </span><br><span class="line">        System.out.println(queue.take());</span><br><span class="line">        System.out.println(queue.take());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelayQueue缓存实现传送门</p><p><a href="https://www.cnblogs.com/jobs/archive/2007/04/27/730255.html" target="_blank" rel="noopener">https://www.cnblogs.com/jobs/archive/2007/04/27/730255.html</a> </p><h4 id="2-4-LinkedBlockingQueue"><a href="#2-4-LinkedBlockingQueue" class="headerlink" title="2-4.LinkedBlockingQueue"></a>2-4.LinkedBlockingQueue</h4><p><strong>链阻塞同步队列(FIFO)</strong></p><p>数据结构为<strong>链表</strong></p><p>可以指定节点上限,默认Integer.MAX_VALUE</p><p>与ArrayBlockingQueue使用方法相同</p><p><strong>使用场景:</strong></p><p><strong>Executors线程池:newFixedThreadPool/newSingleThreadExecutor</strong></p><p><strong>tomcat:TaskQueue(继承了LinkedBlockingQueue并且泛化类型固定了为Runnalbe.重写了offer,poll，take方法。)</strong></p><p><strong>Tomcat源码分析</strong></p><p><strong><a href="https://blog.csdn.net/u011109589/article/details/80518931" target="_blank" rel="noopener">https://blog.csdn.net/u011109589/article/details/80518931</a></strong> </p><p><strong>源码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;E&gt;  //节点</span><br><span class="line">private final int capacity; //队列最大容量,默认Integer.MAX_VALUE</span><br><span class="line">private final AtomicInteger count = new AtomicInteger(); //队列内元素个数</span><br><span class="line">transient Node&lt;E&gt; head; //头结点</span><br><span class="line">private transient Node&lt;E&gt; last;//尾节点</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();   //取出锁(互斥锁)</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();    //插入锁 </span><br><span class="line">private final Condition notEmpty = takeLock.newCondition(); //非空条件</span><br><span class="line">private final Condition notFull = putLock.newCondition();    //未满条件</span><br></pre></td></tr></table></figure><p><strong>offer方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        if (e == null) throw new NullPointerException();</span><br><span class="line">        final AtomicInteger count = this.count;    //统计元素个数</span><br><span class="line">        if (count.get() == capacity)//如果队列满了,返回false</span><br><span class="line">            return false;</span><br><span class="line">        int c = -1;</span><br><span class="line">        Node&lt;E&gt; node = new Node&lt;E&gt;(e);</span><br><span class="line">        final ReentrantLock putLock = this.putLock; //插入锁</span><br><span class="line">        putLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (count.get() &lt; capacity) &#123; //队列未满,允许插入</span><br><span class="line">                enqueue(node);</span><br><span class="line">                c = count.getAndIncrement();</span><br><span class="line">                if (c + 1 &lt; capacity) </span><br><span class="line">                    notFull.signal(); //激活插入条件</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        if (c == 0)</span><br><span class="line">            signalNotEmpty(); //激活等待条件</span><br><span class="line">        return c &gt;= 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>take方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        E x;</span><br><span class="line">        int c = -1;</span><br><span class="line">        final AtomicInteger count = this.count;    //统计元素个数</span><br><span class="line">        final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count.get() == 0) &#123; //队列空,则等待</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();    //移除头结点</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            if (c &gt; 1)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        if (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>remove方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">      if (o == null) return false;</span><br><span class="line">      fullyLock();    //移除操作时,插入和其他移除(take)操作将被阻塞,双重锁</span><br><span class="line">      try &#123;</span><br><span class="line">          for (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">               p != null;</span><br><span class="line">               trail = p, p = p.next) &#123;</span><br><span class="line">              if (o.equals(p.item)) &#123;</span><br><span class="line">                  unlink(p, trail);</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          fullyUnlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h5 id="并发队列对比之一：ConcurrentLinkedQueue、LinkedBlockingQueue对比分析"><a href="#并发队列对比之一：ConcurrentLinkedQueue、LinkedBlockingQueue对比分析" class="headerlink" title="并发队列对比之一：ConcurrentLinkedQueue、LinkedBlockingQueue对比分析"></a>并发队列对比之一：ConcurrentLinkedQueue、LinkedBlockingQueue对比分析</h5><p><a href="https://www.cnblogs.com/duanxz/archive/2012/10/12/2721290.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz/archive/2012/10/12/2721290.html</a> </p><h4 id="2-5-SynchronousQueue"><a href="#2-5-SynchronousQueue" class="headerlink" title="2-5. SynchronousQueue"></a>2-5. SynchronousQueue</h4><p>特殊的同步阻塞队列,他内部没有容器,队列中<strong>只有一个元素</strong></p><p>如果队列中有1个元素,则插入线程进入阻塞</p><p>如果队列中没有元素,则移除线程进入阻塞<br><img src="https://i.imgur.com/LWtgHSZ.png" alt=""></p><p>底层与ArrayBlockingQueue/LinkedBlockingQueue(依赖AQS实现线程安全)不同,</p><p>而是直接由大量CAS代码(Unsafe)保障其安全</p><p><strong>匹配通信机制</strong></p><p><strong>特点</strong></p><ol><li><p>不能在同步队列上进行 peek，因为仅在试图要取得元素时，该元素才存在； </p></li><li><p>它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。 </p></li><li><p>对于正在等待的生产者和使用者线程而言，此类支持可选的公平排序策略。默认情况下不保证这种排序。 但是，使用公平设置为 true 所构造的队列可保证线程以 FIFO 的顺序进行访问。 公平通常会降低吞吐量，但是可以减小可变性并避免得不到服务。</p></li></ol><p><strong>场景:</strong></p><p>​     <strong>线程池中运用较多</strong></p><p><strong>公平模式FIFO</strong></p><p>TransferQueue</p><p><strong>非公平模式FILO</strong></p><p><strong>TransferStack</strong></p><p><strong>源码详解</strong></p><p><a href="https://blog.csdn.net/chenssy/article/details/77371992" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/77371992</a> </p><h4 id="2-6-BlockingDeque"><a href="#2-6-BlockingDeque" class="headerlink" title="2-6. BlockingDeque"></a>2-6. BlockingDeque</h4><p><strong>阻塞双端队列</strong></p><p>BlockingDeque接口实现BlockingQueue接口</p><p>在线程中,既可以是生产者,又可以是消费者</p><p><strong>deque</strong>全称”Double Ended Queue”,可以从双端队列的任一端点执行插入或移除</p><ol><li><p>在不能插入元素时,将<strong>阻塞试图插入</strong>元素的线程,</p></li><li><p>在不能移除元素时,将<strong>阻塞试图移除</strong>元素的线程</p></li></ol><p><strong>更加灵活,可以实现FIFO或者FILO</strong></p><table><thead><tr><th>~</th><th>抛异常</th><th>特定值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>addFirst(o)</td><td>offerFirst(o)</td><td>putFirst(o)</td><td>offerFirst(o,timeout,timeUnit)</td></tr><tr><td>移除</td><td>removeFirst(o)</td><td>pollFirst(o)</td><td>takeFirst(o)</td><td>pollFirst(timeout,timeunit)</td></tr><tr><td>检查</td><td>getFirst(o)</td><td>peekFirst(o)</td><td>~</td><td>~</td></tr></tbody></table><table><thead><tr><th>~</th><th>抛异常</th><th>特定值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>addLast(o)</td><td>offerLast(o)</td><td>putLast(o)</td><td>offerLast(o,timeout,timeUnit)</td></tr><tr><td>移除</td><td>removeLast(o)</td><td>pollLast(o)</td><td>takeLast(o)</td><td>pollLast(timeout,timeunit)</td></tr><tr><td>检查</td><td>getLast(o)</td><td>peekLast(o)</td><td>~</td><td>~</td></tr></tbody></table><p>方法与BlockingQueue类似</p><p>双端队列可以使用BlockingQueue的方法,当然这些方法会遵循BlockingQueue的规则,FIFO</p><h4 id="2-7-链阻塞双端队列-LinkedBlockingDeque"><a href="#2-7-链阻塞双端队列-LinkedBlockingDeque" class="headerlink" title="2-7.链阻塞双端队列 LinkedBlockingDeque"></a>2-7.链阻塞双端队列 LinkedBlockingDeque</h4><p>LinkedBlockingDeque是BlockingDeque的唯一实现</p><p>可以指定队列容量,如果不指定,则默认Integer.MAX_VALUE</p><p><strong>源码:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static final class Node&lt;E&gt; //元素节点</span><br><span class="line">transient Node&lt;E&gt; first; //头元素</span><br><span class="line">transient Node&lt;E&gt; last; //尾元素</span><br><span class="line">private transient int count; //队列中元素统计</span><br><span class="line">private final int capacity; //队列最大容量,可指定,默认Integer.MAX_VALUE</span><br><span class="line">final ReentrantLock lock = new ReentrantLock(); //重入锁(互斥锁)</span><br><span class="line">private final Condition notEmpty = lock.newCondition();  //非空条件</span><br><span class="line">private final Condition notFull = lock.newCondition(); //未满条件</span><br></pre></td></tr></table></figure><p><strong>源码基础连接</strong></p><p><a href="https://www.cnblogs.com/skywang12345/p/3503480.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3503480.html</a> </p><p><strong>FIFO式使用</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoLinkedBlockingDequ</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/15 18:09</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class DemoLinkedBlockingDequ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        LinkedBlockingDeque&lt;Object&gt; deque = new LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">        //插入</span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                deque.putFirst(&quot;123&quot;);</span><br><span class="line">                deque.putFirst(&quot;567&quot;);</span><br><span class="line">                deque.putFirst(&quot;789&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        //取出</span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(deque.takeLast()); //123</span><br><span class="line">                System.out.println(deque.takeLast()); //567</span><br><span class="line">                System.out.println(deque.takeLast()); //789</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FILO式使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassMame: DemoLinkedBlockingDequ</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author 宝全</span><br><span class="line"> * @Date 2018/10/15 18:09</span><br><span class="line"> * @Version 1.0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class DemoLinkedBlockingDequ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        LinkedBlockingDeque&lt;Object&gt; deque = new LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">        //插入</span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                deque.putFirst(&quot;123&quot;);</span><br><span class="line">                deque.putFirst(&quot;567&quot;);</span><br><span class="line">                deque.putFirst(&quot;789&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        //取出</span><br><span class="line">        new Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(deque.takeFirst()); //789</span><br><span class="line">                System.out.println(deque.takeFirst()); //567</span><br><span class="line">                System.out.println(deque.takeFirst()); //123</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-JUC锁-互斥锁"><a href="#3-JUC锁-互斥锁" class="headerlink" title="3.JUC锁(互斥锁)"></a>3.JUC锁(互斥锁)</h3><p><a href="http://www.cnblogs.com/skywang12345/p/3496101.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3496101.html</a> </p><p><a href="https://juejin.im/post/5a093ff551882531bb6c4ee3" target="_blank" rel="noopener">https://juejin.im/post/5a093ff551882531bb6c4ee3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Concurrent并发包入门-二-之BlockingQueue&quot;&gt;&lt;a href=&quot;#Concurrent并发包入门-二-之BlockingQueue&quot; class=&quot;headerlink&quot; title=&quot;Concurrent并发包入门(二)之BlockingQ
      
    
    </summary>
    
      <category term="JAVA并发编程" scheme="http://yoursite.com/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Concurrent并发包入门(一)</title>
    <link href="http://yoursite.com/2018/10/10/Concurrent%E5%B9%B6%E5%8F%91%E5%8C%85%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/10/10/Concurrent并发包入门(一)/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2018-10-10T14:30:53.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="concurrent并发包入门-一"><a href="#concurrent并发包入门-一" class="headerlink" title="concurrent并发包入门(一)"></a>concurrent并发包入门(一)</h2><p><strong>java.util.concurrent</strong> 简称(<strong>JUC</strong>) 作者<strong>:Doug Lea</strong></p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p><strong>JUC</strong>包含许多<strong>线程安全</strong>/<strong>测试良好</strong>/<strong>高性能</strong>的<strong>并发构建块</strong></p><p><strong>Concurrent</strong>可以实现Collection框架对数据结构所执行的兵法操作</p><p>通过并发模块,可以提高并发类的<strong>线程安全</strong>/<strong>可伸缩性</strong>/<strong>性能</strong>/<strong>可读性</strong>/<strong>可靠性</strong></p><h3 id="2-对比"><a href="#2-对比" class="headerlink" title="2.对比"></a>2.对比</h3><p> <strong>synchronized</strong>通过<strong>(monitor)监视器锁</strong>来完成同步</p><p>每个对象有一个<strong>监视器锁（monitor）</strong>。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权,获取不到则进入阻塞状态</p><p><strong>monitorenter</strong> 进入设置(初始为0,同一个线程每次进入+1,其他线程阻塞)</p><p><strong>monitorexit</strong> 离开设置(当值为0时,表示线程释放锁,所有线程可以再次争夺)</p><p>java反编译字节码(同步方法)不显示monitor的两条指令,而是通过<strong>ACC_SYNCHRONIZED</strong>封装,隐式调用,但仍是执行monitor指令来加解锁</p><p><strong>wait/notify</strong> 等方法的底层同样是基于监视器,因此只有在同步方法(块)中才能调用</p><p><strong>JUC</strong>通过<strong>ASC/AQS/CLH等同步技术</strong>来完成同步</p><p>更加灵活,对资源的损耗较少等如上概念所提</p><h3 id="3-构成"><a href="#3-构成" class="headerlink" title="3.构成"></a>3.构成</h3><p><strong>Atomic</strong> : AtomicInteger 原子数据的构建</p><p><strong>Locks</strong> : Lock, Condition, ReadWriteLock 基本的锁实现,最重要的AQS框架和lockSupport</p><p><strong>Collections</strong> : Queue, ConcurrentMap  构建一些集合的工具</p><p><strong>Executer</strong> : Future, Callable, Executor  构建一些线程池的工具</p><p><strong>Tools</strong> : CountDownLatch, CyclicBarrier, Semaphore 并发队列等</p><p>以上都用到了<strong>CAS</strong>(compare-and-swap)操作.</p><h3 id="4-CAS介绍"><a href="#4-CAS介绍" class="headerlink" title="4.CAS介绍"></a>4.CAS介绍</h3><p><strong>(compare-and-swap)比较和交换</strong></p><p>CAS是一种<strong>低级别</strong>的/<strong>细粒度</strong>的技术,它<strong>允许多个线程更新一个内存位置</strong>,同时能够检测其他线程的冲突并进行恢复,他是<strong>许多高性能并发算法的基础</strong>.</p><p>在<strong>JDK5.0之前</strong>,java语言中用于<strong>协调线程之间的访问的唯一原语是同步(更重量级和粗粒度)</strong>,</p><p>公开<strong>CAS可以开发高度可伸缩的并发java类</strong>,这些更改<strong>主要由JDK库类使用,而不是开发人员</strong></p><p>CAS操作都封装在java不公开的类库中<strong>,sun.misc.Unsafe.</strong></p><p>此类包含了对原子操作的封装,具体用本地代码实现,本地的C代码直接利用到了<strong>硬件上的原子操作</strong></p><h3 id="5-AQS介绍"><a href="#5-AQS介绍" class="headerlink" title="5.AQS介绍"></a>5.AQS介绍</h3><p><strong>(abstract-queued-synchronizer)队列同步器</strong></p><p>JDK1.6以前,synchronized重量级锁的性能一直都较为低下,虽然在1.6以后进行了大量的锁优化策略,</p><p>但与Lock相比,synchronized还是存在一些缺陷</p><h4 id="5-1-synchronized优缺"><a href="#5-1-synchronized优缺" class="headerlink" title="5-1.synchronized优缺"></a>5-1.synchronized优缺</h4><p><strong>优点</strong>:提供了便捷性的隐式获取锁释放锁机制<strong>(基于JVM机制)</strong></p><p><strong>缺点</strong>:缺少了获取锁和释放锁的可操作性,可中断/超时获取锁等,且它为独立式,在高并发场景下性能大打折扣</p><h4 id="5-2-AQS"><a href="#5-2-AQS" class="headerlink" title="5-2.AQS"></a>5-2.AQS</h4><p>构建锁或其他同步组件的基础框架,如:ReentrantLock/ReentrantReadWriteLock/Semaphore等</p><ol><li>JUC并发包的作者希望它能够成为实现大部分同步需求的基础,<strong>是JUC并发包中的核心基础组件</strong></li><li>AQS解决了实现同步器时设计的大量细节问题,如:<strong>获取同步状态/FIFO同步队列</strong></li><li>基于AQS来构同步器可以带来很多好处,不仅能<strong>极大地减少实现工作,也不必处理多个位置上发生竞争问题</strong></li><li>基于AQS构建的同步器中,<strong>只能在同一时刻发生阻塞,从而降低上下文切换带来的开销,提高吞吐量.</strong></li><li>设计AQS时充分考虑了<strong>可伸缩性,JUC中所有基于AQS构建的同步器均可获得这个优势</strong></li></ol><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p><strong>AQS</strong>通过<strong>内置的FIFO同步队列(CLH)</strong>来完成资源获取线程的排队工作,如果当前线程获取同步状态(锁)失败,</p><p><strong>AQS</strong>则会将当前线程以及等待状态等信息构建成一个节点(Node)并将其加入到同步队列中,</p><p>同时阻塞当前线程,当同步状态释放时,会把节点中的线程唤醒,使其再次尝试获取同步状态</p><h4 id="5-3-AQS使用"><a href="#5-3-AQS使用" class="headerlink" title="5-3.AQS使用"></a>5-3.AQS使用</h4><p>AQS主要使用方式是集成,子类通过集成同步器并实现它的抽象方法来管理同步状态</p><p><strong>AQS使用一个int类型的成员变量state来表示同步状态</strong></p><ul><li>当state&gt;0表示获取锁</li><li>state=0表示释放锁</li></ul><p><strong>提供三个方法来对同步状态state进行操作</strong></p><ol><li>getState() 获取当前同步状态值；</li><li>setState(int newState)设置当前同步状态；</li><li>compareAndSetState(int expect,int update) 使用CAS设置当前状态，该方法能够保证状态设置的原子性；</li></ol><p><strong>AQS可以确保对state的操作是安全的</strong></p><p><strong>AQS主要提供的方法</strong></p><p><strong>getState()</strong> 获取当前同步状态值</p><p><strong>setState()</strong> 设置当前同步状态</p><p><strong>compareAndSetState(int expect,int update)</strong> 使用CAS设置当前状态,该方法能够邦正状态设置的原子性</p><p><strong>tryAcquire(int arg)</strong> 独占式获取同步状态,获取同步状态成功后,其他线程需要等待该线程释放同步状态才能获取同步状态</p><p><strong>tryRelease(int arg)</strong> 独占式释放同步状态</p><ul><li>—-共享式获取同步状态,返回值&gt;=0则表示获取成功,否则获取失败</li></ul><p><strong>tryReleaseShared(int arg)</strong> 共享式释放同步状态</p><p><strong>isHeldExclusively()</strong>  当前同步器是否独占式模式下被线程占用,一般该方法表示是否被当前线程所占用</p><p><strong>acquire(int arg)</strong>  独占式获取同步状态,如果当前线程同步状态成功,则由该方法返回,否则进入同步队列等待,该方法将会调用可重写的tryAcquire(int arg)方法</p><p><strong>acquireInterruptibly(int arg)</strong> 与acquire(int arg)方法相同,但是该方法响应中断,当前线程会为获取到同步状态而进入到同步队列中,如果当前线程被中断,则该方法抛出InterruptedException异常并返回</p><p><strong>tryAcquireNanos(int arg,long nanos)</strong> 超时获取同步状态,如果当前线程在nanos时间内没有获取到同步状态,那么将会返回false,已经获取则返回true</p><p><strong>acquireShared(int arg)</strong> 共享式获取同步状态,如果当前线程未获取到同步状态,将会进入同步队列等待,与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态</p><p><strong>acquireSharedInterruptibly(int arg)</strong> 共享式获取同步状态,响应中断,当前线程会为获取到同步状态而进入到同步队列中,如果当前线程被中断,则该方法抛出InterruptedException异常并返回</p><p><strong>tryAcquireSharedNanos(int arg,long nanosTimeout)</strong> 共享式获取同步状态,增加超时限制</p><p><strong>release(int arg)</strong> 独占式释放同步状态,该方法会释放同步状态之后,将同步队列中第一个节点包含的线程唤醒</p><p><strong>releaseShared(int arg)</strong> 共享式释放同步状态,该方法会释放同步状态之后,将同步队列中第一个节点包含的线程唤醒</p><h3 id="6-部分底层锁简介"><a href="#6-部分底层锁简介" class="headerlink" title="6.部分底层锁简介"></a>6.部分底层锁简介</h3><p><strong>自旋锁/排队自旋锁/MSC锁/CLH锁</strong></p><p><a href="https://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">https://coderbee.net/index.php/concurrent/20131115/577</a></p><p><strong>公平锁/非公平锁/可重入锁</strong></p><p><strong>独享锁/共享锁</strong></p><p><strong>互斥锁/读写锁</strong></p><p><strong>乐观锁/悲观锁</strong></p><p><strong>分段锁</strong></p><p><strong>偏向锁/轻量级锁/重量级锁</strong></p><p><a href="https://blog.csdn.net/weixin_38894058/article/details/78952585" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38894058/article/details/78952585</a></p><h3 id="7-CLH同步队列"><a href="#7-CLH同步队列" class="headerlink" title="7.CLH同步队列"></a>7.CLH同步队列</h3><p><strong>AQS内部维护的FIFO队列,即CLH同步队列</strong></p><p><strong>AQS依赖CLH同步队列才能完成同步状态的管理</strong>(自旋锁-&gt;公平锁,详情了解6章节内容)</p><p><a href="https://blog.csdn.net/chenssy/article/details/60781148" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/60781148</a></p><p>CLH同步队列中,一个节点表示一个线程,包含如下:</p><ol><li>线程的引用(thread)</li><li>状态(waitStatus)</li><li>前驱节点(prev)</li><li>后继节点(next)</li></ol><p>AQS通过”死循环”(自旋)的方法保证节点的正确添加,只有添加成功后,当前线程才会从该方法返回,否则一直执行</p><p><strong>CLH同步队列中,当首节点释放同步状态后,将会唤醒其后继节点,后继节点获取同步状态成功后将自己设为首节点</strong></p><p><strong>CLH唤醒方法简述</strong></p><p>前驱节点:<strong>isLocked=true</strong></p><p>后置节点:<strong>while(preNode.isLocked){}</strong></p><p>后置节点会轮询前驱节点的锁状态,当前驱节点释放锁,isLocked=false,则后置节点跳出”死循环(自旋)”尝试获取锁</p><h4 id="7-1-独占式"><a href="#7-1-独占式" class="headerlink" title="7-1.独占式"></a><strong>7-1.独占式</strong></h4><p><strong>独占式获取响应中断</strong></p><p>AQS提供了acquire(int arg)方法让独占式获取同步状态,但是该方法对中断不响应,线程中断后仍然会在对联中等待获取同步状态,为了响应中断,可以使用acquireInterruptibly(int arg)方法,线程中断后立刻抛出InterruptedException异常</p><p><strong>独占式超时获取</strong></p><p>tryAcquireNano(int arg,long nanos),如果指定时间没有获得同步状态,则直接返回false,否则返回true</p><p><strong>独占式同步状态释放</strong></p><p>release(int arg) 释放同步状态</p><p>(该方法先调用自定义同步器定义的tryRelease(int arg)方法释放同步状态,释放成功后调用unparkSuccessor(Node node)方法唤醒后继节点)</p><h4 id="7-2-共享式"><a href="#7-2-共享式" class="headerlink" title="7-2.共享式"></a><strong>7-2.共享式</strong></h4><p>共享式和独占式最大的区别是同一时刻共享式可以有多个线程获得同步状态,而独占式只有一个线程可以获得</p><p>共享式<strong>读操作</strong>可以有多个线程同时执行,<strong>写操作</strong>同一时刻只有一个线程,其他线程会被阻塞</p><p><strong>共享式获取同步状态</strong></p><p>AQS提供acquireShared(int arg)方法让共享式获取同步状态,该方法中</p><p>首先调用tryAcquireShared(int arg)方法尝试获取同步状态,如果获取失败</p><p>则调用doAcquireShared(int arg)自旋方式获取同步状态,共享式获取同步状态的标志是返回&gt;=0</p><p><strong>共享式获取同步状态响应中断</strong></p><p>AQS提供acquireShared(int arg)方法让共享式获取同步状态,该方法对中断也不响应,需要使用,中断和超时的方法分别为</p><p>acquireSharedInterruptibly(int arg)</p><p>tryAcquireSharedNanos(int arg,long nanos)</p><p><strong>共享式同步状态释放</strong></p><p>releaseShared(int arg)释放同步状态</p><p>内部调用tryReleaseShared(int arg)来尝试循环释放</p><p>因为可能存在多个线程同时释放同步状态资源,所以需要确保同步状态安全成功的释放,一般都是通过CAS和循环来完成</p><h4 id="7-3-阻塞和唤醒线程"><a href="#7-3-阻塞和唤醒线程" class="headerlink" title="7-3.阻塞和唤醒线程"></a><strong>7-3.阻塞和唤醒线程</strong></h4><p>在线程获取同步状态时,如果获取失败,则加入CLH同步队列,通过自旋的方式不断获取同步状态,但在自选的过程中需要判断该线程是否需要阻塞,</p><p>通过acquireQueued()方法</p><p>该方法内首先需要判断该线程的状态,再决定是否阻塞</p><p>主要通过该节点的前驱节点判断当前线程是否应该被阻塞,规则如下:</p><ol><li>如果当前线程的前驱节点状态为SIGNAL,则表示当前线程需要被阻塞,调用unpark()方法唤醒,直接返回true,当前线程阻塞</li><li>如果当前线程的前驱节点状态为CANCELLED(取消)(ws&gt;0),表示该线程的前驱节点超时或中断</li><li>如果前驱节点非SIGNAL,非CANCELLED,则通过CAS(compareAndSetWaitStatus)的方式将其前驱节点设置为SIGNAL,返回false</li></ol><p>如果shouldParkAfterFailedAcquire(Node pred, Node node) 方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程;</p><p>当前线程release(int arg)释放同步状态后,调用unparkSuccessor(Node node)唤醒后继节点</p><p><strong>注意</strong></p><p>后继节点可能存在null,如超时/被中断等情况,需要跳过该节点,</p><p>所以不采用next的方法,而采用<strong>tail回溯</strong>的办法<strong>找第一个可用线程</strong>,</p><p>最后调用LockSupport的<strong>unpark(Thread thread)方法唤醒该线程</strong></p><h4 id="7-4-LockSupport"><a href="#7-4-LockSupport" class="headerlink" title="7-4.LockSupport"></a><strong>7-4.LockSupport</strong></h4><p><strong>阻塞或唤醒</strong>一个线程时,AQS都会使用<strong>LockSupport</strong>这个工具类来完成</p><p><strong>原语:LockSupport是用来创建锁和其他同步类的基本线程阻塞</strong></p><p>每个使用LockSupport的线程都会与一个<strong>许可关联</strong>,</p><p>如果<strong>该许可可用</strong>,并且<strong>可在进程中使用</strong>,<strong>则调用park()将会立即返回</strong>,否则进入阻塞状态</p><p>如果<strong>许可尚不可用</strong>,可以<strong>调用unpark使其可用</strong>,但是许可不可以重入,只能调用一次park()方法,否则一直进入阻塞状态</p><p>LockSupport定义了一系列<strong>park开头的方法用来阻塞当前线程</strong>,<strong>unark(Thread thread)方法唤醒一个被阻塞的线程</strong><br><img src="https://i.imgur.com/Q6FmVPd.jpg" alt=""></p><p><strong>park(Object blocker)</strong>方法的blocker参数，主要是用来标识当前线程在等待的对象，该对象主要用于问题排查和系统监控。</p><p><strong>park方法和unpark(Thread thread)都是成对出现的</strong>，同时unpark必须要在park执行之后执行，当然并不是说没有不调用unpark线程就会一直阻塞，park有一个方法，它带了时间戳（parkNanos(long nanos)：为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用）。</p><p><strong>park()和unpark()源码</strong>都是调用UNSAFE类中的方法,该方法都是native中的本地方法,比较危险,主要用于执行<strong>低级别,不安全的方法集合</strong>,</p><p>除非是<strong>授信代码</strong>,否则无法再java程序中直接使用</p><p><strong>基础概括传送门</strong></p><p><a href="https://my.oschina.net/lifany/blog/146699" target="_blank" rel="noopener">https://my.oschina.net/lifany/blog/146699</a></p><p><strong>教全基础概括传送门</strong></p><p><a href="https://blog.csdn.net/windsunmoon/article/details/36903901" target="_blank" rel="noopener">https://blog.csdn.net/windsunmoon/article/details/36903901</a></p><p><strong>参考链接门(含部分源码与流程图):</strong></p><p><a href="https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70" target="_blank" rel="noopener">https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70</a></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>Doug Lea：《Java并发编程实战》方腾飞：《Java并发编程的艺术》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;concurrent并发包入门-一&quot;&gt;&lt;a href=&quot;#concurrent并发包入门-一&quot; class=&quot;headerlink&quot; title=&quot;concurrent并发包入门(一)&quot;&gt;&lt;/a&gt;concurrent并发包入门(一)&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="JAVA并发编程" scheme="http://yoursite.com/categories/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Apollo基础(一)</title>
    <link href="http://yoursite.com/2018/10/09/Apollo%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/10/09/Apollo基础(一)/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2018-10-09T12:47:06.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apollo基础-一"><a href="#Apollo基础-一" class="headerlink" title="Apollo基础(一)"></a>Apollo基础(一)</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>配置中心,实时监听最新配置列表,动态添加配置</p><p><strong>实时生效/灰度发布/分环境/分集群管理配置/完善权限/本地离线等</strong></p><p><strong>本地离线</strong></p><ul><li><strong>Mac/Linux</strong>: /opt/data/{<em>appId</em>}/config-cache</li><li><strong>Windows</strong>: C:\opt\data{<em>appId</em>}\config-cache</li></ul><p>本地配置文件会以下面的文件名格式放置于本地缓存路径下：</p><p><strong>{appId}+{cluster}+{namespace}.properties</strong></p><p><strong>支持四个维度管理的kv配置:</strong></p><ol><li>application(应用)</li><li>env(环境)</li><li>cluster(集群)</li><li>namespace(命名空间)</li></ol><h4 id="1-2-配置的基本概念"><a href="#1-2-配置的基本概念" class="headerlink" title="1-2.配置的基本概念"></a>1-2.配置的基本概念</h4><h5 id="独立于程序的只读变量"><a href="#独立于程序的只读变量" class="headerlink" title="独立于程序的只读变量"></a>独立于程序的只读变量</h5><h5 id="配置伴随应用的整个生命周期"><a href="#配置伴随应用的整个生命周期" class="headerlink" title="配置伴随应用的整个生命周期"></a>配置伴随应用的整个生命周期</h5><h5 id="配置可以有多种加载方式"><a href="#配置可以有多种加载方式" class="headerlink" title="配置可以有多种加载方式:"></a>配置可以有多种加载方式:</h5><ol><li>hard code</li><li>配置文件</li><li>环境变量</li><li>启动参数</li><li>基于数据库等</li></ol><h5 id="配置治理"><a href="#配置治理" class="headerlink" title="配置治理:"></a>配置治理:</h5><ol><li>权限控制</li><li>不同的环境/集群配置管理</li><li>框架类组件配置管理</li></ol><h3 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h3><p>四个核心模块(功能相关),三个辅助模块(辅助服务发现的模块)</p><p>———————————-[核心功能模块]————————————</p><h4 id="2-1-ConfigService"><a href="#2-1-ConfigService" class="headerlink" title="2-1.ConfigService"></a>2-1.ConfigService</h4><p>提供配置<strong>获取</strong>接口</p><p>提供配置<strong>推送</strong>接口</p><p>服务于<strong>Apollo客户端</strong></p><h4 id="2-2-AdminService"><a href="#2-2-AdminService" class="headerlink" title="2-2.AdminService"></a>2-2.AdminService</h4><p>提供配置<strong>管理</strong>接口</p><p>提供配置<strong>修改发布</strong>接口</p><p>服务于<strong>管理界面Portal</strong></p><h4 id="2-3-Client"><a href="#2-3-Client" class="headerlink" title="2-3.Client"></a>2-3.Client</h4><p>为应用<strong>获取配置</strong>,支持<strong>实时更新</strong></p><p>通过<strong>MetaServer</strong>获取<strong>ConfigService</strong>的服务列表</p><p>使用客户端软负载<strong>SLB</strong>方式调用<strong>ConfigService</strong></p><h4 id="2-4-Portal"><a href="#2-4-Portal" class="headerlink" title="2-4.Portal"></a>2-4.Portal</h4><p>配置管理界面</p><p>通过<strong>MetServer</strong>获取<strong>AdminService</strong>列表</p><p>使用客户端软辅在<strong>SLB</strong>方式调用<strong>AdminSerivce</strong></p><p>———————————–[辅助服务发现模块]————————————</p><h3 id="2-5-Eureka"><a href="#2-5-Eureka" class="headerlink" title="2-5.Eureka"></a>2-5.Eureka</h3><h6 id="用于服务注册和发现"><a href="#用于服务注册和发现" class="headerlink" title="用于服务注册和发现,"></a>用于服务注册和发现,</h6><p><strong>ConfigService/AdminService</strong>注册实例并定期报心跳</p><p>和<strong>ConfigService</strong>在一起部署</p><h4 id="2-6-MetaServer"><a href="#2-6-MetaServer" class="headerlink" title="2-6.MetaServer"></a>2-6.MetaServer</h4><p><strong>Portal</strong>通过域名访问MetaServer获取<strong>AdminService</strong>服务列表</p><p><strong>Client</strong>通过域名访问MetaServer获取<strong>ConfigService</strong>服务地址</p><p>相当于<strong>Eureka Proxy</strong></p><h3 id="2-7-NginxLB"><a href="#2-7-NginxLB" class="headerlink" title="2-7.NginxLB"></a>2-7.NginxLB</h3><p>和域名系统配合,<strong>协助Portal访问MetaServer</strong>,获取AdminService列表</p><p>和域名系统配合,<strong>协助client访问MetaServer</strong>,获取ConfigService列表</p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="https://i.imgur.com/q2pOhTI.jpg" alt=""></p><h3 id="3-Apollo使用指南"><a href="#3-Apollo使用指南" class="headerlink" title="3.Apollo使用指南"></a>3.Apollo使用指南</h3><p><a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Apollo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97</a></p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="4-API接入管理-Protal"><a href="#4-API接入管理-Protal" class="headerlink" title="4.API接入管理(Protal)"></a>4.API接入管理(Protal)</h3><p><a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D</a></p><h3 id="5-接入使用-Client"><a href="#5-接入使用-Client" class="headerlink" title="5.接入使用(Client)"></a>5.接入使用(Client)</h3><h4 id="5-1-常用方案"><a href="#5-1-常用方案" class="headerlink" title="5-1.常用方案:"></a>5-1.常用方案:</h4><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">maven</span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apollo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">gradle</span><br><span class="line">    compile 'com.ctrip.framework.apollo:apollo-client:1.0.0'</span><br></pre></td></tr></table></figure><p>在properties中配置命名空间等即可使用(当做在线properties即可)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.id=apollo-id</span><br><span class="line">apollo.meta=http://localhost:8080</span><br><span class="line">env=DEV</span><br><span class="line"># will inject &apos;application&apos; namespace in bootstrap phase</span><br><span class="line">apollo.bootstrap.enabled = true</span><br><span class="line">apollo.bootstrap.namespaces =redis</span><br></pre></td></tr></table></figure><h4 id="5-2-方案二"><a href="#5-2-方案二" class="headerlink" title="5-2.方案二"></a>5-2.方案二</h4><p><strong>Bean</strong>的形式注入到Spring中(该场景使用不多)(支持<strong>注解/XML</strong>等形式)</p><p><strong>配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonSingleConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;serverConfig:Single&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverConfig;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;singleServerConfig.address:127.0.0.1&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;singleServerConfig.connectionPoolSize:100&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer connectionPoolSize;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;keepAlive:true&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Boolean keepAlive;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;database:0&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer database;</span><br><span class="line"><span class="comment">//get set 略</span></span><br></pre></td></tr></table></figure><p><strong>Bean注入类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableApolloConfig</span>(value = &#123;<span class="string">"namespace"</span>&#125;) <span class="comment">//可省略指定命名空间,默认为application私有空间</span></span><br><span class="line"><span class="comment">//@EnableApolloConfig(&#123;"FX.apollo", "FX.soa"&#125;) //指定多个命名空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonSingleConfig <span class="title">getRedissonSingleConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedissonSingleConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的拉取和注入即可将Apollo的配置注入到Spring中使用,更多内容可参考官网java接入指南</p><p><a href="https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#31-api%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97#31-api%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F</a></p><h4 id="5-3-方案三"><a href="#5-3-方案三" class="headerlink" title="5-3.方案三"></a>5-3.方案三</h4><p><strong>动态切换数据库</strong></p><p><a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%BB%8B%E7%BB%8D</a></p><p>Hikaricp官网(动态切换jar包)</p><p><a href="http://brettwooldridge.github.io/HikariCP/" target="_blank" rel="noopener">http://brettwooldridge.github.io/HikariCP/</a></p><h3 id="6-Apollo使用"><a href="#6-Apollo使用" class="headerlink" title="6.Apollo使用"></a>6.Apollo使用</h3><ol><li><p>创建项目</p></li><li><p>创建配置空间(private/public)</p></li></ol><p>私有空间是本项目使用,</p><p>公共空间是通用空间,其他项目都可以使用</p><p><strong>注意:</strong></p><p>公共空间使用时<strong>建议关联</strong>一个新副本,该副本改动的配置属性为<strong>覆盖效果</strong>,可覆盖公共空间的<strong>部分配置</strong></p><h3 id="优秀分析传送门"><a href="#优秀分析传送门" class="headerlink" title="优秀分析传送门:"></a>优秀分析传送门:</h3><p> <code>https://mp.weixin.qq.com/s/-hUaQPzfsl9Lm3IqQW3VDQ</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Apollo基础-一&quot;&gt;&lt;a href=&quot;#Apollo基础-一&quot; class=&quot;headerlink&quot; title=&quot;Apollo基础(一)&quot;&gt;&lt;/a&gt;Apollo基础(一)&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>快速入门自定义Starter</title>
    <link href="http://yoursite.com/2018/10/09/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%87%AA%E5%AE%9A%E4%B9%89Starter/"/>
    <id>http://yoursite.com/2018/10/09/快速入门自定义Starter/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2018-10-09T13:02:38.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速入门自定义Starter"><a href="#快速入门自定义Starter" class="headerlink" title="快速入门自定义Starter"></a>快速入门自定义Starter</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>依赖管理是任何复杂项目的关键所在,当项目布局比较大时,纯手工的去做依赖显然比较浪费时间和精力,其中产生各种小问题同样会减少工作核心部分的投入时间</p><p><strong>Springboot starter</strong>作为Springboot四大神器之一,就是为了解决这一问题而诞生,分而治之,提高代码复用性,让代码的配置看起来更加简洁</p><p>(与Apollo结合使用将大大降低因配置而产生的维护难度,提高了配置的治理效率)</p><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><p>1.引入SpringBoot配置自动注入的依赖*2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 以下两个依赖是自动配置的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.创建配置类(定义properties的内容)</p><p>3.创建服务类(需要封装和处理的业务逻辑等)</p><p>4.创建自动配置类(将配置类和服务类注入)</p><p>5.创建resources/META-INF/spring.factories工厂配置文件,注入自动配置类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.dony15.config.PersonServiceAutoConfiguration</span><br></pre></td></tr></table></figure><h3 id="3-搭建"><a href="#3-搭建" class="headerlink" title="3.搭建"></a>3.搭建</h3><h4 id="3-1-配置类"><a href="#3-1-配置类" class="headerlink" title="3-1.配置类"></a>3-1.<strong>配置类</strong></h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dony15.config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassMame</span>: PersonServiceProperties</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 人员信息自动配置属性类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 宝全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/9/18 10:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"person.proterties.set"</span>)<span class="comment">// 定义application.properties配置文件中的配置前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceProperties</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 性别，不配置的时候默认为person.proterties.set=man</span></span><br><span class="line">    <span class="keyword">private</span> String sex = <span class="string">"man"</span>;</span><br><span class="line">    <span class="comment">// 身高</span></span><br><span class="line">    <span class="keyword">private</span> String height;</span><br><span class="line">    <span class="comment">// 体重</span></span><br><span class="line">    <span class="keyword">private</span> String weight;</span><br><span class="line">    ...get/set略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-服务类"><a href="#3-2-服务类" class="headerlink" title="3-2.服务类"></a>3-2.服务类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dony15.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dony15.config.PersonServiceProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassMame</span>: PersonService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 编写服务类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 宝全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/9/18 10:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PersonServiceProperties personServiceProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonService</span><span class="params">(PersonServiceProperties personServiceProperties)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personServiceProperties=personServiceProperties;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPersonName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personServiceProperties.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPersonAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personServiceProperties.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPersonSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personServiceProperties.getSex();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-自动配置类-核心"><a href="#3-3-自动配置类-核心" class="headerlink" title="3-3.自动配置类(核心)"></a>3-3.自动配置类(核心)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dony15.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dony15.service.PersonService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassMame</span>: PersonServiceAutoConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 宝全</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/9/18 10:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//声明配置类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(PersonServiceProperties.class) <span class="comment">//开启指定类的配置</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(PersonService.class) <span class="comment">//当PersonService这个类在类路径中时，且当前容器中没有这个Bean的情况下，开始自动配置</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"person.proterties.set"</span>,value = <span class="string">"enabled"</span>,matchIfMissing = <span class="keyword">true</span>) <span class="comment">//指定的属性是否有指定的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonServiceProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(PersonService.class) <span class="comment">//当前容器中没有指定bean的情况下,自动配置PersonService类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonService <span class="title">personService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonService(properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h3><p>至此,一个简单的starter搭建完毕,如下可以引用</p><p><strong>maven</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 引入自己的starter --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dony15<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>properties</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.proterties.set.age=18</span><br><span class="line">person.proterties.set.name=常贵</span><br><span class="line">person.proterties.set.height=189</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>然后直接Autowired自动注入即可正常使用</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速入门自定义Starter&quot;&gt;&lt;a href=&quot;#快速入门自定义Starter&quot; class=&quot;headerlink&quot; title=&quot;快速入门自定义Starter&quot;&gt;&lt;/a&gt;快速入门自定义Starter&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-概念
      
    
    </summary>
    
      <category term="Spring全家桶" scheme="http://yoursite.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>WebSocket入门</title>
    <link href="http://yoursite.com/2018/10/01/WebSocket%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/10/01/WebSocket入门/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2018-10-01T09:54:16.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocket入门"><a href="#WebSocket入门" class="headerlink" title="WebSocket入门"></a>WebSocket入门</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>ws协议,基于TCP连接,随着H5的发展而诞生</p><p>允许浏览器和服务器建立持久连接</p><p>服务器可以主动给客户端发送信息,双向互通</p><h3 id="2-基础组成"><a href="#2-基础组成" class="headerlink" title="2.基础组成"></a>2.基础组成</h3><p>基础的组件由/open/close/send/message/error组成并延伸</p><p>当然,实际使用时需要有服务器来作为通信支撑,此处以nodejs为例</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>首先需要安装nodjs环境</p><p>然后使用脚本拉取github的开源服务器model</p><p><code>npm install nodejs-websocket</code></p><p>使用一下方式建立服务器脚本即可(需要与model同层,配置才生效)</p><p>wsServer.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="built_in">require</span>(<span class="string">"nodejs-websocket"</span>)</span><br><span class="line"><span class="keyword">var</span> port=<span class="number">8000</span>;<span class="comment">//监听端口</span></span><br><span class="line"><span class="comment">// Scream server example: "hi" -&gt; "HI!!!"</span></span><br><span class="line"><span class="comment">//服务连接事件,连接后才会有内部的事件执行</span></span><br><span class="line"><span class="keyword">var</span> server = ws.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">conn</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"New connection"</span>)</span><br><span class="line">    <span class="comment">//消息的收发中转</span></span><br><span class="line">conn.on(<span class="string">"text"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Received "</span>+str)</span><br><span class="line">conn.sendText(str.toUpperCase()+<span class="string">"!!!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//关闭连接时的事件</span></span><br><span class="line">conn.on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code, reason</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Connection closed"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//错误时的事件,如果没有该函数,服务器会因消息错误而宕机,相当于java中的异常捕获</span></span><br><span class="line">    conn.on(<span class="string">"error"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(port)</span><br></pre></td></tr></table></figure><p>启动方式:<code>node wsServer.js</code></p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>以js为例(java/nodejs等语法稍微有区别,但原理相同)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先需要创建ws协议,才能使用</span></span><br><span class="line"><span class="keyword">var</span> websocket=<span class="keyword">new</span> WebSocket(<span class="string">"ws://echo.websocket.org/"</span>);</span><br></pre></td></tr></table></figure><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>onopen/onclose/onmessage/onerror等,如下</p><h4 id="2-1-open"><a href="#2-1-open" class="headerlink" title="2-1.open"></a>2-1.open</h4><p>建立连接,比如发送按钮事件,可以嵌套在open中,如果websocket没有连接,name发送按钮本身也没有意义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">websocket.onopen=function()&#123;</span><br><span class="line">    consolet.log(&quot;websocket open&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-close"><a href="#2-2-close" class="headerlink" title="2-2.close"></a>2-2.close</h4><p>关闭连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">websocket.onclose=function()&#123;</span><br><span class="line">    consolet.log(&quot;websocket close&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-send"><a href="#2-3-send" class="headerlink" title="2-3.send"></a>2-3.send</h4><p>发送消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">websocket.send(&quot;这是发送的消息&quot;)</span><br></pre></td></tr></table></figure><h4 id="2-4-message"><a href="#2-4-message" class="headerlink" title="2-4.message"></a>2-4.message</h4><p>接收消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">websocket.onmessage=function(e)&#123;</span><br><span class="line">    consolet.log(e.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于message来说,e.data只是普通的字符串消息接收</p><p>但是因为实际的需求,如:用户离开/进入/统计等等</p><p>需要将消息分离,那么我们可以用对象的方式来操作信息</p><h4 id="2-5-error"><a href="#2-5-error" class="headerlink" title="2-5.error"></a>2-5.error</h4><p>错误情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">websocket.onerror=function(err)&#123;</span><br><span class="line">    consolet.log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-格式化消息改造"><a href="#3-格式化消息改造" class="headerlink" title="3.格式化消息改造"></a>3.格式化消息改造</h3><p>通过以上的基础组件,我们可以实现简单的webSocket通信,但是稍微复杂一些的信息格式却难以完成,比如用户离开/进入/统计等</p><p>我们可以对消息进行JSON格式化来完成这样的基础实现</p><h4 id="3-1-服务器改造"><a href="#3-1-服务器改造" class="headerlink" title="3-1.服务器改造"></a>3-1.服务器改造</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="built_in">require</span>(<span class="string">"nodejs-websocket"</span>)</span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8000</span>;</span><br><span class="line"><span class="keyword">var</span> clientCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = ws.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">conn</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"New connection"</span>);</span><br><span class="line"></span><br><span class="line">    clientCount++;<span class="comment">//临时区分用户使用</span></span><br><span class="line">    conn.nickname = <span class="string">'用户'</span> + clientCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mes = &#123;&#125;;<span class="comment">//封装消息</span></span><br><span class="line">    mes.type = <span class="string">"enter"</span>;<span class="comment">//消息类型</span></span><br><span class="line">    mes.data = conn.nickname + <span class="string">"进入房间"</span>;<span class="comment">//消息内容</span></span><br><span class="line">    broadcast(<span class="built_in">JSON</span>.stringify(mes));<span class="comment">//封装消息发送函数</span></span><br><span class="line"></span><br><span class="line">    conn.on(<span class="string">"text"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mes = &#123;&#125;;</span><br><span class="line">        mes.type = <span class="string">"message"</span>;</span><br><span class="line">        mes.data = conn.nickname + <span class="string">"说:"</span> + str;</span><br><span class="line">        broadcast(<span class="built_in">JSON</span>.stringify(mes))</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    conn.on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code, reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mes = &#123;&#125;;</span><br><span class="line">        mes.type = <span class="string">"leave"</span>;</span><br><span class="line">        mes.data = conn.nickname + <span class="string">"离开房间"</span>;</span><br><span class="line">        broadcast(<span class="built_in">JSON</span>.stringify(mes));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    conn.on(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;).listen(port);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"WebSocket Start Success:"</span> + port);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    server.connections.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">connection</span>) </span>&#123;</span><br><span class="line">        connection.sendText(msg);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上,将消息封装为一个mes对象,通过定义其属性来完成分类消息的发送</p><p><code>type=&quot;enter&quot;</code> 表示进入</p><p><code>type=&quot;leave&quot;</code>表示离开</p><p><code>data</code>表示封装的消息</p><p>发送时将消息格式化为JSON字符串发送到前段即可</p><h4 id="3-2-客户端改造"><a href="#3-2-客户端改造" class="headerlink" title="3-2.客户端改造"></a>3-2.客户端改造</h4><p>通过类型的判断,来实现想要的显示方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Websocket<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>WebSocket<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"sendText"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"sendBtn"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> webSocket=<span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8000/"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sendBtn = <span class="built_in">document</span>.getElementById(<span class="string">"sendBtn"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params">data,type</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> div= <span class="built_in">document</span>.createElement(div);</span></span><br><span class="line"><span class="javascript">       div.innerHTML=<span class="string">"&lt;br/&gt;"</span>+data;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">if</span> (type==<span class="string">"enter"</span>)&#123;</span></span><br><span class="line"><span class="javascript">           div.style.color=<span class="string">"blue"</span>;</span></span><br><span class="line"><span class="undefined">       &#125;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">if</span> (type==<span class="string">"leave"</span>)&#123;</span></span><br><span class="line"><span class="javascript">           div.style.color=<span class="string">"red"</span>;</span></span><br><span class="line"><span class="undefined">       &#125;</span></span><br><span class="line"><span class="javascript">       <span class="built_in">document</span>.body.appendChild(div);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    webSocket.onopen=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        sendBtn.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> sendText = <span class="built_in">document</span>.getElementById(<span class="string">"sendText"</span>).value;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (sendText)&#123;</span></span><br><span class="line"><span class="undefined">            webSocket.send(sendText);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="javascript">    webSocket.onclose=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="javascript">    webSocket.onmessage=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> mes=<span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line"><span class="undefined">        showMessage(mes.data,mes.type);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上是原生的WebSocket,如果需要更为丰富的通信,可以使用Socket.IO框架来实现</p><h3 id="4-Socket-IO框架"><a href="#4-Socket-IO框架" class="headerlink" title="4.Socket.IO框架"></a>4.Socket.IO框架</h3><p>支持包括java/python/c++等多语言框架(底部连接)</p><p><strong>NodeJs案例</strong></p><p>通过以下指令安装socket.io模块</p><p>(需要nodejs环境和c编译器环境)</p><h4 id="4-1-服务端"><a href="#4-1-服务端" class="headerlink" title="4-1.服务端"></a>4-1.服务端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer();</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123; <span class="comment">//socket 与客户端的连接</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  emit发送指定格式消息,on接收指定格式消息</span></span><br><span class="line"><span class="comment">     *  当emit为io.emit时,表示广播形式</span></span><br><span class="line"><span class="comment">     *  自定义KV,可以发送对象,简化了消息格式化的过程</span></span><br><span class="line"><span class="comment">     *  自定义on的K,简化了自定义消息分类的过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    socket.on(<span class="string">'Dony15'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">        socket.emit(<span class="string">'Dony15'</span>,data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听3000端口,此处演示为监听时可执行函数功能,也可不执行</span></span><br><span class="line"><span class="comment"> * server.listen(3000)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listen on *：3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="注意emit"><a href="#注意emit" class="headerlink" title="注意emit"></a>注意emit</h5><p>当其为io中的函数socket.emit时,代表的是<strong>发送</strong></p><p>当io.emit时,代表的是<strong>广播</strong></p><h4 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4-2.客户端"></a>4-2.客户端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;WebSocketIO&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="https:/</span><span class="regexp">/cdnjs.cloudflare.com/</span>ajax/libs/socket.io/<span class="number">2.0</span><span class="number">.3</span>/socket.io.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    var socket=io('ws://localhost:3000');</span></span><br><span class="line"><span class="string">    socket.on('Dony15',function (data) &#123;</span></span><br><span class="line"><span class="string">        console.log(data);</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">    socket.emit('Dony15',&#123;name:'长贵',age:30&#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-Socket-IO服务端改造"><a href="#4-3-Socket-IO服务端改造" class="headerlink" title="4-3.Socket.IO服务端改造"></a>4-3.Socket.IO服务端改造</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(); <span class="comment">//创建http服务</span></span><br><span class="line"><span class="keyword">var</span> io=<span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server); <span class="comment">//将服务包装为io的形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PORT = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">var</span> clientCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123; <span class="comment">//通过io建立连接</span></span><br><span class="line">    clientCount++;</span><br><span class="line">    socket.nickname = <span class="string">'用户'</span> + clientCount;</span><br><span class="line">    io.emit(<span class="string">'enter'</span>,socket.nickname+<span class="string">'进入'</span>); <span class="comment">//广播</span></span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;    <span class="comment">//以message类型发消息</span></span><br><span class="line">        io.emit(<span class="string">'message'</span>,socket.nickname+<span class="string">'说:'</span>+str)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//特殊:disconnect类型表示断开</span></span><br><span class="line">        io.emit(<span class="string">'leave'</span>,socket.nickname+<span class="string">'离开'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure><h4 id="4-4-Socket-IO客户端改造"><a href="#4-4-Socket-IO客户端改造" class="headerlink" title="4-4.Socket.IO客户端改造"></a>4-4.Socket.IO客户端改造</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocketIO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//引入在线Socket.IO.js,开发建立离线使用</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>WebSocket<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"sendText"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"sendBtn"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> socket = io(<span class="string">"ws://localhost:3000/"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sendBtn = <span class="built_in">document</span>.getElementById(<span class="string">"sendBtn"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//判断输出样式</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params">data, type</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(div);</span></span><br><span class="line"><span class="javascript">        div.innerHTML = <span class="string">"&lt;br/&gt;"</span> + data;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (type == <span class="string">"enter"</span>) &#123;</span></span><br><span class="line"><span class="javascript">            div.style.color = <span class="string">"blue"</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (type == <span class="string">"leave"</span>) &#123;</span></span><br><span class="line"><span class="javascript">            div.style.color = <span class="string">"red"</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(div);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//点击发送消息</span></span></span><br><span class="line"><span class="javascript">    sendBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> sendText = <span class="built_in">document</span>.getElementById(<span class="string">"sendText"</span>).value;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (sendText) &#123;</span></span><br><span class="line"><span class="javascript">            socket.emit(<span class="string">'message'</span>, sendText);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//Socket.IO监听消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'enter'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">//进入房间</span></span></span><br><span class="line"><span class="javascript">        showMessage(data,<span class="string">'enter'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'leave'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">//离开房间</span></span></span><br><span class="line"><span class="javascript">        showMessage(data,<span class="string">'leave'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">//发送消息</span></span></span><br><span class="line"><span class="javascript">        showMessage(data,<span class="string">'message'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-5-示例截图"><a href="#4-5-示例截图" class="headerlink" title="4-5.示例截图"></a>4-5.示例截图</h4><p><img src="https://i.imgur.com/678Bp4V.png" alt=""></p><h3 id="5-传送门"><a href="#5-传送门" class="headerlink" title="5.传送门"></a>5.传送门</h3><p>慕课网WebSocket入门教程</p><p><a href="https://www.imooc.com/learn/861" target="_blank" rel="noopener">https://www.imooc.com/learn/861</a></p><p>Socket.IO官网文档</p><p><a href="https://socket.io/get-started/chat/" target="_blank" rel="noopener">https://socket.io/get-started/chat/</a> </p><p>多语言GitHub服务器示例社区维护</p><ul><li>Java：<a href="https://github.com/socketio/socket.io-client-java" target="_blank" rel="noopener">https</a>：<a href="https://github.com/socketio/socket.io-client-java" target="_blank" rel="noopener">//github.com/socketio/socket.io-client-java</a></li><li>C ++：<a href="https://github.com/socketio/socket.io-client-cpp" target="_blank" rel="noopener">https</a>：<a href="https://github.com/socketio/socket.io-client-cpp" target="_blank" rel="noopener">//github.com/socketio/socket.io-client-cpp</a></li><li>Swift：<a href="https://github.com/socketio/socket.io-client-swift" target="_blank" rel="noopener">https</a>：<a href="https://github.com/socketio/socket.io-client-swift" target="_blank" rel="noopener">//github.com/socketio/socket.io-client-swift</a></li><li>Dart：<a href="https://github.com/rikulo/socket.io-client-dart" target="_blank" rel="noopener">https</a>：<a href="https://github.com/rikulo/socket.io-client-dart" target="_blank" rel="noopener">//github.com/rikulo/socket.io-client-dart</a></li><li>Python：<a href="https://github.com/invisibleroads/socketIO-client" target="_blank" rel="noopener">https</a>：<a href="https://github.com/invisibleroads/socketIO-client" target="_blank" rel="noopener">//github.com/invisibleroads/socketIO-client</a></li><li>.Net：<a href="https://github.com/Quobject/SocketIoClientDotNet" target="_blank" rel="noopener">https</a>：<a href="https://github.com/Quobject/SocketIoClientDotNet" target="_blank" rel="noopener">//github.com/Quobject/SocketIoClientDotNet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebSocket入门&quot;&gt;&lt;a href=&quot;#WebSocket入门&quot; class=&quot;headerlink&quot; title=&quot;WebSocket入门&quot;&gt;&lt;/a&gt;WebSocket入门&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务入门</title>
    <link href="http://yoursite.com/2018/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/09/10/微服务入门/</id>
    <published>2018-09-09T16:00:00.000Z</published>
    <updated>2018-09-10T16:00:16.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务入门"><a href="#微服务入门" class="headerlink" title="微服务入门"></a>微服务入门</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>在单体应用架构开发模式时期经常会在合作开发和测试上线等环节出现问题,主要是开发人员较多,代码合并/打包/依赖等等的更新和疏忽导致.</p><p>服务化架构可以比较好的处理这个问题,小团队负责各自小型的单体应用服务,全自动方式部署,服务间调用通过HTTP API通讯等,服务可以使用不同语言和数据库等,一定程度的解耦</p><p>微服务架构与服务化架构相比:</p><ol><li>服务拆分粒度更细</li><li>服务独立部署</li><li>服务独立维护</li><li>服务治理能力要求高</li></ol><p>微服务架构的选择需要根据实际需求和开发团队能力的情况,否则容易挖坑自己跳,影响业务的稳定性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;微服务入门&quot;&gt;&lt;a href=&quot;#微服务入门&quot; class=&quot;headerlink&quot; title=&quot;微服务入门&quot;&gt;&lt;/a&gt;微服务入门&lt;/h2&gt;&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;
      
    
    </summary>
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker容器基础</title>
    <link href="http://yoursite.com/2018/09/05/Docker%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/05/Docker容器基础/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2018-09-05T15:53:42.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker容器基础"><a href="#Docker容器基础" class="headerlink" title="Docker容器基础"></a>Docker容器基础</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>先进的软件管理容器引擎,统一文件系统</p><p><strong>基本概念</strong></p><p><strong>镜像</strong> Image</p><p><strong>容器</strong> Container </p><p><strong>仓库</strong> Repository</p><p>数据卷</p><h3 id="2-结构"><a href="#2-结构" class="headerlink" title="2.结构"></a>2.结构</h3><p>镜像:相当于java中的<strong>类</strong></p><p>容器:相当于java中的<strong>对象</strong></p><p>仓库:相当于属于镜像的<strong>maven仓库</strong></p><p>数据卷: 容器间及本地共享资源等,可以快速引用</p><ol><li>镜像可以增删,配置环境/资源/等等所有静态内容,但是不能运行</li><li>容器则相当于镜像的实例,可以创建/使用/停止/删除/暂停等,一个镜像可以实例化无数的容器,容器间相互独立隔绝 </li><li>容器最好保持无状态,存储数据要独立于容器的数据卷等方式,这样容器消亡后,数据不会丢失. </li><li>仓库:存储镜像,每个镜像的每个版本都有自己的标签,可以通过标签来使用,和maven仓库同一概念 </li></ol><h3 id="3-操作原理"><a href="#3-操作原理" class="headerlink" title="3.操作原理"></a>3.操作原理</h3><p><strong>CLI :</strong>命令窗口</p><p><strong>RestAPI :</strong>Rest指令</p><p><strong>DockerServer :</strong>Docker守护线程,核心程序</p><p>在CLI中使用Rest指令,即可轻松操纵Docker,简单方便</p><h3 id="4-基本操作"><a href="#4-基本操作" class="headerlink" title="4.基本操作"></a>4.基本操作</h3><p>[创建/运行/停止/暂停/删除] </p><ul><li>docker create <image-id> 创建Container</image-id></li><li>docker start <container-id>运行Container</container-id></li><li>docker run <image-id> 创建并运行Container</image-id></li><li>docker stop <container-id> 停止Container</container-id></li><li>docker kill <container-id> 不友好的停止Container</container-id></li><li>docker pause <container-id> 暂停Container</container-id></li><li>docker rm <container-id> 删除Container(需要停止Container)</container-id></li><li>docker rmi <image-id> 删除Image镜像</image-id></li></ul><p>[创建镜像] </p><ul><li>docker commit <container-id>容器提交为镜像</container-id></li><li>docker build 构建镜像</li></ul><p>[查看]</p><ul><li>docker ps 查看所有运行中的Container</li><li>docker ps –a 查看所有Container(包含未运行)</li><li>docker images 查看所有顶级镜像(top-leve)</li><li>docker images –a 查看所有镜像</li></ul><p>[移植复制]</p><ul><li>docker save <image-id> 只对镜像生效,每一个层都保存了元数据,可以看到镜像历史版本</image-id></li><li>docker export <container-id> 排除元数据,创建一个tar文件,多层合一,没有历史版本</container-id></li><li>docker history <image-id> 查看镜像历史版本</image-id></li></ul><p>[???骚操作]</p><ul><li>docker exec <running-container-id> 在运行中的容器执行一个新进程</running-container-id></li><li>docker inspect <container-id> or <image-id> 提取镜像或容器最顶级的元数据</image-id></container-id></li></ul><h3 id="5-使用链接"><a href="#5-使用链接" class="headerlink" title="5.使用链接"></a>5.使用链接</h3><p>详细基础指令操作连接,配图</p><p><a href="http://dockone.io/article/783" target="_blank" rel="noopener">http://dockone.io/article/783</a></p><p>详细Docker指令文档,配每个指令详情</p><p><a href="http://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-command-manual.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker容器基础&quot;&gt;&lt;a href=&quot;#Docker容器基础&quot; class=&quot;headerlink&quot; title=&quot;Docker容器基础&quot;&gt;&lt;/a&gt;Docker容器基础&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka基础</title>
    <link href="http://yoursite.com/2018/09/05/kafka%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/05/kafka基础/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2018-09-05T16:02:14.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka基础"><a href="#Kafka基础" class="headerlink" title="Kafka基础"></a>Kafka基础</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>基于发布/订阅的消息系统(类似JMS特性,但设计实现却不同)</p><p>分布式/可分区/可复制/日志服务</p><p>官方文档↓</p><p><a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">http://kafka.apache.org/documentation.html</a></p><h3 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h3><h4 id="1-Messaging-常规消息"><a href="#1-Messaging-常规消息" class="headerlink" title="1.Messaging 常规消息"></a><strong>1.Messaging 常规消息</strong></h4><p>对于一些常规的消息系统,kafka是个不错的选择;partitons/replication和容错,可以使kafka具有良好的扩展性和性能优势.不过到目前为止,我们应该很清楚认识到,kafka并没有提供JMS中的”事务性””消息传输担保(消息确认机制)””消息分组”等企业级特性;kafka只能使用作为”常规”的消息系统,在一定程度上,尚未确保消息的发送与接收绝对可靠(比如,消息重发,消息发送丢失等)</p><h4 id="2-Websit-activity-tracking-网站活动追踪的最佳工具"><a href="#2-Websit-activity-tracking-网站活动追踪的最佳工具" class="headerlink" title="2.Websit activity tracking  网站活动追踪的最佳工具"></a><strong>2.Websit activity tracking  网站活动追踪的最佳工具</strong></h4><p>可以将网页/用户操作等信息发送到kafka中.并实时监控,或者离线统计分析等</p><h4 id="3-Log-Aggregation-日志收集中心"><a href="#3-Log-Aggregation-日志收集中心" class="headerlink" title="3.Log Aggregation 日志收集中心"></a><strong>3.</strong>Log Aggregation 日志收集中心</h4><p> kafka的特性决定它非常适合作为”日志收集中心”;application可以将操作日志”批量””异步”的发送到kafka集群中,而不是保存在本地或者DB中;kafka可以批量提交消息/压缩消息等,这对producer端而言,几乎感觉不到性能的开支.此时consumer端可以使hadoop等其他系统化的存储和分析系统.</p><h3 id="3-结构"><a href="#3-结构" class="headerlink" title="3.结构"></a>3.结构</h3><h4 id="producer-提供者"><a href="#producer-提供者" class="headerlink" title="producer:提供者"></a><strong>producer:提供者</strong></h4><p>将消息发布到Topic中,同时将决定该消息属于哪个Partition,比如基于”round-robin”方式或者通过其他的一些算法等.</p><h4 id="consumer-消费者"><a href="#consumer-消费者" class="headerlink" title="consumer:消费者"></a><strong>consumer:消费者</strong></h4><p>每个Consumer都属于一个Consumer Group;</p><p>Consumer Group中可以存在多个Consumer;</p><p>Topic中的一个消息,只会被Group中的一个Consumer订阅;</p><p>即:</p><ol><li>如果只有一个Consumer Group且组内有多个Consumer,那么相当于queue模式,消息会在group内负载均衡</li><li>如果有多个Consumer Group且组内只有一个Consumer,那么相当于topic模式,消息将会发布给所有Consumer</li></ol><p>注意,一个partition内部<strong>不允许并发</strong>,组内如果有多于partition的consumer存在,将会有接受不到消息的consumer</p><p>建议partition数量为Consumer的<strong>倍数</strong>,这样可以提高性能和合理负载</p><h4 id="topic-主题"><a href="#topic-主题" class="headerlink" title="topic:主题"></a><strong>topic:主题</strong></h4><p>逻辑上的概念,消息类别,物理上存在的是partition</p><h4 id="partition-区"><a href="#partition-区" class="headerlink" title="partition:区"></a><strong>partition:区</strong></h4><p>一个topic可以有多个partition区,每个partition都有存储xxx.log文件,</p><p>任何发布到此partition的消息都会append到log文件中,如</p><p>00000000000.log</p><p>00000000001.log</p><p>00000000002.log</p><p>每次的<strong>Record</strong>消息都拥有<strong>offset</strong>偏移量(下标) 0 ,1, 2, 3, 4…相对于partition内的<strong>有序队列</strong></p><h4 id="offset-偏移量"><a href="#offset-偏移量" class="headerlink" title="offset: 偏移量"></a><strong>offset: 偏移量</strong></h4><p>每个partition中消息的偏移量,partition间互不影响,kafka通过offset来使用,时间复杂度为O(1),效率飞铲高</p><h4 id="Record-消息"><a href="#Record-消息" class="headerlink" title="Record:消息"></a><strong>Record:消息</strong></h4><p>每一条消息都由Key/value和时间戳构成</p><h4 id="broker-Server"><a href="#broker-Server" class="headerlink" title="broker: Server"></a>broker: Server</h4><p>kafka和JMS不同的是,即使消息被消费,也不会立马消失,会根据broker中的日志配置,如配置了两天后删除,那么无论消息是否被消费,两天后都会被清除</p><h4 id="Distribution-分布"><a href="#Distribution-分布" class="headerlink" title="Distribution:分布"></a><strong>Distribution:分布</strong></h4><p>一个Topic可以有多个partition,每个partition都可以分配到集群的<strong>broker</strong>(负责partition读写操作)中,</p><p><strong>broker</strong>中可以配置partition备份个数(<strong>Replicated</strong>),来完成<strong>负载均衡/高可用</strong></p><h4 id="Replicated-备份"><a href="#Replicated-备份" class="headerlink" title="Replicated:备份"></a><strong>Replicated:备份</strong></h4><p>基于partition的备份,可以备份在多个Server中</p><h4 id="Guarantees-担保"><a href="#Guarantees-担保" class="headerlink" title="Guarantees:担保"></a><strong>Guarantees:担保</strong></h4><p>1.发送到partition中的消息,将会按照他接受的消息追加到日志中</p><p>2.对于消费者而言,消息的接受顺序和日志的追加顺序保持一致</p><p><strong>3.如果Topic中的 replicationfactor(复制因子) 为N ,那么允许N-1个实例失效(待深入)</strong></p><hr><p><strong>精华传送门,入门+原理+配置说明</strong></p><p><strong><a href="https://www.cnblogs.com/likehua/p/3999538.html" target="_blank" rel="noopener">https://www.cnblogs.com/likehua/p/3999538.html</a></strong></p><hr><h3 id="4-Java-服务器中的使用"><a href="#4-Java-服务器中的使用" class="headerlink" title="4.Java/服务器中的使用"></a>4.Java/服务器中的使用</h3><p>详细使用代码地址</p><p><a href="https://www.2cto.com/kf/201804/739331.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201804/739331.html</a></p><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><h5 id="4-1-Maven依赖"><a href="#4-1-Maven依赖" class="headerlink" title="4-1.Maven依赖"></a>4-1.Maven依赖</h5><h5 id="4-2-Producer"><a href="#4-2-Producer" class="headerlink" title="4.2.Producer"></a>4.2.Producer</h5><ol><li>Producer发布消息</li><li>producer拦截器</li><li>Producer自定义路由规则</li></ol><h5 id="4-3-Consumer"><a href="#4-3-Consumer" class="headerlink" title="4-3.Consumer"></a>4-3.Consumer</h5><ol><li>自动提交</li><li>手动提交</li><li>自定义Consumer拦截器</li><li>定义offset,提交回调方法</li></ol><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a><strong>服务器</strong></h4><ol><li>开启zookeeper（在安装目录下使用命令）</li><li>启动kafka（安装目录下使用命令）</li><li>创建topic</li><li>删除topic</li><li>查看topic名称列表</li><li>查看topic详情</li><li>创建Consumer</li><li>创建Producer</li><li>查询topic所有分区的offset值</li><li>查询kafka集群当前topic所有分区中的消息数目</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafka基础&quot;&gt;&lt;a href=&quot;#Kafka基础&quot; class=&quot;headerlink&quot; title=&quot;Kafka基础&quot;&gt;&lt;/a&gt;Kafka基础&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot整合篇</title>
    <link href="http://yoursite.com/2018/08/24/Spring%20boot%E6%95%B4%E5%90%88%E7%AF%87/"/>
    <id>http://yoursite.com/2018/08/24/Spring boot整合篇/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2018-08-24T15:41:25.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-boot整合篇"><a href="#Spring-boot整合篇" class="headerlink" title="Spring boot整合篇"></a>Spring boot整合篇</h2><p>[TOC]</p><h3 id="1-优秀传送门"><a href="#1-优秀传送门" class="headerlink" title="1.优秀传送门"></a>1.优秀传送门</h3><h4 id="1-1-第一章送给GitHub仓库-多种框架整合实战案例"><a href="#1-1-第一章送给GitHub仓库-多种框架整合实战案例" class="headerlink" title="1-1.第一章送给GitHub仓库,多种框架整合实战案例"></a>1-1.第一章送给GitHub仓库,多种框架整合实战案例</h4><p><a href="https://github.com/JeffLi1993/springboot-learning-example" target="_blank" rel="noopener">https://github.com/JeffLi1993/springboot-learning-example</a></p><hr><h3 id="公告"><a href="#公告" class="headerlink" title="公告"></a>公告</h3><p><strong>该套框架整合尽量以一个工程进行叠加演示,一般情况下后面的整合都包含前面的基础整合</strong></p><p>(上面 1 仓库实战是各个框架分离,可以参考学习)</p><hr><h3 id="2-基础整合搭建ZK-Dubbo"><a href="#2-基础整合搭建ZK-Dubbo" class="headerlink" title="2.基础整合搭建ZK/Dubbo"></a>2.基础整合搭建ZK/Dubbo</h3><p>Dubbo Spring Boot Starter 致力于简化 Dubbo 应用在 Spring Boot 环境中的开发，主要包括自动装配（Auto-Configure）、外部化配置（Externalized-Configuration）以及生产准备（Actuator） </p><p><strong>思路</strong></p><ol><li>在Spring boot中整合ZK/Dubbo,可以将ZK抽出来放在parent中,这样子模块只需要考虑dubbo的服务配置即可</li><li>利用强大的注解功能,运用Dubbo的@Service做服务端注解,@Reference做消费端注解,快速整合Springboot+ZK+Dubbo</li></ol><h4 id="2-1-基础搭建传送门"><a href="#2-1-基础搭建传送门" class="headerlink" title="2-1.基础搭建传送门"></a>2-1.基础搭建传送门</h4><p><a href="https://www.bysocket.com/?p=1681" target="_blank" rel="noopener">https://www.bysocket.com/?p=1681</a></p><h4 id="2-2-优秀开源项目"><a href="#2-2-优秀开源项目" class="headerlink" title="2-2.优秀开源项目"></a>2-2.优秀开源项目</h4><p><a href="https://github.com/dubbo/dubbo-spring-boot-project" target="_blank" rel="noopener">https://github.com/dubbo/dubbo-spring-boot-project</a> </p><p><em>Springboot</em> 多模块项目，整合了freemark,jsp,logback,mail,多数据源,mybatis,redis,docker,SSL等(待验证) </p><p><a href="https://github.com/dony15/springboot-dubbox" target="_blank" rel="noopener">https://github.com/dony15/springboot-dubbox</a></p><h4 id="2-3-配置详解"><a href="#2-3-配置详解" class="headerlink" title="2-3.配置详解"></a>2-3.配置详解</h4><p>application.properties  </p><p><strong>简单基础配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## Dubbo 服务提供者配置</span><br><span class="line">spring.dubbo.application.name=provider/consumer</span><br><span class="line">spring.dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">spring.dubbo.protocol.name=dubbo</span><br><span class="line">spring.dubbo.protocol.port=20880</span><br><span class="line">spring.dubbo.scan=org.spring.springboot.</span><br></pre></td></tr></table></figure><p>spring.dubbo.application.name 应用名称  </p><p>spring.dubbo.registry.address 注册中心地址  </p><p>spring.dubbo.protocol.name 协议名称 </p><p>spring.dubbo.protocol.port 协议端口  </p><p>spring.dubbo.scan dubbo 服务类包目录 </p><p><strong>详细配置清单</strong></p><p>#根据 starter 工程源码，可以看出 application.properties 对应的 Dubbo 配置类 DubboProperties 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;spring.dubbo&quot;)</span><br><span class="line"></span><br><span class="line">public class DubboProperties &#123;</span><br><span class="line"></span><br><span class="line">private String scan;</span><br><span class="line"></span><br><span class="line">private ApplicationConfig application;</span><br><span class="line"></span><br><span class="line">private RegistryConfig registry;</span><br><span class="line"></span><br><span class="line">private ProtocolConfig protocol;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括了扫描路径、应用配置类、注册中心配置类和服务协议类 所以具体常用配置下扫描包路径：指的是 Dubbo 服务注解的服务包路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">## Dubbo 配置</span><br><span class="line"></span><br><span class="line"># 扫描包路径</span><br><span class="line"></span><br><span class="line">spring.dubbo.scan=org.spring.springboot.dubbo</span><br><span class="line"></span><br><span class="line">应用配置类：关于 Dubbo 应用级别的配置</span><br><span class="line"></span><br><span class="line">## Dubbo 应用配置</span><br><span class="line"></span><br><span class="line"># 应用名称</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.name=xxx</span><br><span class="line"></span><br><span class="line"># 模块版本</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.version=xxx</span><br><span class="line"></span><br><span class="line"># 应用负责人</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.owner=xxx</span><br><span class="line"></span><br><span class="line"># 组织名(BU或部门)</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.organization=xxx</span><br><span class="line"></span><br><span class="line"># 分层</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.architecture=xxx</span><br><span class="line"></span><br><span class="line"># 环境，如：dev/test/run</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.environment=xxx</span><br><span class="line"></span><br><span class="line"># Java代码编译器</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.compiler=xxx</span><br><span class="line"></span><br><span class="line"># 日志输出方式</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.logger=xxx</span><br><span class="line"></span><br><span class="line"># 注册中心 0</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries[0].address=zookeeper:#127.0.0.1:2181=xxx</span><br><span class="line"></span><br><span class="line"># 注册中心 1</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries[1].address=zookeeper:#127.0.0.1:2181=xxx</span><br><span class="line"></span><br><span class="line"># 服务监控</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.monitor.address=xxx</span><br><span class="line"></span><br><span class="line">这里注意多个注册中心的配置方式。下面介绍单个注册中心的配置方式。 注册中心配置类：常用 ZooKeeper 作为注册中心进行服务注册。</span><br><span class="line"></span><br><span class="line">## Dubbo 注册中心配置类</span><br><span class="line"></span><br><span class="line"># 注册中心地址</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.address=xxx</span><br><span class="line"></span><br><span class="line"># 注册中心登录用户名</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.username=xxx</span><br><span class="line"></span><br><span class="line"># 注册中心登录密码</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.password=xxx</span><br><span class="line"></span><br><span class="line"># 注册中心缺省端口</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.port=xxx</span><br><span class="line"></span><br><span class="line"># 注册中心协议</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.protocol=xxx</span><br><span class="line"></span><br><span class="line"># 客户端实现</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.transporter=xxx</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.server=xxx</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.client=xxx</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.cluster=xxx</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.group=xxx</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.version=xxx</span><br><span class="line"></span><br><span class="line"># 注册中心请求超时时间(毫秒)</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.timeout=xxx</span><br><span class="line"></span><br><span class="line"># 注册中心会话超时时间(毫秒)</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.session=xxx</span><br><span class="line"></span><br><span class="line"># 动态注册中心列表存储文件</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.file=xxx</span><br><span class="line"></span><br><span class="line"># 停止时等候完成通知时间</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.wait=xxx</span><br><span class="line"></span><br><span class="line"># 启动时检查注册中心是否存在</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.check=xxx</span><br><span class="line"></span><br><span class="line"># 在该注册中心上注册是动态的还是静态的服务</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.dynamic=xxx</span><br><span class="line"></span><br><span class="line"># 在该注册中心上服务是否暴露</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.register=xxx</span><br><span class="line"></span><br><span class="line"># 在该注册中心上服务是否引用</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.registries.subscribe=xxx</span><br><span class="line"></span><br><span class="line">服务协议配置类：</span><br><span class="line"></span><br><span class="line">## Dubbo 服务协议配置</span><br><span class="line"></span><br><span class="line"># 服务协议</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.name=xxx</span><br><span class="line"></span><br><span class="line"># 服务IP地址(多网卡时使用)</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.host=xxx</span><br><span class="line"></span><br><span class="line"># 服务端口</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.port=xxx</span><br><span class="line"></span><br><span class="line"># 上下文路径</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.contextpath=xxx</span><br><span class="line"></span><br><span class="line"># 线程池类型</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.threadpool=xxx</span><br><span class="line"></span><br><span class="line"># 线程池大小(固定大小)</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.threads=xxx</span><br><span class="line"></span><br><span class="line"># IO线程池大小(固定大小)</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.iothreads=xxx</span><br><span class="line"></span><br><span class="line"># 线程池队列大小</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.queues=xxx</span><br><span class="line"></span><br><span class="line"># 最大接收连接数</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.accepts=xxx</span><br><span class="line"></span><br><span class="line"># 协议编码</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.codec=xxx</span><br><span class="line"></span><br><span class="line"># 序列化方式</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.serialization=xxx</span><br><span class="line"></span><br><span class="line"># 字符集</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.charset=xxx</span><br><span class="line"></span><br><span class="line"># 最大请求数据长度</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.payload=xxx</span><br><span class="line"></span><br><span class="line"># 缓存区大小</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.buffer=xxx</span><br><span class="line"></span><br><span class="line"># 心跳间隔</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.heartbeat=xxx</span><br><span class="line"></span><br><span class="line"># 访问日志</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.accesslog=xxx</span><br><span class="line"></span><br><span class="line"># 网络传输方式</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.transporter=xxx</span><br><span class="line"></span><br><span class="line"># 信息交换方式</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.exchanger=xxx</span><br><span class="line"></span><br><span class="line"># 信息线程模型派发方式</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.dispatcher=xxx</span><br><span class="line"></span><br><span class="line"># 对称网络组网方式</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.networker=xxx</span><br><span class="line"></span><br><span class="line"># 服务器端实现</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.server=xxx</span><br><span class="line"></span><br><span class="line"># 客户端实现</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.client=xxx</span><br><span class="line"></span><br><span class="line"># 支持的telnet命令，多个命令用逗号分隔</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.telnet=xxx</span><br><span class="line"></span><br><span class="line"># 命令行提示符</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.prompt=xxx</span><br><span class="line"></span><br><span class="line"># status检查</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.status=xxx</span><br><span class="line"></span><br><span class="line"># 是否注册</span><br><span class="line"></span><br><span class="line">spring.dubbo.application.protocol.status=xxx</span><br></pre></td></tr></table></figure><h4 id="2-4-Service-服务提供者常用配置"><a href="#2-4-Service-服务提供者常用配置" class="headerlink" title="2-4.@Service 服务提供者常用配置"></a>2-4.@Service 服务提供者常用配置</h4><p>常用 @Service 配置的如下</p><ul><li><p>version 版本</p></li><li><p>group 分组</p></li><li><p>provider 提供者</p></li><li><p>protocol 服务协议</p></li><li><p>monitor 服务监控</p></li><li><p>registry 服务注册</p></li><li><p>…</p></li></ul><h4 id="2-5-Reference-服务消费者常用配置"><a href="#2-5-Reference-服务消费者常用配置" class="headerlink" title="2-5.@Reference 服务消费者常用配置"></a>2-5.@Reference 服务消费者常用配置</h4><p>常用 @Reference 配置的如下</p><ul><li><p>version 版本</p></li><li><p>group 分组</p></li><li><p>timeout 消费者调用提供者的超时时间</p></li><li><p>consumer 服务消费者</p></li><li><p>monitor 服务监控</p></li><li><p>registry 服务注册</p></li></ul><h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2-6.总结"></a>2-6.总结</h4><h5 id="A-依赖问题"><a href="#A-依赖问题" class="headerlink" title="A) 依赖问题"></a>A) 依赖问题</h5><p>目前测试的是Spring boot整合的dubbo依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.dubbo.springboot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注意该依赖中存在了dubbo和zk所有依赖包,不需要额外的配置zk,<strong>否则会引起jar包冲突</strong>,选择时可以通过插件查看</p><p>注意提供者如果使用事务,那么需要导入AOP依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="B-配置问题"><a href="#B-配置问题" class="headerlink" title="B)配置问题"></a>B)配置问题</h5><p>注意ZK的注册地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ZK地址</span><br><span class="line">spring.dubbo.registry.address=zookeeper://www.dony15.com:2181</span><br></pre></td></tr></table></figure><p>注意服务包目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.dubbo.scan=com.dony15.service</span><br></pre></td></tr></table></figure><p>该目录的提供者和消费者并不需要一致,扫描的是本工程内对应的注解位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#服务包目录-提供者</span><br><span class="line">spring.dubbo.scan=com.dony15.service</span><br><span class="line"></span><br><span class="line">#服务包目录-消费者</span><br><span class="line">spring.dubbo.scan=com.dony15.dubbo</span><br></pre></td></tr></table></figure><h5 id="C-注解问题"><a href="#C-注解问题" class="headerlink" title="C)注解问题"></a>C)注解问题</h5><p>@Service(version = “1.0.0”)和@Reference(version = “1.0.0”)</p><p>版本号可以写也可以不写,但是这两个注解注意是dubbo包下,并非spring包</p><h5 id="D-解耦"><a href="#D-解耦" class="headerlink" title="D)解耦"></a>D)解耦</h5><p>可以将通用的接口和实体类抽离出来打成jar进行依赖,优点</p><ol><li>提高复用性</li><li>避免springboot的<strong>按需依赖原则</strong>造成的过多引用问题</li><li>如果不这样做,注解方式的引用需要在提供者和消费者都建立服务接口,降低dubbo的实用性(每次调用服务都需要将服务内容复制一遍)</li></ol><h5 id="E-注解篇代码奉上Spring-boot-Dubbo-ZK-JDBC-AOP-Mybatis-Restful"><a href="#E-注解篇代码奉上Spring-boot-Dubbo-ZK-JDBC-AOP-Mybatis-Restful" class="headerlink" title="E)注解篇代码奉上Spring boot+Dubbo+ZK+JDBC+AOP+Mybatis+Restful"></a>E)注解篇代码奉上Spring boot+Dubbo+ZK+JDBC+AOP+Mybatis+Restful</h5><p><a href="https://github.com/dony15/my_springboot_code" target="_blank" rel="noopener">https://github.com/dony15/my_springboot_code</a></p><p>### </p><hr><h3 id="3-整合Thymeleaf-Freemarker"><a href="#3-整合Thymeleaf-Freemarker" class="headerlink" title="3.整合Thymeleaf/Freemarker"></a>3.整合Thymeleaf/Freemarker</h3><h4 id="3-1-代码"><a href="#3-1-代码" class="headerlink" title="3-1.代码"></a>3-1.代码</h4><h5 id="注解篇代码奉上Thymeleaf-Freemarker-Spring-boot-Dubbo-ZK-JDBC-AOP-Mybatis-Restful"><a href="#注解篇代码奉上Thymeleaf-Freemarker-Spring-boot-Dubbo-ZK-JDBC-AOP-Mybatis-Restful" class="headerlink" title="注解篇代码奉上Thymeleaf+Freemarker+Spring boot+Dubbo+ZK+JDBC+AOP+Mybatis+Restful"></a>注解篇代码奉上Thymeleaf+Freemarker+Spring boot+Dubbo+ZK+JDBC+AOP+Mybatis+Restful</h5><p><a href="https://github.com/dony15/my_springboot_code/tree/master/springboot-dubbo-mybatis-freemarker-thymeleaf" target="_blank" rel="noopener">https://github.com/dony15/my_springboot_code/tree/master/springboot-dubbo-mybatis-freemarker-thymeleaf</a></p><h4 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3-2.配置文件"></a>3-2.配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#Themleaf配置</span><br><span class="line">spring.thymeleaf.content-type=text/html  </span><br><span class="line">spring.thymeleaf.mode =LEGACYHTML5</span><br><span class="line">#开发时关闭缓存,不然没法看到实时页面</span><br><span class="line">spring.thymeleaf.cache=false</span><br><span class="line"></span><br><span class="line">#配置静态资源路径</span><br><span class="line">spring.mvc.static-path-pattern=/static/**</span><br><span class="line"></span><br><span class="line">#DispatcherServlet 映射后缀(效果暂时没发现,并非伪静态技术)</span><br><span class="line">server.sevlet-path=*.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#freemarker模板</span><br><span class="line">spring.freemarker.allow-request-override=false</span><br><span class="line">spring.freemarker.cache=false</span><br><span class="line">spring.freemarker.check-template-location=true</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line">spring.freemarker.content-type=text/html</span><br><span class="line">spring.freemarker.expose-request-attributes=false</span><br><span class="line">spring.freemarker.expose-session-attributes=false</span><br><span class="line">spring.freemarker.expose-spring-macro-helpers=false</span><br></pre></td></tr></table></figure><h4 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3-3.总结"></a>3-3.总结</h4><p>Thymeleaf和Freemarker可以共存,当然语法有区别,根据实际业务选择吧,整合基本没有难点,有时间可以了解一下他们的配置文件都是啥意思,百度很多,不留了</p><h5 id="A-严谨问题"><a href="#A-严谨问题" class="headerlink" title="A)严谨问题"></a>A)严谨问题</h5><p>Thymeleaf对标签格式要求比较严谨,如果需要可以通过依赖jar进行自动补充(前段不一定写的很完整哦)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--ThymeLeaf代码补全--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.9.22&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="B-伪静态思路"><a href="#B-伪静态思路" class="headerlink" title="B)伪静态思路"></a>B)伪静态思路</h5><p>通过过滤器实现伪静态化,优化SEO,项目在不值得做大量静态页面时,可以使用</p><p>一时半会没整合好,就注释掉了,大概这个思路( • ̀ω•́ )✧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--伪静态化优化方案,未实现--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.tuckey&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;urlrewritefilter&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.0.4&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="C-依赖问题"><a href="#C-依赖问题" class="headerlink" title="C)依赖问题"></a>C)依赖问题</h5><p>Thymeleaf的依赖中已经存在spring-boot-starter-web的依赖</p><p>因此spring-boot-starter-web可以无情的去掉了</p><h5 id="D-FreemarkerUtil使用问题"><a href="#D-FreemarkerUtil使用问题" class="headerlink" title="D)FreemarkerUtil使用问题"></a>D)FreemarkerUtil使用问题</h5><p>注意目录,如果写错了很尴尬哦.中间环节取不到值会提示异常,表达式值为null</p><h5 id="E-前后端分离"><a href="#E-前后端分离" class="headerlink" title="E)前后端分离"></a>E)前后端分离</h5><p>如果你能参与项目的设计,那么通过/{page}进行较大程度的前后端分离,是个不错的点子哦,项目中有示例</p><hr><h3 id="4-整合-FastDFS-Nginx"><a href="#4-整合-FastDFS-Nginx" class="headerlink" title="4.整合 FastDFS+Nginx"></a>4.整合 FastDFS+Nginx</h3><p>本次整合会增加数据库字段,当然包括代码层的更新咯.url存图片来演示FastDFS功能</p><p>新增字段city_image存储url,演示是1张图,实际上在实体类中已经为多图扩展做了准备(数组切割)</p><h4 id="4-1-代码"><a href="#4-1-代码" class="headerlink" title="4-1.代码"></a>4-1.代码</h4><p><strong>Thymeleaf+Freemarker+Spring boot+Dubbo+ZK+JDBC+AOP+Mybatis+Restful+FastDFS+Nginx</strong></p><p><a href="https://github.com/dony15/my_springboot_code/tree/master/3springboot-fastDFS-Nginx" target="_blank" rel="noopener">https://github.com/dony15/my_springboot_code/tree/master/3springboot-fastDFS-Nginx</a></p><h4 id="4-2-配置文件"><a href="#4-2-配置文件" class="headerlink" title="4-2.配置文件"></a>4-2.配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracker_server=www.dony15.com:22122</span><br></pre></td></tr></table></figure><p><strong>不足</strong></p><p>Nginx地址没有提出来,开发时应该提出来通用的,方案有很多,放在配置文件或者指定类或接口都可以</p><p>都没有做太多限制,比如图片类型,大小等等.可以进行各种判断过滤,这里只演示基础的功能实现</p><p>FastDFS只演示了增加,还缺少删和改哦,可以自行百度</p><h4 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4-3.总结"></a>4-3.总结</h4><h5 id="A-前段问题"><a href="#A-前段问题" class="headerlink" title="A)前段问题"></a>A)前段问题</h5><p>这次演示没有使用富文本,可以更直接的去尝试细节(脑壳疼),</p><p>注意文件上传的类型,使用ajax的时候很容易前后不兼容,400或者406等</p><p>该方案是不依赖于form表单的ajax 详细见源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;input  type=<span class="string">"file"</span> alt=<span class="string">"插入图片"</span> id=<span class="string">"uploadFile"</span>name=<span class="string">"uploadFile"</span> /&gt;</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 图片上传</span></span><br><span class="line"><span class="comment">* 注意如果不加processData:false和contentType:false会报错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$(<span class="string">"#uploadFile"</span>).change(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> imageForm = <span class="keyword">new</span> FormData();</span><br><span class="line">        imageForm.append(<span class="string">"uploadFile"</span>, $(<span class="string">"#uploadFile"</span>).get(<span class="number">0</span>).files[<span class="number">0</span>]);</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">'POST'</span>,</span><br><span class="line">            url: <span class="string">"/insertImage"</span>,</span><br><span class="line">            data: imageForm,</span><br><span class="line">            processData: <span class="literal">false</span>,  <span class="comment">// 告诉jQuery不要去处理发送的数据</span></span><br><span class="line">            contentType: <span class="literal">false</span>,   <span class="comment">// 告诉jQuery不要去设置Content-Type请求头</span></span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">                <span class="keyword">if</span> (result.error==<span class="number">1</span>) &#123;</span><br><span class="line">                    alert(result.message)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    $(<span class="string">"#image_echo"</span>).attr(<span class="string">"src"</span>, result.url);</span><br><span class="line">                    $(<span class="string">"#cityImage"</span>).attr(<span class="string">"value"</span>, result.url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                alert(<span class="string">"上传失败"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="B-基础逻辑"><a href="#B-基础逻辑" class="headerlink" title="B)基础逻辑"></a>B)基础逻辑</h5><p>基础的逻辑,文件上传到FastDFS,通过回调获取URI</p><p>再和Nginx的地址拼接成完整的URL响应给前段</p><p>前段拿到响应的URL和其他数据一起存进数据库</p><h3 id="5-整合Redis"><a href="#5-整合Redis" class="headerlink" title="5.整合Redis"></a>5.整合Redis</h3><h4 id="5-1-代码"><a href="#5-1-代码" class="headerlink" title="5-1.代码"></a>5-1.代码</h4><p><strong>Thymeleaf+Freemarker+Spring boot+Dubbo+ZK+JDBC+AOP+Mybatis+Restful+FastDFS+Nginx+Redis</strong></p><p><a href="https://github.com/dony15/my_springboot_code/tree/master/springboot4-redis" target="_blank" rel="noopener">https://github.com/dony15/my_springboot_code/tree/master/springboot4-redis</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="A-依赖问题-1"><a href="#A-依赖问题-1" class="headerlink" title="A)依赖问题"></a>A)依赖问题</h5><p>注意redis需要和jackson一起,否则异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;functionDomainRedisTemplate&apos; defined in class path resource [com/dony15/config/RedisConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.data.redis.core.RedisTemplate]: Factory method &apos;functionDomainRedisTemplate&apos; threw exception; nested exception is java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/ObjectMapper</span><br></pre></td></tr></table></figure><p>我们可以看到这里的提示,缺少jacksion中的ObjectMapper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nested exception is java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/ObjectMapper</span><br></pre></td></tr></table></figure><p>因此依赖应该这样配套使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 整合redis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- jackson --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>当然,FastJSON也是需要的,主要用在处理业务的时候,选择怎么存的策略转换,比如List,Map,数组等的处理选择上</p><h5 id="B-配置-单机版"><a href="#B-配置-单机版" class="headerlink" title="B)配置-单机版"></a>B)配置-单机版</h5><p>Springboot整合redis,需要注意RedisTemplate的注入,通过配置类来实现</p><p>将RedisUtil注入封装RedisTemplate</p><p>调用RedisUtil通过自动装配或者@Resource注入即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#Redis</span><br><span class="line">#Matser的ip地址</span><br><span class="line">redis.host=www.dony15.com</span><br><span class="line">#端口号</span><br><span class="line">redis.port=6379</span><br><span class="line">#如果有密码</span><br><span class="line">redis.password=</span><br><span class="line">#客户端超时时间单位是毫秒 默认是2000</span><br><span class="line">redis.timeout=20000  </span><br><span class="line"></span><br><span class="line">#最大空闲数</span><br><span class="line">redis.maxIdle=300  </span><br><span class="line">#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal</span><br><span class="line">#redis.maxActive=600</span><br><span class="line">#控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性</span><br><span class="line">redis.maxTotal=1000  </span><br><span class="line">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span><br><span class="line">redis.maxWaitMillis=10000  </span><br><span class="line">#连接的最小空闲时间 默认1800000毫秒(30分钟)</span><br><span class="line">redis.minEvictableIdleTimeMillis=300000  </span><br><span class="line">#每次释放连接的最大数目,默认3</span><br><span class="line">redis.numTestsPerEvictionRun=1024  </span><br><span class="line">#逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span><br><span class="line">redis.timeBetweenEvictionRunsMillis=30000  </span><br><span class="line">#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span><br><span class="line">redis.testOnBorrow=true  </span><br><span class="line">#在空闲时检查有效性, 默认false</span><br><span class="line">redis.testWhileIdle=true</span><br></pre></td></tr></table></figure><hr><h3 id="6-整合Logback全局异常处理"><a href="#6-整合Logback全局异常处理" class="headerlink" title="6.整合Logback全局异常处理"></a>6.整合Logback全局异常处理</h3><p>个人理解目前Logback仍为主流的异常处理工具,但是配置<strong>细粒度</strong>较为麻烦,并且难以分析,对于中小项目比较实用;</p><p>对于长期的中大型soa项目,建议添加Cat检测,更加细粒度控制大部分细节,使用也相对简单方便,如:</p><ol><li>分布式细粒度实时监控</li><li>故障快速发现 </li><li>系统问题分析 </li><li>Cat报表展示消息类型  </li><li>Transaction  </li><li>Event  </li><li>Heartbeat  </li><li>Metric  </li><li>Trace  </li><li>各种埋点</li><li>丰富的模块警告通知/多种通知方式</li><li>…</li></ol><p>Cat待更新,在新篇章介绍</p><h4 id="6-1-代码"><a href="#6-1-代码" class="headerlink" title="6-1.代码"></a>6-1.代码</h4><p><strong>Thymeleaf+Freemarker+Spring boot+Dubbo+ZK+JDBC+AOP+Mybatis+Restful+FastDFS+Nginx+Redis+Logback</strong></p><p><a href="https://github.com/dony15/my_springboot_code/tree/master/springboot5-logback" target="_blank" rel="noopener">https://github.com/dony15/my_springboot_code/tree/master/springboot5-logback</a></p><h4 id="6-2-配置"><a href="#6-2-配置" class="headerlink" title="6-2.配置"></a>6-2.配置</h4><p><strong>A)、Logger、appender及layout</strong></p><p>Logger作为日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。</p><p>Appender主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、 PostreSQL、 Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。</p><p>Layout 负责把事件转换成字符串，格式化的日志信息的输出。</p><p><strong>B)、logger context</strong></p><p>各个logger 都被关联到一个 LoggerContext，LoggerContext负责制造logger，也负责以树结构排列各 logger。其他所有logger也通过org.slf4j.LoggerFactory 类的静态方法getLogger取得。 getLogger方法以 logger 名称为参数。用同一名字调用LoggerFactory.getLogger 方法所得到的永远都是同一个logger对象的引用。</p><p><strong>C)、有效级别及级别的继承</strong></p><p>Logger 可以被分配级别。级别包括：TRACE、DEBUG、INFO、WARN 和 ERROR，定义于 ch.qos.logback.classic.Level类。如果 logger没有被分配级别，那么它将从有被分配级别的最近的祖先那里继承级别。root logger 默认级别是 DEBUG。</p><p><strong>D)、打印方法与基本的选择规则</strong></p><p>打印方法决定记录请求的级别。例如，如果 L 是一个 logger 实例，那么，语句 L.info(“..”)是一条级别为 INFO 的记录语句。记录请求的级别在高于或等于其 logger 的有效级别时被称为被启用，否则，称为被禁用。记录请求级别为 p，其logger的有效级别为 q，只有则当 p&gt;=q时，该请求才会被执行。</p><p>该规则是 logback 的核心。级别排序为： <strong>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR</strong>。</p><p><strong>Logback默认配置的步骤</strong></p><p>(1). 尝试在 classpath 下查找文件 logback-test.xml；</p><p>(2). 如果文件不存在，则查找文件 logback.xml；</p><p>(3). 如果两个文件都不存在，logback 用 Bas icConfigurator 自动对自己进行配置，这会导致记录输出到控制台。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"D:/temp/log"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按照每天生成日志文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span>  <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件输出的文件名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文件保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文件最大的大小--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- show parameters for hibernate sql 专为 Hibernate 定制 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate.type.descriptor.sql.BasicBinder"</span>  <span class="attr">level</span>=<span class="string">"TRACE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate.type.descriptor.sql.BasicExtractor"</span>  <span class="attr">level</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate.SQL"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate.engine.QueryParameters"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.hibernate.engine.query.HQLQueryPlan"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--myibatis log configure--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.apache.ibatis"</span> <span class="attr">level</span>=<span class="string">"TRACE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Connection"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Statement"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.PreparedStatement"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志异步到数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"DB"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.db.DBAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志异步到数据库 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DriverManagerConnectionSource不支持DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">connectionSource</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.db.DriverManagerConnectionSource"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DataSourceConnectionSource支持DataSource,但是没整合上,这里有区别,使用时需要注意 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dataSource class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dataSource class="com.alibaba.druid.pool.DruidDataSource"&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">driverClass</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">driverClass</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span>root<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>68835230<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/dataSource&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">connectionSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;appender-ref ref="STDOUT" /&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"DB"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-3-建表语句"><a href="#6-3-建表语句" class="headerlink" title="6-3.建表语句"></a>6-3.建表语句</h4><p>如果输出到数据库,那么需要先建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> logging_event_property;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> logging_event_exception;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> logging_event;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> logging_event </span><br><span class="line">  (</span><br><span class="line">    timestmp         <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    formatted_message  <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    logger_name       <span class="built_in">VARCHAR</span>(<span class="number">254</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    level_string      <span class="built_in">VARCHAR</span>(<span class="number">254</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    thread_name       <span class="built_in">VARCHAR</span>(<span class="number">254</span>),</span><br><span class="line">    reference_flag    <span class="built_in">SMALLINT</span>,</span><br><span class="line">    arg0              <span class="built_in">VARCHAR</span>(<span class="number">254</span>),</span><br><span class="line">    arg1              <span class="built_in">VARCHAR</span>(<span class="number">254</span>),</span><br><span class="line">    arg2              <span class="built_in">VARCHAR</span>(<span class="number">254</span>),</span><br><span class="line">    arg3              <span class="built_in">VARCHAR</span>(<span class="number">254</span>),</span><br><span class="line">    caller_filename   <span class="built_in">VARCHAR</span>(<span class="number">254</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    caller_class      <span class="built_in">VARCHAR</span>(<span class="number">254</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    caller_method     <span class="built_in">VARCHAR</span>(<span class="number">254</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    caller_line       <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    event_id          <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> logging_event_property</span><br><span class="line">  (</span><br><span class="line">    event_id       <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    mapped_key        <span class="built_in">VARCHAR</span>(<span class="number">254</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    mapped_value      <span class="built_in">TEXT</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(event_id, mapped_key),</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (event_id) <span class="keyword">REFERENCES</span> logging_event(event_id)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> logging_event_exception</span><br><span class="line">  (</span><br><span class="line">    event_id         <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    i                <span class="built_in">SMALLINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    trace_line       <span class="built_in">VARCHAR</span>(<span class="number">254</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(event_id, i),</span><br><span class="line">    FOREIGN <span class="keyword">KEY</span> (event_id) <span class="keyword">REFERENCES</span> logging_event(event_id)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h4 id="6-5-加入全局异常处理器即可使用"><a href="#6-5-加入全局异常处理器即可使用" class="headerlink" title="6-5.加入全局异常处理器即可使用"></a>6-5.加入全局异常处理器即可使用</h4><p>这里整合了ajax请求(需要ajax请求工具类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dony15.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.dony15.utils.AjaxResponse;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一的错误处理页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.error(ex.getMessage(),ex);</span><br><span class="line">        <span class="comment">//ajax 请求</span></span><br><span class="line">        <span class="keyword">if</span> (request.getHeader(<span class="string">"x-requested-with"</span>) != <span class="keyword">null</span> &amp;&amp; request.getHeader(<span class="string">"x-requested-with"</span>).equalsIgnoreCase(<span class="string">"XMLHttpRequest"</span>)) &#123; <span class="comment">//如果是ajax请求响应头会有x-requested-with</span></span><br><span class="line">            AjaxResponse ajaxResponse = <span class="keyword">new</span> AjaxResponse();</span><br><span class="line">            ajaxResponse.setThrowable(ex);</span><br><span class="line">            response.reset();</span><br><span class="line">            response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out = response.getWriter();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                logger.error(e.getMessage(),e);</span><br><span class="line">            &#125;</span><br><span class="line">            out.print(JSON.toJSONString(ajaxResponse));</span><br><span class="line">            out.flush();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//非ajax请求跳转登陆页</span></span><br><span class="line"></span><br><span class="line">            ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">            Cookie[] cookies = request.getCookies();</span><br><span class="line">            <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"debug"</span>.equals(cookies[i].getName())) &#123;</span><br><span class="line">                        StackTraceElement[] stackTraces = ex.getStackTrace();</span><br><span class="line"></span><br><span class="line">                        StringBuilder stackTraceStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                        stackTraceStr.append(ex.toString())</span><br><span class="line">                                .append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; stackTraces.length; j++) &#123;</span><br><span class="line">                            stackTraceStr.append(stackTraces[j].toString())</span><br><span class="line">                                    .append(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        mv.getModel().put(<span class="string">"stackTraces"</span>, stackTraceStr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mv.setViewName(<span class="string">"error.html"</span>);</span><br><span class="line">            <span class="keyword">return</span> mv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6-6.总结"></a>6-6.总结</h4><h5 id="A-依赖"><a href="#A-依赖" class="headerlink" title="A)依赖"></a>A)依赖</h5><p>依赖没有问题,spring-boot默认首先支持logback,不需要引入,详细关系可以查看关系图</p><h5 id="B-配置"><a href="#B-配置" class="headerlink" title="B)配置"></a>B)配置</h5><p>配置中需要注意的是,如果输出到数据库,那么除了配置文件外,需要在数据库中建好表哦</p><p>测试logback-test.xml </p><p>生产logback.xml</p><hr><h3 id="7-整合Quartz"><a href="#7-整合Quartz" class="headerlink" title="7.整合Quartz"></a>7.整合Quartz</h3><h4 id="7-1-配置组成"><a href="#7-1-配置组成" class="headerlink" title="7-1.配置组成"></a>7-1.配置组成</h4><p>以下为<strong>Spring boot</strong> 方式的配置,不依赖于任何配置文件</p><ol><li>JobFactory   配置类:Job注入到Spring中管理,否则无法与Spring中的Bean交互</li><li>QuartzConfig 配置类:Schedulder注入到Spring中管理</li><li>QuartzManager 工具管理类:封装调用Quartz的方法,如添加/修改/删除/查看</li><li>SelectCityJob Job类:任务类,处理业务逻辑的地方</li></ol><p>注意此处配置的注入,实际上是将<strong>Job和Schedulder的工厂</strong>交给<strong>Spring管理</strong>,<br>因为<strong>Quartz本身具有自己的容器</strong>,而自身的容器和Spring的容器互相没有关联,导致Bean无法沟通</p><p><strong>可参考该文章:</strong></p><p><a href="https://blog.csdn.net/xiaobuding007/article/details/80455187" target="_blank" rel="noopener">https://blog.csdn.net/xiaobuding007/article/details/80455187</a></p><p><strong>①个人仓库中代码集成演示:</strong><br><a href="https://github.com/dony15/my_springboot_code/tree/master/springboot6-quartz%20X" target="_blank" rel="noopener">https://github.com/dony15/my_springboot_code/tree/master/springboot6-quartz%20X</a><br>该演示是单独Quartz的集成,特意打穿MVC架构使用,问题和理解↓↓↓</p><h4 id="7-2-原理"><a href="#7-2-原理" class="headerlink" title="7-2.原理"></a>7-2.原理</h4><p><strong>假设: 我们需要通过CMS界面来定时执行某个任务</strong></p><p><strong>①</strong>中的集成实际上存在问题,首先我们知道Quartz底层调用<code>Object.wait()</code>方法来阻塞实现</p><p>那么使用Quartz就必须异步实现,否则将会影响程序的正常运行</p><p>该演示中的集成恰好没有实现异步,我们一起来看后果是什么:</p><p>首先:如果我们在Controller调用Job的方法,那么会抛出TimeOut超时,其实很容易理解,</p><p>Object.wait()阻塞下是拿不到返回值的,该方法执行一段时间后,因为Controller中的请求本身有设定超时时间,</p><p>时间到了自然<strong>超时</strong>(防止死锁和同步的问题,spring本身的优化方案)</p><p>超时情况下,我们的Quartz实际上是生效了的,而且会生效两次,这是SpringMVC本身的机制,超时时仍然会刷新该方法</p><p>这个时候的Quartz会被再次执行,导致一个无关紧要的异常提示:<strong>该job已经存在</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCityByName</span><span class="params">(String cityName)</span> </span>&#123;</span><br><span class="line">            Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            params.put(<span class="string">"cityName"</span>, cityName);</span><br><span class="line">            <span class="comment">//try..catch省略</span></span><br><span class="line">            quartzManager.addJob(<span class="string">"getCityN"</span>, <span class="string">"cityJ"</span>,</span><br><span class="line">                    <span class="string">"getCityT"</span>, <span class="string">"cityT"</span>,</span><br><span class="line">                    SelectCityJob.class, <span class="string">"0/3 * * * * ?"</span>, params);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"SUCCESS"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解决这两个问题我进行了如下尝试</p><ol><li>不调用需要返回值</li><li>提前进行任务判断</li><li>(Job中设置@DisallowConcurrentExecution 禁止并发)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初次解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCityByName</span><span class="params">(String cityName)</span> </span>&#123;</span><br><span class="line">       Boolean exists = quartzManager.notExists(<span class="string">"getCityT"</span>, <span class="string">"cityT"</span>);</span><br><span class="line">           Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           params.put(<span class="string">"cityName"</span>, cityName);</span><br><span class="line">       <span class="keyword">if</span> (!exists)&#123;</span><br><span class="line">           <span class="comment">//如果存在该任务,那么不操作</span></span><br><span class="line">           System.out.println(<span class="string">"存在该任务哦,可以尝试移除"</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//如果不存在,那么创建该任务</span></span><br><span class="line">           quartzManager.addJob(<span class="string">"getCityN"</span>, <span class="string">"cityJ"</span>,</span><br><span class="line">                   <span class="string">"getCityT"</span>, <span class="string">"cityT"</span>,</span><br><span class="line">                   SelectCityJob.class, <span class="string">"0/3 * * * * ?"</span>, params);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实际上该方案只能解决第二个异常提示:<strong>该job已存在</strong></p><p>对于<strong>SpringMVC</strong>超时问题仍然无法解决,那么问题的根源又回到了一开始,为什么Quartz要使用异步来处理</p><p>我们知道SpringMVC本身有一套完善的请求流程(13步),但是我们在handler中的业务操作同步阻塞,</p><p>导致后续的流程需要超时后才能执行</p><p>虽然以上两个异常提示都不会终止程序,也不会终止业务的实现,但是等待超时的时间和毫无意义的异常仍然不利于我们的开发</p><p>同理,在此代码中,<strong>Quartz和dubbo</strong>也会发生同步超时的状态</p><p>因此,我们可以<strong>重新屡一下</strong></p><p>我们需要定时做些事情–&gt;选择定时框架Quartz(扔进大后方)–&gt;Controller难以做到异步通知(X)–&gt;选择MQ消息队列通知(√)–&gt;完美ヾ(ﾟ∀ﾟゞ)</p><h4 id="7-3-正确代码使用"><a href="#7-3-正确代码使用" class="headerlink" title="7-3.正确代码使用"></a>7-3.正确代码使用</h4><p><strong>修改后的完整代码</strong></p><p><strong>Thymeleaf+Freemarker+Spring boot+Dubbo+ZK+JDBC+AOP+Mybatis+Restful+FastDFS+Nginx+Redis+Logback+Quartz+ActiveMQ</strong></p><p><a href="https://github.com/dony15/my_springboot_code/tree/master/springboot7-quartz%20%E2%88%9A-ActiveMQ" target="_blank" rel="noopener">https://github.com/dony15/my_springboot_code/tree/master/springboot7-quartz%20%E2%88%9A-ActiveMQ</a> </p><p><strong>加入MQ</strong></p><p>ActiveMQ</p><p>注意:序列化的对象不可以直接用来做ActiveMQ的消息,需要添加配置允许</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.packages.trust-all=true   //允许所有</span><br><span class="line">    </span><br><span class="line">此处百度  //允许指定序列化类</span><br><span class="line">    详细可参考ActiveMQ文章</span><br></pre></td></tr></table></figure><p><strong>核心:</strong></p><ol><li>ActiveMQ配置文件</li><li>ActiveProvider</li><li>ActiveConsumer</li></ol><h4 id="7-4-结合数据库"><a href="#7-4-结合数据库" class="headerlink" title="7-4.结合数据库"></a>7-4.结合数据库</h4><p>本次数据库结合并非持久化MQ消息,只是持久化Quartz的任务</p><p>假装结合一下,剩下的就是普通的业务逻辑了,说明书代替就好</p><p><img src="https://i.imgur.com/7Ta6HZq.jpg" alt=""></p><h4 id="7-5-ActiveMQ消息持久化到数据库"><a href="#7-5-ActiveMQ消息持久化到数据库" class="headerlink" title="7-5.ActiveMQ消息持久化到数据库"></a>7-5.ActiveMQ消息持久化到数据库</h4><p><a href="http://topmanopensource.iteye.com/blog/1066383" target="_blank" rel="noopener">http://topmanopensource.iteye.com/blog/1066383</a></p><h4 id="7-6-RocketMQ"><a href="#7-6-RocketMQ" class="headerlink" title="7-6.RocketMQ"></a>7-6.RocketMQ</h4><p>资源传送门</p><p><a href="https://blog.csdn.net/zhangll_2008/article/details/78657177" target="_blank" rel="noopener">https://blog.csdn.net/zhangll_2008/article/details/78657177</a></p><p>在MQ文章中记录个人总结</p><p><a href="https://dony15.github.io/2018/08/24/MQ%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%90%E7%94%A8/" target="_blank" rel="noopener">https://dony15.github.io/2018/08/24/MQ%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%90%E7%94%A8/</a></p><h4 id="7-7-整合Quartz总结"><a href="#7-7-整合Quartz总结" class="headerlink" title="7-7.整合Quartz总结"></a>7-7.整合Quartz总结</h4><h5 id="A-结构问题"><a href="#A-结构问题" class="headerlink" title="A)结构问题"></a>A)结构问题</h5><p>注意其本身需要异步实现,否则基本上会出现超时问题</p><p>本身具有自己的容器,该容器与Spring容器无关,需要配置注入到Spring管理,才能使用Spring中的bean</p><h5 id="B-位置"><a href="#B-位置" class="headerlink" title="B)位置"></a>B)位置</h5><p>建议放在大后方,还是异步处理的问题,最好不要与其他框架同步</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-boot整合篇&quot;&gt;&lt;a href=&quot;#Spring-boot整合篇&quot; class=&quot;headerlink&quot; title=&quot;Spring boot整合篇&quot;&gt;&lt;/a&gt;Spring boot整合篇&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-优秀
      
    
    </summary>
    
      <category term="Spring全家桶" scheme="http://yoursite.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>MQ基础与运用</title>
    <link href="http://yoursite.com/2018/08/24/MQ%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%90%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/24/MQ基础与运用/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2018-08-24T15:36:06.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ基础与运用"><a href="#MQ基础与运用" class="headerlink" title="MQ基础与运用"></a>MQ基础与运用</h1><p>[TOC]</p><h2 id="一-MQ原理"><a href="#一-MQ原理" class="headerlink" title="一.MQ原理"></a>一.MQ原理</h2><p>待整理</p><h2 id="二-ActiveMQ部分"><a href="#二-ActiveMQ部分" class="headerlink" title="二.ActiveMQ部分"></a>二.ActiveMQ部分</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>消息队列:<strong>即时消息通信</strong>和<strong>延时消息通信</strong></p><p>MQ 是一个<strong>消息中间件</strong>,常见的消息中间件有 <strong>ActiveMQ | RabbitMQ | kafka</strong></p><p>ActiveMQ底层基于java的JMS实现,在没有JMS之前的系统存在很多缺陷:</p><ol><li>前后端同步问题,如果后台没有响应,则前段会一直阻塞等待</li><li>前后端生命周期耦合性太强,一方崩了则另一方也会崩</li><li>点对点通信,前段一次只能发送给某一个单独的服务对象,无法群发</li></ol><p><strong>JMS:</strong> (Java Message Service ) 通过消息中间件(MOM：Message Oriented Middleware )</p><p>将消息发送给单独的消息服务器中,消息服务器会将消息存放在若干的队列/主题中,在合适的时候将消息发送给接收者.<strong>发送和接收是异步的,无需阻塞等待</strong> 在pub/sub的模式下,可以将消息发送给多个接收者</p><p><strong>JMS类中定义了java访问中间件的接口,除此之外都是异常定义</strong></p><ol><li>Provider/MessageProvider：生产者 </li><li>Consumer/MessageConsumer：消费者 </li><li>PTP：Point To Point，点对点通信消息模型 </li><li>Pub/Sub：Publish/Subscribe，发布订阅消息模型 </li><li><strong>Queue</strong>：队列，目标类型之一，和PTP结合 </li><li><strong>Topic</strong>：主题，目标类型之一，和Pub/Sub结合 </li><li>ConnectionFactory：连接工厂，JMS用它创建连接 </li><li>Connnection：JMS Client到JMS Provider的连接 </li><li>Destination：消息目的地，由Session创建 </li><li><strong>Session</strong>：会话，由Connection创建，实质上就是发送、接受消息的一个线程，因此生产者、消费者都是Session创建的 </li></ol><h4 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h4><p><strong>| 异步处理 | 应用解耦 | 流量削锋 | 消息通讯 |</strong></p><p><strong>详情参考:<a href="https://blog.csdn.net/kingcat666/article/details/78660535" target="_blank" rel="noopener">https://blog.csdn.net/kingcat666/article/details/78660535</a></strong></p><h4 id="3-消息模式"><a href="#3-消息模式" class="headerlink" title="3.消息模式"></a>3.消息模式</h4><ul><li><strong>P2P模式(点对点)</strong> Queue</li><li><strong>Pub/Sub模式(发布订阅)</strong> Topic</li><li><strong>Push模式(推拉模式,消息更新C/S中)</strong></li></ul><p><img src="https://i.imgur.com/1YQjxG6.png" alt=""></p><p><strong>Topic根据业务需求,也可以持久化</strong></p><p>客户端启动时设置一个ClientID作为编号在服务器注册</p><p>可以将消息一致保存在服务器(可以持久化)</p><p><strong>环境搭建文件中存放该操作方法</strong></p><h4 id="4-五种不同的消息正文格式"><a href="#4-五种不同的消息正文格式" class="headerlink" title="4.五种不同的消息正文格式"></a>4.五种不同的消息正文格式</h4><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><ul><li>　　StreamMessage – Java原始值的数据流</li><li>　　MapMessage–一套名称-值对</li><li>　　TextMessage–一个字符串对象(常用)</li><li>　　ObjectMessage–一个序列化的 Java对象</li><li>　　BytesMessage–一个字节的数据流</li></ul><h4 id="5-java中与Solr结合"><a href="#5-java中与Solr结合" class="headerlink" title="5.java中与Solr结合"></a>5.java中与Solr结合</h4><p>搭建..(省略)</p><p><strong>注意：</strong>如果ActiveMQ整合spring使用不要使用activemq-all-5.12.0.jar包。</p><p>(5.12.0中许多包和spring相同,而且少方法,坑)</p><p><strong>建议使用5.11.2</strong></p><p>进入管理后台：</p><ul><li><a href="http://www.fzs.com:8161/admin/" target="_blank" rel="noopener">http://www.fzs.com:8161/admin/</a></li><li>用户名：admin</li><li>密码：admin</li></ul><p><img src="https://i.imgur.com/RgH5SGA.png" alt=""></p><h5 id="5-1-JMS规范下使用套路-基础原理"><a href="#5-1-JMS规范下使用套路-基础原理" class="headerlink" title="5-1.JMS规范下使用套路 基础原理"></a>5-1.JMS规范下使用套路 基础原理</h5><p><strong>导包</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>提供方</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建工厂对象ConnectionFactory,需要指定IP和端口</span></span><br><span class="line">      ConnectionFactory connectionFactory= <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://www.fzs.com:61616"</span>);</span><br><span class="line">      <span class="comment">//2.使用工厂对象创建Connection连接对象</span></span><br><span class="line">      Connection connection=connectionFactory.createConnection();</span><br><span class="line">      <span class="comment">//3.开启连接,调用Connection对象的start方法</span></span><br><span class="line">      connection.start();</span><br><span class="line">      <span class="comment">//4.创建Session对象</span></span><br><span class="line">      <span class="comment">//(两个参数,|1.是否开启分布式事务(少,一般不开),如果开启,第二个参数无意义 | 2.应答模式(自动/手动)一般自动)</span></span><br><span class="line">      Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">      <span class="comment">//5.使用Session创建目的模式Destination (queue(点对点)|topic(广播一对多))</span></span><br><span class="line">      Queue queue = session.createQueue(<span class="string">"DonY15_ActiveMQ_Message"</span>);</span><br><span class="line">      <span class="comment">//6.使用Session创建生产者Producer</span></span><br><span class="line">      MessageProducer producer = session.createProducer(queue);</span><br><span class="line">      <span class="comment">//7.创建Message对象(一般textMessage)</span></span><br><span class="line">      TextMessage textMessage = session.createTextMessage(<span class="string">"发出命令:全军粗鸡!✧*｡٩(ˊᗜˋ*)و✧*｡"</span>);</span><br><span class="line">      <span class="comment">//8.发送消息(Message放到Producer)</span></span><br><span class="line">      producer.send(textMessage);</span><br><span class="line">      <span class="comment">//9.关闭资源(Producer|Session|Connection)</span></span><br><span class="line">       producer.close();</span><br><span class="line">       session.close();</span><br><span class="line">       connection.close();</span><br></pre></td></tr></table></figure><p><strong>接收方</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建工厂对象ConnectionFactory连接MQ服务器</span></span><br><span class="line">ConnectionFactory connectionFactory=<span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://www.fzs.com:61616"</span>);</span><br><span class="line"><span class="comment">//2.使用工厂对象创建Connection连接对象</span></span><br><span class="line">Connection connection=connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.开启连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.创建Session</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.使用Session创建目的模式Destination (queue(点对点)|topic(广播一对多))</span></span><br><span class="line">Queue queue = session.createQueue(<span class="string">"DonY15_ActiveMQ_Message"</span>);</span><br><span class="line"><span class="comment">//6.使用Session创建消费者对象</span></span><br><span class="line">MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"><span class="comment">//7.接收消息(监听)</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line"><span class="comment">//8.打印结果</span></span><br><span class="line">        TextMessage textMessage= (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String text = textMessage.getText();</span><br><span class="line">            System.out.println(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//9.等待接收消息</span></span><br><span class="line">System.in.read();</span><br><span class="line"><span class="comment">//9.关闭连接</span></span><br><span class="line">consumer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MQ基础与运用&quot;&gt;&lt;a href=&quot;#MQ基础与运用&quot; class=&quot;headerlink&quot; title=&quot;MQ基础与运用&quot;&gt;&lt;/a&gt;MQ基础与运用&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一-MQ原理&quot;&gt;&lt;a href=&quot;#一-MQ原理&quot; class=
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Cat监控基础使用</title>
    <link href="http://yoursite.com/2018/08/23/Cat%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/23/Cat基础使用/</id>
    <published>2018-08-22T16:00:00.000Z</published>
    <updated>2018-08-23T13:59:08.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cat监控基础使用"><a href="#Cat监控基础使用" class="headerlink" title="Cat监控基础使用"></a>Cat监控基础使用</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>基于Java开发的实时应用监控平台，提供了全面的监控服务和业务决策支持。 </p><h4 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1-1.作用"></a>1-1.作用</h4><p>故障快速发现:主要面向运维，让运维直观到生产环境出现的问题；<br>系统问题分析：面向开发，让开发能了解自己系统实时运行状态、发现问题。<br>分布式追踪</p><h4 id="1-2-CAT报表展示消息类型"><a href="#1-2-CAT报表展示消息类型" class="headerlink" title="1-2.CAT报表展示消息类型"></a>1-2.CAT报表展示消息类型</h4><p><strong>Transaction</strong> 适合记录跨越系统边界的程序访问行为,比如远程调用，数据库调用，也适合执行时间较长的业务逻辑监控，Transaction用来记录一段代码的<strong>执行时间</strong>和<strong>次数</strong>。</p><p><strong>Event</strong> 用来记录一件事发生的次数，比如<strong>记录系统异常</strong>，它和transaction相比<strong>缺少了时间的统计</strong>，开销比transaction要<strong>小</strong>。 </p><p><strong>Heartbeat</strong> 表示程序内定期产生的统计信息, 如CPU%, MEM%, 连接池状态, 系统负载等。 </p><p><strong>Metric</strong> 用于记录业务指标、指标可能包含对一个指标记录次数、记录平均值、记录总和，业务指标<strong>最低统计粒度为1分钟</strong>。 </p><p><strong>Trace</strong> 用于记录基本的trace信息，类似于log4j的info信息，这些信息仅用于查看一些相关信息。</p><h4 id="1-3-CAT架构图"><a href="#1-3-CAT架构图" class="headerlink" title="1-3.CAT架构图"></a>1-3.CAT架构图</h4><p><img src="https://i.imgur.com/xO0meHh.png" alt=""></p><p>追求简单、去中心化、分工协作，两层结构，除了依赖外部存储如HDFS和MySQL外，不依赖其他系统，CAT内部全面采用组件化设计和实现。CAT每天消息量巨大，一台机器是不能处理全部流量，必须分片处理，均衡负载。<br>业务应用目前使用CAT API进行埋点，后台异步线程采用TCP长连接方式，将消息源源不断地传输到后台服务器；CAT具有fail-over(故障切换)机制，在后台服务器不可用时会自动切换到另一台可用服务器。CAT目前使用native协议做序列化和反序列化，将来会考虑支持更多协议，比如thrift。</p><h4 id="1-4-消息处理"><a href="#1-4-消息处理" class="headerlink" title="1-4.消息处理"></a>1-4.消息处理</h4><p>消息处理分五个阶段：收集、传输、分析、存储和展示。</p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>GitHub–&gt;Cat master 安装代码/mvnrepo 依赖jar包(Copy到maven库中)<br><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">https://github.com/dianping/cat</a><br>搭建教程有很多,如<br><a href="https://my.oschina.net/fuxingCoder/blog/750639" target="_blank" rel="noopener">https://my.oschina.net/fuxingCoder/blog/750639</a><br><strong>注意下载master中也有搭建教程,较为详细</strong></p><h3 id="3-AOP埋点"><a href="#3-AOP埋点" class="headerlink" title="3.AOP埋点"></a>3.AOP埋点</h3><p>master中整合了框架埋点方案<br>如dubbo/logback/mybatis/aop/url等等,说明书相当完善,自行参考</p><p>CAT以上完整分析<br><a href="https://blog.csdn.net/tankun940507994/article/details/56672385/" target="_blank" rel="noopener">https://blog.csdn.net/tankun940507994/article/details/56672385/</a></p><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h3><h4 id="4-1-设置Cat配置文件"><a href="#4-1-设置Cat配置文件" class="headerlink" title="4-1.设置Cat配置文件"></a>4-1.设置Cat配置文件</h4><p>主要是对client.xml/server.xml/datasources.xml进行配置,如果使用公司现成的则该步已经搭建完成,无需配置 </p><h4 id="4-2-引入master打包生成的jar包"><a href="#4-2-引入master打包生成的jar包" class="headerlink" title="4-2.引入master打包生成的jar包"></a>4-2.引入master打包生成的jar包</h4><p>客户端和核心jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--cat实时监控--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cat-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;&lt;!--根据自己打包的版本号进行修改--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.dianping.cat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cat-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="4-3-配置Cat过滤器"><a href="#4-3-配置Cat过滤器" class="headerlink" title="4-3.配置Cat过滤器"></a>4-3.配置Cat过滤器</h4><p>这是整合Springboot的配置方案,如果是普通整合,只需要web.xml中添加servlet过滤器即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.dony15.controller;</span><br><span class="line"></span><br><span class="line">import com.dianping.cat.servlet.CatFilter;</span><br><span class="line">import com.dony15.exception.ExceptionHandler;</span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.DispatcherType;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by ying on 2017/1/16.</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class WebMvcConfigurer extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) &#123;</span><br><span class="line">        exceptionResolvers.add(new ExceptionHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * cat 过滤器</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean catFilterRegistrationBeanConfig()&#123;</span><br><span class="line">        FilterRegistrationBean registrationBean = new FilterRegistrationBean();</span><br><span class="line">        registrationBean.setFilter(new CatFilter());</span><br><span class="line">        registrationBean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">        registrationBean.setDispatcherTypes(DispatcherType.FORWARD, DispatcherType.REQUEST);</span><br><span class="line">        registrationBean.setName(&quot;catFilter&quot;);</span><br><span class="line"></span><br><span class="line">        return  registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 一种增加心跳的方式 也可以用controller来做</span><br><span class="line">     * @param registry</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers( ViewControllerRegistry registry ) &#123;</span><br><span class="line">        registry.addViewController( &quot;/heartBeat&quot; ).setStatusCode(HttpStatus.OK);</span><br><span class="line">        registry.setOrder( Ordered.HIGHEST_PRECEDENCE );</span><br><span class="line">        super.addViewControllers( registry );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-resources中添加配置"><a href="#4-5-resources中添加配置" class="headerlink" title="4-5.resources中添加配置"></a>4-5.resources中添加配置</h4><p>新建META-INF/app.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.name=demo01</span><br></pre></td></tr></table></figure><p>配好的cat,使用相当简单,<strong>引入jar包</strong>,<strong>添加过滤</strong>,<strong>添加一行app.name配置</strong>即可完成基础操作  </p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>需要将script配置文件放入/data/appdatas/cat中  也可以使用脚本中的一键安装script中(未测) </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cat监控基础使用&quot;&gt;&lt;a href=&quot;#Cat监控基础使用&quot; class=&quot;headerlink&quot; title=&quot;Cat监控基础使用&quot;&gt;&lt;/a&gt;Cat监控基础使用&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; cl
      
    
    </summary>
    
      <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基础操作文档</title>
    <link href="http://yoursite.com/2018/08/08/Linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/08/08/Linux基础操作/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2018-08-08T11:05:09.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux基础操作文档"><a href="#Linux基础操作文档" class="headerlink" title="Linux基础操作文档"></a>Linux基础操作文档</h2><p>[TOC]</p><h3 id="1-User操作"><a href="#1-User操作" class="headerlink" title="1.User操作"></a>1.User操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo(Superuser do) 超级用户操作</span><br><span class="line">passwd 修改密码</span><br><span class="line">chgrp(Change group) 改变用户组</span><br><span class="line">ps(Process Status)进程状态</span><br></pre></td></tr></table></figure><h3 id="2-文件-端口系统的增删改查"><a href="#2-文件-端口系统的增删改查" class="headerlink" title="2.文件/端口系统的增删改查"></a>2.文件/端口系统的增删改查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//增</span><br><span class="line">mkdir/mkdirs 创建文件夹/指定路径文件夹</span><br><span class="line">vim 创建/打开指定文件</span><br><span class="line">tar(解压) -zxvf(每个字母都有意义) 压缩包名字.tar.gz结尾</span><br><span class="line"></span><br><span class="line">//删</span><br><span class="line">rm </span><br><span class="line">umount(Unmount) 卸载</span><br><span class="line">rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; </span><br><span class="line">rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; </span><br><span class="line">rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 </span><br><span class="line">rm -rf dir1 dir2 同时删除两个目录及它们的内容 </span><br><span class="line"></span><br><span class="line">//改</span><br><span class="line">cp 拷贝粘贴</span><br><span class="line">mv xxx  xxx 移动/重命名</span><br><span class="line"></span><br><span class="line">//****查****</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[普通查看]</span><br><span class="line">cd 查看各种目录</span><br><span class="line">ls(list) 查看当前文件夹</span><br><span class="line">cat 查看文件内容</span><br><span class="line">pwd 当前文件夹全路径</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[动态查看文本]</span><br><span class="line">tail -2 file1 查看一个文件的最后两行 </span><br><span class="line">tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[查看内存]</span><br><span class="line">cat /proc/meminfo 查看详细内存使用情况</span><br><span class="line"> free -h    快速查询内存使用(单位自动换算)</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">[核心组成]</span><br><span class="line">/etc 存放配置文件的地方.配置文件目录</span><br><span class="line">/dev(DEVices)  设备</span><br><span class="line">/usr = Unix Shared Resources 共享资源</span><br></pre></td></tr></table></figure><h3 id="3-文本操作"><a href="#3-文本操作" class="headerlink" title="3.文本操作"></a>3.文本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i 进入insert状态</span><br><span class="line">esc 进入文本操作</span><br><span class="line">:0 光标回到第一行</span><br><span class="line">:$光标回到最后一行</span><br><span class="line">/dsf 搜索dsf这个字符串</span><br><span class="line">:u 撤销,相当于ctrl+Z</span><br><span class="line">:q 退出</span><br><span class="line">:wq 保存并退出</span><br><span class="line">注意:断电时需要删除临时文件.xxx.swp</span><br></pre></td></tr></table></figure><h3 id="4-网络操作"><a href="#4-网络操作" class="headerlink" title="4.网络操作"></a>4.网络操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 测试ping值</span><br><span class="line">ifconfig 查看网关地址等</span><br></pre></td></tr></table></figure><h3 id="5-端口及PID查询"><a href="#5-端口及PID查询" class="headerlink" title="5.端口及PID查询"></a>5.端口及PID查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span><br><span class="line">[查看进程]</span><br><span class="line"># ps -aux|grep java      //显示所有进程名中包含java字符串的进程</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">[查看端口]</span><br><span class="line">netstat -t 显示TCP协议的连接情况。</span><br><span class="line">netstat -u 显示UDP协议的连接情况。</span><br><span class="line">netstat -tln 查看linux的端口使用情况</span><br><span class="line">netstat -aln|grep 8080 查看8080端口占用情况</span><br></pre></td></tr></table></figure><h3 id="6-软件管理"><a href="#6-软件管理" class="headerlink" title="6.软件管理"></a>6.软件管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.源码安装：</span><br><span class="line">tar -zxvf filename.tar.gz 解压</span><br><span class="line">make 编译</span><br><span class="line">make install  安装</span><br><span class="line">make clean  清除1</span><br><span class="line">make distclean 清除2</span><br><span class="line"></span><br><span class="line">2.rpm(二进制包)安装：</span><br><span class="line">(安装本地自己下载的rpm软件包，自己解决软件之间的依赖。)</span><br><span class="line"> rpm -ivh xxx.rpm 安装</span><br><span class="line"> rpm -Uvh xxx.rpm 升级</span><br><span class="line">/**</span><br><span class="line"> 一般用不到</span><br><span class="line"> rpm -e xxx.rpm 反安装</span><br><span class="line"> rpm -qpi xxx.rpm 查询软件包的详细信息</span><br><span class="line"> rpm -qf xxx.rpm 查询某个文件是属于那个rpm包</span><br><span class="line">  rpm -qpl xxx.rpm 查该软件包会向系统里面写入哪些文件</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">3.yum安装：</span><br><span class="line">(在线安装，可以解决依赖问题。)</span><br><span class="line"> 通过yum安装的php，是不需要手动配置环境变量的。配置文件目录在/etc/php.ini</span><br><span class="line"> 通过yum安装的apache2，配置文件目录在/etc/httpd/conf/</span><br><span class="line"> rm -f /etc/httpd/conf.d/welcome.conf /var/www/error/noindex.html #删除默认测试页</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">[关闭]</span><br><span class="line"></span><br><span class="line">kill 进程号 正常关闭 (正常建议使用此命令)</span><br><span class="line">kill -9 进程号  强制关闭  (暴力关闭)</span><br></pre></td></tr></table></figure><h3 id="7-开发软件操作"><a href="#7-开发软件操作" class="headerlink" title="7.开发软件操作"></a>7.开发软件操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/sshd start 启动sshd服务器</span><br><span class="line">ps -ef|grep (服务名)如redis  服务查询(通用)</span><br><span class="line">tomcat</span><br><span class="line">    service tomcat stop 停止</span><br><span class="line">service tomcat start 启动</span><br><span class="line">    tail -f logs/catalina.out 卡特琳娜日志查询 在tomcat根目录下查看</span><br><span class="line"></span><br><span class="line">http://www.dony15.com:8080/dubbo-admin-2.8.4/governance/services  查看dubbo服务管理</span><br><span class="line"></span><br><span class="line">mysql</span><br><span class="line">    service mysql stop 停止</span><br><span class="line">service mysql start 启动</span><br><span class="line"></span><br><span class="line">zookeeper(目录)</span><br><span class="line">./zkServer.sh start 启动</span><br><span class="line">./zkServer.sh status 查看状态</span><br><span class="line">./zkServer.sh stop 停止</span><br><span class="line"></span><br><span class="line">redis(目录)</span><br><span class="line">    ./redis-server redis.conf 启动</span><br><span class="line">    ./redis-cli  -p 6379  连接</span><br><span class="line">    ./bin/redis-cli -p 7001 shutdown 停止</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis集群(目录)</span><br><span class="line">    ./start-cluster.sh 启动</span><br><span class="line">    ./stop-cluster.sh  停止</span><br><span class="line">    ./redis-cli -h 127.0.0.1 -p 7001 -c -a 123456    远程连接(密码可删)</span><br><span class="line">    ./redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001    追加节点(需要注意步骤较多)</span><br><span class="line">    ./redis-trib.rb del-node 127.0.0.1:7001 a06a54ab354327cd9920fa8b14a7b8b71a4d445a    删除</span><br><span class="line">redis哨兵</span><br><span class="line">     ???</span><br><span class="line"></span><br><span class="line">tracker</span><br><span class="line">    /usr/local/software/fastdfs-master/init.d/fdfs_trackerd start 启动</span><br><span class="line">    ps -ef | grep fdfs_trackerd 查看状态</span><br><span class="line">storage</span><br><span class="line">     /usr/local/software/fastdfs-master/init.d/fdfs_storaged start 启动</span><br><span class="line">    ps -ef | grep fdfs_storaged 查看状态</span><br><span class="line"></span><br><span class="line">nginx</span><br><span class="line">    nginx    启动</span><br><span class="line">    nginx -s stop 停止</span><br><span class="line">    nginx -s reload 重新启动</span><br><span class="line"></span><br><span class="line">activeMQ</span><br><span class="line">    ./activemq start  启动(bin目录下)</span><br><span class="line">    ./activemq stop   停止</span><br><span class="line">    ./activemq status 查看状态</span><br><span class="line">    访问服务器的8161端口</span><br><span class="line">    http://www.vm.com:8161/admin/</span><br><span class="line">    用户名密码都是admin</span><br></pre></td></tr></table></figure><h3 id="8-redis集群内部指令"><a href="#8-redis集群内部指令" class="headerlink" title="8.redis集群内部指令"></a>8.redis集群内部指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看</span><br><span class="line">info replication 查看节点信息</span><br><span class="line">quit  退出</span><br></pre></td></tr></table></figure><h3 id="9-防火墙设置-端口"><a href="#9-防火墙设置-端口" class="headerlink" title="9.防火墙设置(端口)"></a>9.防火墙设置(端口)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用iptables开放如下端口</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">保存</span><br><span class="line">/etc/rc.d/init.d/iptables save</span><br><span class="line">重启服务</span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><h3 id="10-服务器备用url"><a href="#10-服务器备用url" class="headerlink" title="10.服务器备用url"></a>10.服务器备用url</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[solor]</span><br><span class="line">http://www.fzs.com:8080/solr/admin.html</span><br><span class="line"></span><br><span class="line">[dubbo]</span><br><span class="line">http://www.fzs.com:8080/dubbo-admin/    u:root    p:root</span><br><span class="line"></span><br><span class="line">[activeMQ]</span><br><span class="line">http://www.fzs.com:8161/admin/index.jsp    u:admin    p:admin</span><br></pre></td></tr></table></figure><h3 id="11-Linux连接问题解决"><a href="#11-Linux连接问题解决" class="headerlink" title="11.Linux连接问题解决"></a>11.Linux连接问题解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Xshell问题*</span><br><span class="line">/etc/init.d/sshd start 启动sshd服务器</span><br><span class="line">/etc/init.d/iptables stop 关闭防火墙</span><br><span class="line"></span><br><span class="line">配置hosts</span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">mysql远程连接失败问题*</span><br><span class="line">use mysql; </span><br><span class="line">UPDATE user SET Password=PASSWORD(&apos;123456&apos;) where USER=&apos;root&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="End-各种软件-框架连接问题"><a href="#End-各种软件-框架连接问题" class="headerlink" title="End.各种软件/框架连接问题"></a>End.各种软件/框架连接问题</h3><h4 id="1-MySQL连接问题"><a href="#1-MySQL连接问题" class="headerlink" title="1.MySQL连接问题"></a>1.MySQL连接问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">MySQL远程访问问题(搭配上面):授权法。</span><br><span class="line"></span><br><span class="line">例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;%&apos; IDENTIFIED BY &apos;mypassword&apos; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">FLUSH   PRIVILEGES;</span><br><span class="line"></span><br><span class="line">如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器，并使用mypassword作为密码</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;192.168.1.3&apos; IDENTIFIED BY &apos;mypassword&apos; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">FLUSH   PRIVILEGES;</span><br><span class="line"></span><br><span class="line">如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器的dk数据库，并使用mypassword作为密码</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON dk.* TO &apos;myuser&apos;@&apos;192.168.1.3&apos; IDENTIFIED BY &apos;mypassword&apos; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">FLUSH   PRIVILEGES;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">我用的第一个方法,最后执行一个语句 mysql&gt;FLUSH RIVILEGES 使修改生效.就可以了</span><br><span class="line"></span><br><span class="line">另外一种方法,不过我没有亲自试过的,在csdn.net上找的,可以看一下.</span><br><span class="line"></span><br><span class="line">在安装mysql的机器上运行：</span><br><span class="line"></span><br><span class="line">1、d:/mysql/bin/&gt;mysql   -h   localhost   -u   root  //这样应该可以进入MySQL服务器</span><br><span class="line"></span><br><span class="line">2、mysql&gt;GRANT   ALL   PRIVILEGES   ON   *.*   TO   &apos;root&apos;@&apos;%&apos;   WITH   GRANT   OPTION  //赋予任何主机访问数据的权限</span><br><span class="line"></span><br><span class="line">3、mysql&gt;FLUSH   PRIVILEGES  //修改生效</span><br><span class="line"></span><br><span class="line">4、mysql&gt;EXIT  //退出MySQL服务器</span><br><span class="line"></span><br><span class="line">这样就可以在其它任何的主机上以root身份登录啦！</span><br><span class="line"></span><br><span class="line">来源： https://blog.csdn.net/zyj405569395/article/details/53614356</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux基础操作文档&quot;&gt;&lt;a href=&quot;#Linux基础操作文档&quot; class=&quot;headerlink&quot; title=&quot;Linux基础操作文档&quot;&gt;&lt;/a&gt;Linux基础操作文档&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-User操作&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Linux基础" scheme="http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>IDE基础-Eclipse</title>
    <link href="http://yoursite.com/2018/08/08/IDE%E5%9F%BA%E7%A1%80-Eclipse/"/>
    <id>http://yoursite.com/2018/08/08/IDE基础-Eclipse/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2018-08-08T13:31:01.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IDE基础"><a href="#IDE基础" class="headerlink" title="IDE基础"></a>IDE基础</h2><p>[TOC]</p><h3 id="1-一楼送给自己"><a href="#1-一楼送给自己" class="headerlink" title="1.一楼送给自己"></a>1.一楼送给自己</h3><p>用习惯IDEA,很长时间没有使用Eclipse了,马上换工作可能又要用回Eclipse,写一篇回归文档,重新巩固一下Eclipse的基础使用,简单粗暴,新手不宜观看        ಠ_ಠ我有一个特异功能！！(Maven+基础快捷键篇)</p><h3 id="2-Maven搭建"><a href="#2-Maven搭建" class="headerlink" title="2.Maven搭建"></a>2.Maven搭建</h3><p><strong>注意开始选择简单maven,否则建出来的项目包可能不完整,主要是jre可能不会自动识别,导致message问题不显示</strong></p><p>本次maven搭建是简单的粗粒度模块切分,主要是熟悉<strong>parent继承</strong>和<strong>聚合项目</strong>在Eclipse中的搭建方式和<strong>BUG坑</strong></p><h4 id="2-1-从首选项导入Maven"><a href="#2-1-从首选项导入Maven" class="headerlink" title="2-1.从首选项导入Maven"></a>2-1.从首选项导入Maven</h4><p><img src="https://i.imgur.com/tRcpLJ5.png" alt=""></p><h4 id="2-2-Maven配置"><a href="#2-2-Maven配置" class="headerlink" title="2-2.Maven配置"></a>2-2.Maven配置</h4><p><img src="https://i.imgur.com/HWKL3sw.png" alt=""></p><h4 id="2-3-搭建Server服务器软件"><a href="#2-3-搭建Server服务器软件" class="headerlink" title="2-3.搭建Server服务器软件"></a>2-3.搭建Server服务器软件</h4><p><img src="https://i.imgur.com/Uad0d58.png" alt=""></p><p>服务器软件可以这样搭<strong>↑↑↑</strong>,但是实际中我们建议使用maven的<strong>tomcat插件↓↓↓</strong>来使用(模块较多时效果更好)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在聚合pom工程配置tomcat插件统一启动即可(减少其他模块频繁打包) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-新建Maven工程-parent"><a href="#2-4-新建Maven工程-parent" class="headerlink" title="2-4.新建Maven工程(parent)"></a>2-4.新建Maven工程(parent)</h4><p>(pom)</p><p><img src="https://i.imgur.com/BrsYk8C.png" alt=""></p><h4 id="2-4-parent配置"><a href="#2-4-parent配置" class="headerlink" title="2-4.parent配置"></a>2-4.parent配置</h4><p> (pom)</p><p><img src="https://i.imgur.com/hg3GCVr.png" alt=""><br><img src="https://i.imgur.com/zw9BVzW.png" alt=""></p><h4 id="2-5-common配置"><a href="#2-5-common配置" class="headerlink" title="2-5.common配置"></a>2-5.common配置</h4><p> (jar)</p><p><img src="https://i.imgur.com/U4vDRHB.png" alt=""></p><h4 id="2-6-mvc聚合配置"><a href="#2-6-mvc聚合配置" class="headerlink" title="2-6.mvc聚合配置"></a>2-6.mvc聚合配置</h4><p> (pom) 此处三层架构没有拆解,统一扔到聚合里了,正常可以将模块拆分</p><p><img src="https://i.imgur.com/e5LwXCn.png" alt=""></p><p>注意聚合中的模块大多数会用到common中的工具类或者实体类,这里的pom文件需要依赖common,后面不在提示依赖关系(根据业务逻辑进行依赖jar和模块即可)<br><img src="https://i.imgur.com/oqIeNNn.png" alt=""></p><h4 id="2-7-聚合模块pojo"><a href="#2-7-聚合模块pojo" class="headerlink" title="2-7.聚合模块pojo"></a>2-7.聚合模块pojo</h4><p>(jar)</p><p><img src="https://i.imgur.com/xlEmr3c.png" alt=""><br><img src="https://i.imgur.com/KrG76Qj.png" alt=""><br><img src="https://i.imgur.com/aAuNUhA.png" alt=""></p><h4 id="2-8-聚合模块dao-省略-service"><a href="#2-8-聚合模块dao-省略-service" class="headerlink" title="2-8.聚合模块dao(省略)/service"></a>2-8.聚合模块dao(省略)/service</h4><p>(jar)</p><p><img src="https://i.imgur.com/jsLF0jT.png" alt=""></p><h4 id="2-9-聚合模块controller"><a href="#2-9-聚合模块controller" class="headerlink" title="2-9.聚合模块controller"></a>2-9.聚合模块controller</h4><p>(war)</p><p><img src="https://i.imgur.com/03pqII2.png" alt=""></p><p>注意问题:此时webapp为空(因为选择的基本maven)</p><p><img src="https://i.imgur.com/4VZXkAC.png" alt=""></p><p>右键war模块,选择JavaEE工具重新部署(点一下就行了),webapp将会注入内容(web-inf等)</p><p><img src="https://i.imgur.com/lX1VfJa.png" alt=""></p><h4 id="2-10-聚合结构完成"><a href="#2-10-聚合结构完成" class="headerlink" title="2-10.聚合结构完成"></a>2-10.聚合结构完成</h4><p><img src="https://i.imgur.com/1yxPu4f.png" alt=""></p><h4 id="2-end-总结"><a href="#2-end-总结" class="headerlink" title="2-end.总结"></a>2-end.总结</h4><p>Eclipse的maven搭建并不是很复杂,主要是用习惯了IDEA后,经常会忘记Eclipse搭建的坑,比如</p><ol><li>建立的模块少包(没有选简单maven模板,jre没有注入)</li><li>建立的模块少webapp资源(还是bug,解决方案很多)</li><li>合理的选择打包方式(打pom,src中存在的是site(别紧张,没啥用))</li></ol><p>建议全部项目都以简单Maven模板的方式搭建,区别在于打包方式的不同pom/jar/war</p><h3 id="3-基础快捷键"><a href="#3-基础快捷键" class="headerlink" title="3.基础快捷键"></a>3.基础快捷键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[核心快捷键]</span><br><span class="line">Alt+/  代码助手/单词补全</span><br><span class="line">Ctrl+1 快速修正</span><br><span class="line">Shift+F2 打开外部Java文档</span><br><span class="line">Ctrl+Shift+O 快速导包/清理无效包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------(**查看**)----------------</span><br><span class="line">Ctrl+H 搜索对话框</span><br><span class="line">Ctrl+O 快速Outline结构显示</span><br><span class="line">全局 查找并替换 Ctrl+F </span><br><span class="line">Ctrl+e 快速切换编辑页面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------(**Alt修改代码**)----------------</span><br><span class="line">Ctrl+D 删除行</span><br><span class="line">Alt+Up/Down 上下移动选中行</span><br><span class="line">Ctrl+Alt+↑/↓ 复制当前行到上/下一行(复制增加)</span><br><span class="line">Alt+← 前一个编辑的页面</span><br><span class="line">Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line">Ctrl+Shift+F 格式化当前代码</span><br><span class="line">Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------</span><br><span class="line">Ctrl+Shift+S 保存所有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------[辅助使用]-----------------------------------</span><br><span class="line">Ctrl+Shift+X/Y 改变大小写</span><br><span class="line">Alt+Shift+T 显示重构菜单</span><br><span class="line">Ctrl+P 全局打印</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------[Debug辅助]-----------------------------------</span><br><span class="line">F5：Step Into（debug）</span><br><span class="line">F6：Step over（debug）</span><br><span class="line">F7：Step return（debug）</span><br><span class="line">F8：Resume（debug）</span><br><span class="line">F11：debug上一个应用（debug）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IDE基础&quot;&gt;&lt;a href=&quot;#IDE基础&quot; class=&quot;headerlink&quot; title=&quot;IDE基础&quot;&gt;&lt;/a&gt;IDE基础&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-一楼送给自己&quot;&gt;&lt;a href=&quot;#1-一楼送给自己&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
  </entry>
  
  <entry>
    <title>volatile基础</title>
    <link href="http://yoursite.com/2018/08/05/volatile%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/08/05/volatile基础/</id>
    <published>2018-08-04T16:00:00.000Z</published>
    <updated>2018-08-08T11:14:26.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile基础"><a href="#volatile基础" class="headerlink" title="volatile基础"></a>volatile基础</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p><strong>A.</strong>轻量级同步机制,与synchronized重量级锁不同,不会引起线程的上下文切换,但是需要注意两个问题:</p><ol><li>复合类操作无法同步 如 <strong>count++</strong></li><li>在其他变量的不变式中包含则无法同步 如<strong>常量和条件</strong>(后续再深入理解不变式)</li></ol><p><strong>B.</strong>阻止指令重排</p><h3 id="2-内存可见性"><a href="#2-内存可见性" class="headerlink" title="2.内存可见性"></a>2.内存可见性</h3><p>volatile是轻量级的同步机制,相比于synchronized重量级锁来说 ,能够节省更大的消耗,虽然在总体能力上不如synchronized安全,但是在一定场合也具有自己的优势,合理的利用volatile能够让程序更高效的运行</p><p>volatile修饰的属性对整个内存来说是可见的,即:每个线程获取到的该数据都是最新的(此处内存分配属逻辑模拟)</p><ul><li>A线程(工作内存)→<pre><code>} 主内存空间 </code></pre></li><li>B线程(工作内存)→</li></ul><p>对线程来说,正常的共享资源会从主内存中copy到自己的工作内存中,这里如同内存和硬盘的区别,可以更加快速的使用copy的资源,但是此时的工作内存对于其他线程是不可见的,因此很容易因为并发产生数据异常</p><p>当使用volatile时,该共享资源每次更新都会被同步到主内存空间中,对于其他线程来说,该数据始终是最新的,因此可以一定程度的解决并发的问题,但是有一些情况volatile无法直接实现,如<strong>非复合类操作</strong></p><h3 id="3-解决count-原子性问题"><a href="#3-解决count-原子性问题" class="headerlink" title="3.解决count++原子性问题"></a>3.解决count++原子性问题</h3><p>count++之类的非符合类操作,volatile无法保证他的原子性问题,使共享资源无法实时同步,进而引发并发问题</p><p>复合类操作过程:</p><ol><li>读取</li><li>运算</li><li>赋值</li></ol><p>因为volatile本身只是轻量级的同步机制,并非锁机制,当复合类操作的过程中可能有其他线程继续操作该资源,从而导致并发问题</p><p><strong>解决:循环CAS 方案(待研究)</strong></p><h3 id="4-阻止指令重排"><a href="#4-阻止指令重排" class="headerlink" title="4.阻止指令重排"></a>4.阻止指令重排</h3><p>指令重排是java优化程序性能的一种手段(提供并行度),但是重排也有一定的规则:</p><p>指令重排不会对<strong>存在依赖关系</strong>的数据进行操作</p><p>​    如a=1;b=a</p><p>指令重排不会对单线程下的结果进行操作</p><p>​    如a=1;b=2;c=a+b;</p><p>被volatile修饰的变量,在编译时,会插入内存屏障来阻止处理器等对数据的指令重排,阻止指令重排规则:</p><ol><li>第一个是volatile读操作时,无论第二个是什么操作,都会阻止指令重排</li><li>第二个是volatile写操作时,无论第一个是什么操作,都会阻止指令重排</li><li>第一个是volatile写操作,得个是volatile读操作时,都会阻止指令重排</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;volatile基础&quot;&gt;&lt;a href=&quot;#volatile基础&quot; class=&quot;headerlink&quot; title=&quot;volatile基础&quot;&gt;&lt;/a&gt;volatile基础&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念
      
    
    </summary>
    
      <category term="SE基础" scheme="http://yoursite.com/categories/SE%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud基础使用</title>
    <link href="http://yoursite.com/2018/07/20/Spring%20Cloud%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/20/Spring Cloud基础使用/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2018-07-24T10:34:11.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Cloud基础使用"><a href="#Spring-Cloud基础使用" class="headerlink" title="Spring Cloud基础使用"></a>Spring Cloud基础使用</h2><p>[TOC]</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><h4 id="1-1-什么是微服务"><a href="#1-1-什么是微服务" class="headerlink" title="1-1.什么是微服务?"></a>1-1.什么是微服务?</h4><p>微服务英文名称Micro service，<strong>Micro service架构模式</strong>就是将整个Web应用组织为<strong>一系列小的Web服务</strong>。</p><p>这些小的Web服务可以<strong>独立地编译及部署，并通过各自暴露的API接口相互通讯</strong>。</p><p>它们彼此相互协作，作为一个整体为用户提供功能，却可以<strong>独立地进行扩展</strong>。 </p><h4 id="1-2-微服务架构需要的功能或使用场景"><a href="#1-2-微服务架构需要的功能或使用场景" class="headerlink" title="1-2.微服务架构需要的功能或使用场景"></a>1-2.微服务架构需要的功能或使用场景</h4><ul><li>将整个系统根据业务逻辑拆分为多个子系统</li><li>每个子服务器可以部署多个应用,应用之间使用负载均衡</li></ul><ol><li>需要一个服务注册中心,所有的应用都在注册中心注册,负载均衡也在注册中心通过策略实现</li><li>所有的客户端都通过同一个网关地址访问后台的服务，通过路由配置，网关来判断一个URL请求由哪个服务处理。请求转发到服务上的时候也使用负载均衡。 </li><li>服务之间有时候也需要相互访问。例如有一个用户模块，其他服务在处理一些业务的时候，要获取用户服务的用户数据。 </li><li>需要一个断路器，及时处理服务调用时的超时和错误，防止由于其中一个服务的问题而导致整体系统的瘫痪。 </li><li>还需要一个监控功能，监控每个服务调用花费的时间等。 </li></ol><p>  目前主流的微服务框架：Dubbo、 SpringCloud、thrift、Hessian等，目前国内的中小企业用的大多数都是Dubbo，SpringCloud </p><h4 id="1-3-Spring-Colud概念"><a href="#1-3-Spring-Colud概念" class="headerlink" title="1-3.Spring Colud概念"></a>1-3.Spring Colud概念</h4><p>　springCloud是<strong>基于SpringBoot</strong>的一整套实现微服务的框架。</p><p>他提供了微服务开发所需的</p><p><strong>配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理</strong>等组件。</p><p>最重要的是，</p><p>  跟spring boot框架一起使用的话，会让你开发微服务架构的云服务非常好的方便。</p><h3 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h3><p><img src="https://i.imgur.com/SSZ7cM9.jpg" alt=""></p><h4 id="2-1-Spring-cloud子项目包括"><a href="#2-1-Spring-cloud子项目包括" class="headerlink" title="2-1.Spring cloud子项目包括"></a><strong>2-1.Spring cloud子项目包括</strong></h4><p> <strong>Spring Cloud Config</strong>：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。 </p><p><strong>Spring Cloud Bus</strong>：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。 </p><p><strong>Spring Cloud Netflix</strong>：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。 </p><p><strong>Netflix Eureka</strong>：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。 </p><p><strong>Netflix Hystrix</strong>：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。 </p><p><strong>Netflix Zuul</strong>：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。 </p><p><strong>Netflix Archaius</strong>：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。 </p><p><strong>Spring Cloud for Cloud Foundry</strong>：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。 </p><p><strong>Spring Cloud Sleuth</strong>：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。 </p><p><strong>Spring Cloud Data Flow</strong>：大数据操作工具，通过命令行方式操作数据流。 </p><p><strong>Spring Cloud Security</strong>：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。 </p><p><strong>Spring Cloud Consul</strong>：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。 </p><p><strong>Spring Cloud Zookeeper</strong>：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。 </p><p><strong>Spring Cloud Stream</strong>：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。 </p><p><strong>Spring Cloud CLI</strong>：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。 </p><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h3><ol><li>约定优于配置 </li><li>开箱即用、快速启动 </li><li>适用于各种环境 </li><li>轻量级的组件 </li><li>组件支持丰富，功能齐全 </li></ol><h3 id="4-Dubbo和Spring-Cloud对比"><a href="#4-Dubbo和Spring-Cloud对比" class="headerlink" title="4.Dubbo和Spring Cloud对比"></a>4.Dubbo和Spring Cloud对比</h3><p>**传送门:<a href="https://www.hellojava.com/a/1040.html" target="_blank" rel="noopener">https://www.hellojava.com/a/1040.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-Cloud基础使用&quot;&gt;&lt;a href=&quot;#Spring-Cloud基础使用&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud基础使用&quot;&gt;&lt;/a&gt;Spring Cloud基础使用&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="Spring全家桶" scheme="http://yoursite.com/categories/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
  </entry>
  
</feed>
