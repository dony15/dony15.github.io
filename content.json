{"pages":[{"title":"categories","text":"暂无分类","path":"categories/index.html","date":"07-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-05","excerpt":""},{"title":"留言板","text":"","path":"message/index.html","date":"07-11","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"07-05","excerpt":""},{"title":"tags","text":"暂无标签哦","path":"tags/index.html","date":"07-05","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"07-05","excerpt":""}],"posts":[{"title":"Spring基础原理","text":"Spring基础原理[TOC] 1.Spring概念提供一个ioc容器来管理Bean,并通过AOP方式来增加Bean的功能 基于Spring-IoC和AOP来构建多层Java EE 项目,能构将项目内的组件进行解耦分离,大大提高了开发效率和维护效率 通过反射+XML实现的对象管理工厂(大容器) 目的: 解耦,简化开发 AOP编程的支持 声明事务的支持 方便程序测试 继承各种优秀框架 降低Java EE API的使用难度 2.核心概念 IoC: Inversion of Control 控制反转 (通过反射机制创建对象实例) DI: Dependency Injection 依赖注入(将bean之间的关系交给spring容器管理,我们可以在service注入dao层的实例,controller中注入service层实例) AOP: Aspect Oriented Programming 面向切面 3.Spring组成Spring框架的功能大概由20多个模块组成,这些模块按组可以分为以下几部分 | 核心容器 | 数据访问/集成 | WEB | AOP | 设备 | 消息 | 测试 | ​ 核心模块:Beans Core Context spEL对应项目初始化时需要的四个核心包 4.Spring说明 bean元素:需要spring管理的对象,是Spring中最基础的单位(包括数据源/SessionFactory/事务管理等) class属性: 需要spring管理对象的全类名 name属性:给被管理者起个引用名,根据该引用名就可以使用该对象(bean对象的标识) id属性:bean对象的唯一标识(和name的区别是整个spring中不可重复) lazy-init:是否延时加载,默认false(开启后只对单例有效) init-method:对象初始化方法 destory:对象销毁方法 scope:singleton(默认,适用实际开发的大部分情况)还是prototype 1.Spring管理对象原理1.Spring容器Spring要管理对象,就需要把对象加入到自己的容器中 Spring容器是Spring的核心,主要的责任便是管理Spring中java的组件 对象加入到Spring容器的三种方法(依赖注入) |无参构造+setter注入|有参构造方法注入|动静态工厂注入| 使用bean对象时,实例化容器的两种方法|ClassPathXml..xml实例化|FileSystem…绝对路径实例化| ApplicationContext容器实例化后,默认会实例化内部的所有bean,通过getBean即可获取bean对象的使用权 2.Spring容器与对象Bean通常情况下,Bean是被动的接收Spring容器创建的实例,具有使用权,即Bean不对Spring进行访问 如果想让Bean对Spring进行访问,则需要手动配置,让Bean实现BeanFactoryAware 接口… 该操作非常不推荐,污染代码,使Bean和Spring耦合在一起,若非特别需要,否则不要用 3.Spring容器中Bean的继承特性与Java中继承区别spring中可以使用抽象bean,即abstract 属性为true,抽象bean不能被实例化,作用是Spring中的继承 spring中的继承: 主要用于bean的数量越来越多,许多属性配置冗余,此时可以使用继承 spring的继承无法继承如下属性: depends-on,aotuwirwe,dependency-check,singleton,scope,lazy-iniyt这些属性总是子Bean定义，或采用默认值。 Bean继承与java中继承的区别： Spring中的子bean和父Bean可以是不同类型，但java中的继承则可保证子类是一种特殊的父类； Spring中的Bean的继承是实例之间的关系，因此只要表现在参数值的延续，而java中的继承是类之间的关系，主要表现为方法、属性之间的延续； Spring中的子Bean不可以作为父Bean使用，不具备多态性，java中的子类完全可以当成父类使用。 4.Spring容器中Bean模式的生命周期singleton： Spring容器能够准确的追踪其创建/使用/销毁 prototype：Spring容器仅负责其创建,无法追踪其使用和销毁,每次创建后都会委托给客户端,不再对其追踪 5.强制初始化Bean(使用较少)Spring有一个默认的规则，总是先初始化主调Bean，然后在初始化依赖Bean。为了指定Bean在目标Bean之前初始化，可以使用depends-on属性 6.自动装配 Spring能自动装配Bean与Bean之间的依赖关系，即使无需使用ref显式指定依赖Bean。 自动装配可以减少配置文件的工作量，但是降低了依赖关系的透明性和依赖性。 可以根据指定属性值类型来缩小自动装配的范围(很少指定) | no | byName | byType | constructor | autodetect | 7.依赖检察(使用较少)Spring提供一种依赖检查的功能，可以防止出现配置手误，或者其他情况的错误。dependency-check=”all” 该属性值可以为| none | simple | objects | all | 2.Spring核心机制:IoC/DI无论是IoC(控制反转) 还是DI(依赖注入),其含以上是互相包容的,在控制反转时便实现依赖注入 传统方法:当一个java实例(A)需要调用另一个java实例(B)时,需要在A中new一个B来构建 Spring管理中:B对象的创建交给了Spring来管理(控制反转) | 将B对象注入给A对象的过程称为(依赖注入) 4.Spring AOP1.概念 AOP（Aspect Oriented Programming），即面向切面编程，基于面向过程 是OOP（Object Oriented Programming，面向对象编程）的补充和完善。 (OOP无法关注到程序的切入点,AOP具有更强大的切面控制力) 例如: 面向对象的流程是用户注册信息,然后插入到数据库中 面向切面的流程是用户注册信息,在插入数据库前进行控 制,在插入数据库后进行控制 AOP使用横切技术,把软件系统分成两部分核心关注点,特点:纵向关系为主,建立对象层次结构横切关注点,特点:横向关系为主,分布在核心关注点的周围,能够切开封装对象,对内部重复的部分进行重新封装,降低耦合性,如权限认证、日志、事务,AOP可以分离系统中的关注点,达到更高效的开发和运行 2.五种横切方案 前置通知 后置正常通知 后置异常通知 后置始终通知 环绕通知 3.八大核心概念 Joinpoint 连接点 AOP执行程序的特定位置 PointCut 切点 AOP通过切点来确定特定的连接点位置 Advice 增强 织入目标类连接点上的一段代码,可以描述程序,也可以确定方位, 只有通过切点信息和方位信息,才能确定特定连接点并执行增强逻辑 Target 目标对象 增强逻辑的织入目标类 Introduction 引介 特殊增强,给指定类添加属性和方法,也可以动态的添加接口的实现业务逻辑 weaving 织入 增强 添加到 目标类 的 连接点 的过程,将目标,增强和引介很好的结合在了一起,AOP常用的三种织入技术 编译期织入,这要求使用特殊的Java编译器. ​ 类装载期织入,这要求使用特殊的类装载器. ​ 动态代理织入,在运行期为目标类添加增强生成子类的方式. Spring采用动态代理织入,而AspectJ采用编译期织入和类装载器织入. Proxy 代理 目标被增强织入后生成一个新的代理类,该代理类可能和原类是一个接口,也可能是原类的子类,可以采用和原类相同的方法调用 Aspect 切面 由增强和切点组成, [既包含横切逻辑的定义,也包括连接点的定义] ,能够把这两种定义织入到指定连接点中 4.AOP底层调用的两种代理机制 JDK动态代理:针对接口类产生代理 CGlib动态代理:针对没有实现接口的类产生代理,应用的是底层字节码增强技术,生成当前类的子类对象 5.Spring深入拓展1.利用后处理器扩展Spring容器…2.Spring的“零配置”支持(注解)**| Component | Controller | Service | Repository | Scope | Resource | Autowired | Qualifier | JsonIgnore |** 3.资源访问…深入拓展传送门:https://www.cnblogs.com/shijiaoyun/p/7458341.html","path":"2018/07/15/Spring基础原理/","date":"07-15","excerpt":""},{"title":"Spring-MVC基础原理","text":"1.Spring-MVC基础原理[TOC] 1.概念优秀的Web框架,具有松散耦合,拔插组件结构,注解驱动,REST风格支持等特性,比其他web框架更具有扩展性和灵活性 在数据绑定,视图解析,本地化处理,静态资源处理上有不俗的表现,远超Struts2,WebWork等MVC框架 2.MVC框架MVC全称 Model veiw Controller(模型视图控制器) 软件级的解耦分离 M:主要包含service(核心业务逻辑)和dao(数据库访问) V:静态资源,如HTML5,JS,CSS等 C:servlet(主要处理页面的转发和重定向,数据的接收,域对象的操作,)和jsp(本身也是servlet) MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。 MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。 (扩展)Spring MVC是基于 Model 2实现的技术框架,Model 2是经典的MVC(model,view,control)模型在WEB应用中的变体.这个改变主要源于HTTP协议的无状态性,Model 2 的目的和MVC一样,也是利用处理器分离模型,视图和控制,达到不同技术层级间松散层耦合的效果,提高系统灵活性,复用性和可维护性.大多情况下,可以将Model 2 与 MVC等同起来. (扩展)三层架构基础 物理三层架构:客户端(如浏览器)/Web服务器/数据库服务器 逻辑三层架构:表现层/业务逻辑层/数据库访问层 3.Spring MVC体系概述Spring-MVC围绕着DispatcherServlet(前段控制器)这个核心展开,所有的前端请求都会拦截经过这里分发到Spring MVC的各个处理器中处理,(扩展)如注解驱动控制器,请求及响应的信息处理,视图解析,本地化解析,上传文件解析,异常处理及表单标签绑定内容等… 4.Spring MVC核心组件 DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器,调用处理器传递参数等工作! ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。 5.Spring MVC执行流程 6.DispatcherServlet1.核心 DispatcherServlet 是Spring-MVC的核心构成,负责协调所有mvc的处理器, DispatcherServlet可以和Spring-IoC无缝集成,获得Spring的所有好处 使用时需要在web.xml中对DispatcherServlet进行配置 2.DispatcherServlet继承关系图 3.DispatcherServlet的责任主要负责调度Spring-mvc的工作,并控制MVC的流程 文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析； 通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个HandlerInterceptor拦截器）； 通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)； 通过ViewResolver解析逻辑视图名到具体视图实现； 本地化解析； 渲染具体的视图等； 如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。 4.DispatcherServlet核心代码5.DispatcherServlet辅助类传送门:https://xuzhongcn.github.io/#top7.常用注解(实用重点)1.@RequestMapping 请求方式2.@RequestParam 处理请求参数3.@PathVariable 路径传参","path":"2018/07/15/Spring-MVC基础原理/","date":"07-15","excerpt":""},{"title":"","text":"slf4j 1234567891011121314151617import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * @author DonY15 * @description * @create 2018\\7\\14 0014 */public class test01 &#123; private static final transient Logger log = LoggerFactory.getLogger(test01.class); public static void main(String[] args) &#123; log.debug(\"Here is some DEBUG\"); log.info(\"Here is some INFO\"); log.warn(\"Here is some WARN\"); log.error(\"Here is some ERROR\"); &#125;&#125;","path":"2018/07/14/Log日志整理/","date":"07-14","excerpt":""},{"title":"服务器搭建(持续更新)","text":"服务器搭建集合[TOC] 1.ShadowsocksR多用户一件脚本系统要求:CentOS 6+ / Debian 6+ / Ubuntu 14.04 + 脚本特点： 所有步骤都可以通过 Shell 脚本中文交互 操作。 支持 限制 用户速度 支持 限制 用户设备数 支持 限制 用户总流量 支持 定时 流量清零 支持 显示 当前连接IP 支持 显示 SS/SSR连接+二维码 支持 一键安装 BBR 支持 一键安装 锐速 支持 一键安装 LotServer 支持 一键封禁 垃圾邮件(SMAP)/BT/PT 一键安装指令: 1wget -N --no-check-certificate https://makeai.cn/bash/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 文件位置 安装目录：/usr/local/shadowsocksr 配置文件：/usr/local/shadowsocksr/user-config.json 数据文件：/usr/local/shadowsocksr/mudb.json 启动 ShadowsocksR：service ssrmu start 停止 ShadowsocksR：service ssrmu stop 重启 ShadowsocksR：service ssrmu restart 查看 ShadowsocksR状态：service ssrmu status Linux中提示-bash: wget: command not found的解决方法 CentOS:yum install wget -y Debian/Ubuntu:apt-get install -y wget 详细传送门:https://www.bbaaz.com/thread-7-1-1.html","path":"2018/07/14/服务器搭建/","date":"07-14","excerpt":""},{"title":"Zookeeper与Dubbo基础原理","text":"Zookeeper与Dubbo基础原理[TOC] Zookeeper(RPC框架)高效的分布式分布式应用协调服务,提供注册和负载均衡等–&gt;服务中心 zookeeper让调用者知道调用的哪台服务器地址,也是集群的管理者 Zookeeper具有心跳检测机制,当服务器挂掉时可以让调用者知道,从而切换请求服务器 Zookeeper具有高并发的横向扩展,在不改变代码的情况下对设备进行扩展 1.命名服务 2.配置管理 3.集群管理 4.分布式锁 5.队列管理 命名服务:在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现。 配置管理:程序分散部署在多台机器上难以管理,可以将每台设备的信息存储在Zookeeper的目录节点中,然后相关程序对该目录进行监控,如果配置信息发生变化,则Zookeeper会发布新的配置 集群管理:(1)设备的加入(2)选举master(可以改变设备编号,编号第一位自动master(一种思路)) 分布式锁:zookeeper是一致性的文件系统,锁服务可以分为两类，(1)保持独占，(2)控制时序。 列队管理: 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。 队列按照 FIFO 方式进行入队和出队操作。和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。 特性 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。 可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。 原子性：更新只能成功或者失败，没有中间状态。 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。 Zookeeper工作原理​ Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态 ​ 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。 (部分整理) 原文:https://blog.csdn.net/xqb_756148978/article/details/52259381 Dubbo(SOA基础框架)管理中间层的框架,与注册中心搭配使用,如Zookeeper(最常用),使之具有Zookeeper负载均衡/资源同步等的特性 单一应用架构(ORM) –&gt;垂直应用架构(MVC)–&gt;分布式服务架构(RPC)–&gt;流动计算架构(SOA) 核心部分 远程通讯 集群容错 自动发现 作用 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点. 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 Dubbo采用全spring配置方式,透明化接入,应用,没有API入侵 架构 Provider: 暴露服务的服务提供方。 ​ Consumer: 调用远程服务的服务消费方。 ​ Registry: 服务注册与发现的注册中心。 ​ Monitor: 统计服务的调用次调和调用时间的监控中心. ​ Container]: 服务运行器。 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 收藏Dubbo架构详解http://shiyanjun.cn/archives/325.html","path":"2018/07/08/Zookeeper基础原理/","date":"07-08","excerpt":""},{"title":"基础排序 组合","text":"规范:()中,先写下,在写上 [TOC] 1.排序转换为计算机写法A(n,m) n在下 m在上 ​ 即:n个数中取m个来排序 2.组合转换为计算机写法C(n,m) n在下 m在上 ​ 即: 分子:n的阶乘,阶乘的个数为m ​ 分母:m的阶乘","path":"2018/07/08/基础排序 组合/","date":"07-08","excerpt":""},{"title":"实用工具类集合","text":"实用工具类集合[TOC] 简述 该工具类集合章会持续更新,具体工具类会集成到我的GitHub仓库中 传送门 https://github.com/dony15/mymodes 1.js-utils.js常用js的前段封装 XMLHttpRequest 原生ajax的获取 ,内置了Chrome和IE的兼容转换 图片上传功能前段,四个id解决 | 图片 | 表单 | 回显 | 的结合 验证码显示和输入框校验 两个id 一个url 即可解决 | 校验 | 提示 | 提交url |的结合 点击切换验证码 id和url 2.pattern.js包含开发中各种验证常用的正则封装 2.CollectionsFactory包含各种集合类型的构建,静态工具类,使代码看起来更加规范简洁 3.DownloadUtil文件下载工具类,根据文件名或者文件路径获取文件进行下载(多场景的封装) 3.FileUtil非常实用的文件处理工具,如获取文件名/去重/清空但不删除文件夹/磁盘遍历/xml生成等等… 4.FormatStyle文件容量单位的格式转换,主要解决特殊情况下因为数字太大导致java直接写无法识别的 5.IDUtilsID的多种生成策略 5.JsonUtils使用jackson,多种类型和json的转化封装 对象 | List 6.ResourcesUtil资源读取工具类,较为特殊,使用较少(主要是国际语言的匹配读取,现在前段控制即可) 7.UtilFuns该工具类非常的丰富.各种SE的基础转换和时间/固定长度转换/编码解码等都有涉猎 其他中文命名工具类不再解释(简单明了)","path":"2018/07/08/实用工具类集合/","date":"07-08","excerpt":""},{"title":"工具类集合分析--接口","text":"工具类集合分析–接口[TOC] 1.概述使用接口作为工具类,一般分两种情况 ​ (1)定义常量 ​ (2)定义动态工具类 2.分析1.定义常量可以在工具类中快捷明了的定义常量来使用,因为接口中默认属性便是常量,如: ​ int HOTEL_STATUS_INVALID=0;//酒店失效 ​ int HOTEL_STATUS_VALID=1;//酒店有效 当controller中往前端传递数据时,需要判断状态,而状态从controller中多次定义会导致观察不变,不利于交接和后期维护,此时便可以将状态抽出来存进接口工具类中,提高代码的可读性和开发效率 (RestFull开发风格中,提高代码可读性尤为突出) 2.定义动态工具类当程序运行在不同的环境中时,因为程序对环境的耦合性,频繁的修改代码会大大降低开发效率,可以使用工具类接口的方式,将耦合性降低,如动态工具类 场景 ​ redis 单机版和集群版 (可以根据需要选择具体的方案,减少代码的修改量) ​","path":"2018/07/08/工具类集合分析--接口/","date":"07-08","excerpt":""},{"title":"Solr基础原理","text":"Solr基础原理[TOC] 1.目录核心组成1.core ​ solr的索引库,可以理解为数据库,需要手动创建(文件夹),core可以根据需要建立多个索引库,索引库的内容可以在后台看到也可以在core中看到 2.solrhome ​ solr的配置目录,solr服务器所有的配置文件存放的目录(core创建在solrhome中) 3.collection ​ solr的逻辑索引(逻辑意义上的完整索引),由多个shard的组成,每个shard又由一个leadereplica和多个replica,每个replica都是物理索引,即每个replica都对应着一个core,collection本质是可以跨越多个核的索引,包含冗余的索引. 参考https://blog.csdn.net/zhousenshan/article/details/51799567 2.配置详解1.配置中文分词 ​ &lt;!– default values for query parameters can be specified, these ​ will be overridden by parameters in the request ​ –&gt; ​ ​ explicit ​ item_keywords ​ 10 ​ ​ explicit ​ json ​ true ​ item_keywords ​ 2.配置Solr Dataimport ​ ​ data-config.xml ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ 3.Solr后台的使用第一次先Dataimport–&gt;Execute导入,然后Refresh刷新状态即可 Query:查询功能 ​ q ; –&gt;第一个 表示字段; 第二个 表示字段的内容; ​ 如 item_keywords:北京 分词中有”北京”关键字的内容 ​ item_price:[* TO 200] 价格是200以内的内容 ​ item_price:[100 TO 700] 价格是100-200的内容 3.java中的作用建立一个新的索引模块 index,接口层和实现发布层 写Solr更新和搜索两个方法dubbo发布即可在controller中使用 (一般与MQ一起使用,如activeMQ,见activeMQ基础与运用章节)","path":"2018/07/06/Solr基础原理/","date":"07-06","excerpt":""},{"title":"FastDFS 基础原理","text":"FastDFS 基础原理[TOC] 深度优先搜索Depth First Search 无向图算法概念(一种递归原理) 先按照一条边进行搜索,当遇到第一个节点时,对它相邻的其他节点进行搜索并标记为已查找的节点(会查找完第一条节点的最深层后返回)详细见算法目录(持续更新) FastDFS–结构FastDFS 架构–结构 FastDFS服务有三个角色:跟踪服务器(tracker server)、存储服务器(storage server)和客户端(client) 主要解决了海量数据存储问题 ,特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。 跟踪器Tracker :主要做调度工作，相当于mvc中的controller的角色，在访问上起负载均衡的作用。跟踪器和存储节点都可以由一台或多台服务器构成，跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务，其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。 跟踪器Tracker负责管理所有的Storage和group，本身不需要持久化任何数据,直接增加机器就可以拓展tracker,每个Storage在启动后会连接Tracker，并周期性保持联系. 存储服务器Storage:以group为最小单位,方便实现 应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数）,建议同一group内的配置尽量相同,减少资源浪费(storage依赖于本地文件系统) 客户端Client:基本文件访问接口:比如upload、download、append、delete等，以客户端库的方式提供给用户使用。 FastDFS–运行tracker 当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个trakcer。 group 当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group，支持如下选择group的规则： Round robin，所有的group间轮询 Specified group，指定某一个确定的group Load balance，剩余存储空间多多group优先 storage 当选定group后，tracker会在group内选择一个storage server给客户端，支持如下选择storage的规则： Round robin，在group内的所有storage间轮询 First server ordered by ip，按ip排序 First server ordered by priority，按优先级排序（优先级在storage上配置） storage path 当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录，支持如下规则： Round robin，多个存储目录间轮询 剩余存储空间最多的优先 Fileid 选定存储目录之后，storage会为文件生一个Fileid，由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，然后将这个二进制串进行base64编码，转换为可打印的字符串。 选择两级目录 当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash（猜测），路由到其中一个子目录，然后将文件以fileid为文件名存储到该子目录下。 生成文件名 当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。 文件同步 写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至 [同group] 内其他的storage server。storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。 Download file 客户端upload file成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。 FastDFS–特点小文件合并存储解决问题: 本地文件系统inode数量有限，从而存储的小文件数量也就受到限制。 多级目录+目录里很多文件，导致访问文件的开销很大（可能导致很多次IO） 按小文件存储，备份与恢复的效率低 FastDFS在V3.0版本里引入小文件合并存储的机制，可将多个小文件存储到一个大的文件（trunk file），为了支持这个机制，FastDFS生成的文件fileid需要额外增加16个字节 HTTP访问支持客户端可以通过http协议来下载文件，tracker在接收到请求时，通过http的redirect机制将请求[重定向]至文件所在的storage上；除了内置的http协议外，FastDFS还提供了通过apache或nginx扩展模块下载文件的支持。 负载均衡group机制本身可用来做负载均衡，但这只是一种静态的负载均衡机制，需要预先知道应用的访问特性；同时group机制也导致不可能在group之间迁移数据来做动态负载均衡。 FastDFS–使用小结 分别配置Tracker地址(上传存储使用)和Storage地址(响应回显使用) 接收前段file文件后,将名字拆分重塑后存储 响应url则拼接Storage地址生成 每次上传文件后都会返回一个地址，用户需要自己保存此地址。 前段设计:将整个编辑内容存进一个由事件控制的表单,当图片上传的时候不会影响到表单的完整性,而且可以依靠上传时间来动态生成回显方案,将url放进input中,清除不必要的组件(可能影响表单提交完整性的部分) 为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。 注意:spring-mvc中除了要配置上传解析器之外,还需要将String的字符串指定为UTF-8(默认8859-1) FastDFS原理系列文章(转发)https://blog.csdn.net/hfty290/article/details/42076205","path":"2018/07/06/FastDfs基础原理/","date":"07-06","excerpt":""},{"title":"ActiveMQ基础与运用","text":"ActiveMQ基础与运用[TOC] 1.概念消息队列:即时消息通信和延时消息通信 ActiveMQ底层基于java的JMS实现,在没有JMS之前的系统存在很多缺陷: 前后端同步问题,如果后台没有响应,则前段会一直阻塞等待 前后端生命周期耦合性太强,一方崩了则另一方也会崩 点对点通信,前段一次只能发送给某一个单独的服务对象,无法群发 JMS: (Java Message Service ) 通过消息中间件(MOM：Message Oriented Middleware ) 将消息发送给单独的消息服务器中,消息服务器会将消息存放在若干的队列/主题中,在合适的时候将消息发送给接收者.发送和接收是异步的,无需阻塞等待 在pub/sub的模式下,可以将消息发送给多个接收者 JMS类中定义了java访问中间件的接口,除此之外都是异常定义 Provider/MessageProvider：生产者 Consumer/MessageConsumer：消费者 PTP：Point To Point，点对点通信消息模型 Pub/Sub：Publish/Subscribe，发布订阅消息模型 Queue：队列，目标类型之一，和PTP结合 Topic：主题，目标类型之一，和Pub/Sub结合 ConnectionFactory：连接工厂，JMS用它创建连接 Connnection：JMS Client到JMS Provider的连接 Destination：消息目的地，由Session创建 Session：会话，由Connection创建，实质上就是发送、接受消息的一个线程，因此生产者、消费者都是Session创建的 2.应用| 异步处理 | 应用解耦 | 流量削锋 | 消息通讯 | 详情参考:https://blog.csdn.net/kingcat666/article/details/78660535 3.消息模式 P2P模式(点对点) Pub/Sub模式(发布订阅) Push模式(推拉模式,消息更新C/S中) 4.java中与Solr结合ActiveMQ以监视器的方式将信息与Solr结合使用…待更新","path":"2018/07/06/activeMQ基础与运用/","date":"07-06","excerpt":""},{"title":"Shiro基础原理","text":"Shiro基础原理[TOC] 1.简介shiro是apache的一个开源框架，实现 |认证|授权|为核心的一系列权限管理框架. Web 应用程序一般做法通过表单提交用户名及密码达到认证目的。 “授权”即是否允许已认证用户访问受保护资源。 2.对比Shiro与Spring Security 简单性:shiro更加简单,更容易理解 灵活性:shiro可以使用在 |Web|EJB|IoC| 等大部分的应用环境,而Spring Security必须和Spring一起集成使用 拔插性:shiro干净的API(工具类集合)和设计模式(单例+工厂)使它可以方便的和许多其他框架整合,Spring Security则只能与Spring一起集成 3.组成 1.三个核心组件 Subject: 令牌与项目的登录关系,Shiro保证了项目整体的安全性,是Shiro对外API的核心 Security Manager:负责安全认证预授权等 Shiro的核心 Realm:整个框架中必须由设计者自行实现的模块之一.并且Shiro支持多个Realm数据源,最为重要的一种实现方式—&gt;数据库查询,当需要多个数据库组合验证时,多个数据源的效果就体现出来 2.主要功能 Authentication: 身份认证 Authorization: 授权,权限验证 Session Manager: 会话管理 Cryptography:加密 Web Support: web支持 Caching:缓存 Concurrency:多线程验证 Testing:提供测试支持 Run As:允许一个用户假装另一个用户访问 Remember Me: 记住我 3.组件和内容流程分析1.subject外部API核心,存储用户数据和返回数据 1Subject currentUser = SecurityUtils.getSubject(); 获得Subject的方法,有了Subject才能和Shiro做深入的交互 2.SessionManager Shiro的Session提供了HttpSession常规的大部分功能,但是又有区别,即:Session不依赖于HTTP环境,可以在程序任何地方使用 Shiro的Session可以在任何的环境下使用相同的API,而且是自动启动SessionManager 如果希望在*当前与应用程序会话期间,为用户提供内容,则可以设置Session 12Session session = currentUser.getSession();session.setAttribute( &quot;someKey&quot;, &quot;aValue&quot; ); 3.登录认证AuthenticationShiro的认证功能,会根据Subject的信息进行判断,如果认证过,则直接进入/如果没认证,则需要先认证 12345678910if ( !currentUser.isAuthenticated() ) &#123; //collect user principals and credentials in a gui specific manner //such as username/password html form, X509 certificate, OpenID, etc. //We&apos;ll use the username/password example here since it is the most common. //(do you know what movie this is from? ;) UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;); //this is all you have to do to support &apos;remember me&apos; (no config - built in!): token.setRememberMe(true); currentUser.login(token);&#125; UsernamePasswordToken(username/password) 以特定的方式收集用户的主体和凭证 Remember Me no config - built in!(true/false) Shiro内置功能,记住用户(详情待更新) 登录尝试失败的反馈–异常 1234567891011121314try &#123; currentUser.login( token ); //if no exception, that&apos;s it, we&apos;re done!&#125; catch ( UnknownAccountException uae ) &#123; //username wasn&apos;t in the system, show them an error message?&#125; catch ( IncorrectCredentialsException ice ) &#123; //password didn&apos;t match, try again?&#125; catch ( LockedAccountException lae ) &#123; //account for that username is locked - can&apos;t login. Show them a message?&#125; ... more types exceptions to check if you want ...&#125; catch ( AuthenticationException ae ) &#123; //unexpected condition - error?&#125; Shiro中使用多种异常完善认证 将Subject的.login(token)进行捕获,从而的到许多种异常提醒,根据相应的异常判断用户登录的错误信息 注意:Shiro有丰富的认证异常设定并支持自定义异常,在Realm中通过判断条件,抛出异常的方式,可以在Controller中接收需要的异常数据来完善程序的开发 注意:Shiro不会自己维护用户|权限; 需要开发者去 设计|提供 ; 然后通过接口注入给Shiro即可 4.源码Token认证JdbcRealm Shiro –&gt;JdbcRealm封装的固定sql [1.封装根据用户名查询密码的SQL语句] 1234/** * The default query used to retrieve account data for the user. */ protected static final String DEFAULT_AUTHENTICATION_QUERY = \"select password from users where username = ?\"; [2.盐加密&amp;&amp;authenticationQuery验证查询(判断)] 1234567891011/** * Sets the salt style. See &#123;@link #saltStyle&#125;. * * @param saltStyle new SaltStyle to set. */ public void setSaltStyle(SaltStyle saltStyle) &#123; this.saltStyle = saltStyle; if (saltStyle == SaltStyle.COLUMN &amp;&amp; authenticationQuery.equals(DEFAULT_AUTHENTICATION_QUERY)) &#123; authenticationQuery = DEFAULT_SALTED_AUTHENTICATION_QUERY; &#125; &#125; [3.发现源代码中使用预编译的原生JDBC,并根据索引查找对比,所以要求自定义语句时不能乱写,根据规则走] 12345678910111213141516171819202122232425PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(authenticationQuery); ps.setString(1, username); // Execute query rs = ps.executeQuery(); // Loop over results - although we are only expecting one result, since usernames should be unique boolean foundResult = false; while (rs.next()) &#123; // Check to ensure only one row is processed if (foundResult) &#123; throw new AuthenticationException(&quot;More than one user row found for user [&quot; + username + &quot;]. Usernames must be unique.&quot;); &#125; result[0] = rs.getString(1); //索引查询 if (returningSeparatedSalt) &#123; result[1] = rs.getString(2); &#125; foundResult = true; &#125; new SimpleAuthenticationInfo()(存放唯一认证) 源码分析 principal: 整个Shiro中唯一的标识符,可以存用户名,也可以存ID credentials: 唯一标识符的密码 realmName: 当前数据源的名字 1234public SimpleAuthenticationInfo(Object principal, Object credentials, String realmName) &#123; this.principals = new SimplePrincipalCollection(principal, realmName); this.credentials = credentials; &#125; 使用了工厂模式来对SecurityManager进行生成和配置 生成过程是使用单例+工厂 提供对外的工具类来使用，包含获取SecurityManager的方法和获取Subject的方法 (代码略) subject的使用是通过传入AuthenticationToken接口（注意是接口，其实扩展接口rememnverMeaut…和HostAutho…）， 该接口目前的实现类是UserPasswordToken，当然也可以自己扩展实现自定义的认证Token 测试加密算法盐值加密如果几个人密码一样，那么加密后的密码则一致。这样不安全，要解决这个问题，可以在密码上加盐。一般会选择不重复的值作为盐值，例如 用户名。(部分代码) 12345678//构造方法： //第一个参数：散列算法 //第二个参数：明文，原始密码 //第三个参数：盐，通过使用随机数 //第四个参数：散列的次数，比如散列两次，相当 于md5(md5('')) SimpleHash simpleHash = new SimpleHash(\"md5\", source, salt, hashIterations); String md5 = simpleHash.toString(); System.out.println(md5); 12345678910111213141516shiro-realm-md5.ini---------------------[main]定义凭证匹配器credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher散列算法credentialsMatcher.hashAlgorithmName=md5散列次数credentialsMatcher.hashIterations=1024开启加盐（无需设置，realm中使用的SimpleAuthenticationInfo 是 SaltedAuthenticationInfo 接口的实现类，默认开启的加盐功能）credentialsMatcher.hashSalted=true自定义 realmcustomRealm=com.qfedu.shirodemo.realm.CustomRealmMd5customRealm.credentialsMatcher=$credentialsMatcher将realm设置到securityManager，相当 于spring中注入securityManager.realms=$customRealm 授权流程原理授权 授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。 主体（Subject） 主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。 资源 在应用中用户可以访问的任何东西，比如JSP 页面、某些数据、某个业务方法等等都是资源。用户只要授权后才能访问。 角色 角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。 典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。 权限 权限表示在应用中用户能不能访问某个资源， 如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）打印文档等等。。。 判断是否授权的方式Shiro 支持三种方式的授权判断： 编程式 通过写if/else 授权代码块完成： Subject subject = SecurityUtils.getSubject(); if(subject.hasRole(“admin”)) { ​ //有权限 } else { ​ //无权限 } 注解式 通过在执行的Java方法上放置相应的注解完成： @RequiresRoles(“admin”) public void hello() { //有权限 } 没有权限将抛出相应的异常； JSP 标签 在JSP 页面通过相应的标签完成： 12345&lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;!— 有权限—&gt;&lt; /shiro:hasRole &gt; 自定义realm授权从认证的realm拷贝，改变继承的抽象父类，添加新的方法 5.程序分析程序分析：从应用程序角度的来观察如何使用Shiro完成工作 应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager； 我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。 可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject； Shiro内部结构 详细原理深入和运用:http://jinnianshilongnian.iteye.com/blog/2018398 6.Shiro认证技巧整理工具类接口的使用建立一个工具类接口Constants,以常量字符串的方式,专门存放Shiro中自定义的标识符 12345678910public interface Constants &#123; // md5(用户密码+PASSWORD_SALT_KEY)保存到数据库中。 String PASSWORD_SALT_KEY = &quot;Shiro.admin.2017&quot;; //Shiro的session中存放用户的key String SESSION_USER_KEY = &quot;SESSION_USER_KEY&quot;; //redis中存放的用户权限菜单的key String SESSION_USER_MANU = &quot;SESSION_USER_MANU&quot;; //Shiro存放的角色信息 String SESSION_USER_ROLE = &quot;SESSION_USER_ROLE&quot;;&#125; 接口工具类的思路不仅限于Shiro,灵活的定义接口,将冗余和容易混淆的部分抽离出来统一管理,可以极大的提高开发和维护的效率 认证优化技巧Controller层登录方法中,接收到用户名和密码后先进行 1234Subject currentUser = SecurityUtils.getSubject();if (!currentUser.isAuthenticated()) &#123; ...认证&#125; 直接获取subject,先进性判断该用户是否认证过,如果认证过则直接跳出即可 如果没有认证过,再进入认证环节 该逻辑可以减少服务器和数据库的压力,提高服务器的并发能力 ..shiro.xml 拦截器设置Shiro主过滤器本身功能十分强大,其强大之处就在于它支持任何基于URL路径表达式的、自定义的过滤器的执行 /login.html=anon 静态资源的方式屏蔽过滤器 /**=authc 该路径下需要认证才能访问 … 过滤器的完整参考： http://blog.csdn.net/jadyer/article/details/12172839 登录认证使用原理动态权限控制 RBAC（Role-Based Access Control ）基于角色的访问控制 配置好环境和工具类 自定义Realm和异常 service中添加通过用户名查找用户信息 在Controller层认证登录 UsernamePasswordToken token = new UsernamePasswordToken(name, password); Subject subject = SecurityUtils.getSubject(); ubject.login(token); 将真正的验证交给封装的底层–&gt;AuthenticationToken实现.(自定义Realm中) 通过此时token的username去数据库查询用户信息 用户信息存在,则存入SimpleAuthenticationInfo,否则 抛出用户对应的异常 Shiro的分布式认证结构(shiro认证将账号密码的比较环节封装到AuthenticationToken中) ​ Realm放在Controller中,在分布式中Controller使用Dubbo服务端接口,而dubbo接口通过service实现类来发布,这个角度看realm与dao隔层交互设计不太合理 ​ 验证成功则返回SimpleAuthenticationInfo(存放唯一标识(id或者username),密码,Realm名 7.Shiro授权技巧整理 通过用户登录的唯一标识principals 查找到用户有哪些菜单权限(ID) 将这些ID存到SimpleAuthorizationInfo中 在自定义ShiroFilterFactoryBean中获取所有菜单列表,并将id加入到section中 底层自动对比,哪些ID用户有,则允许访问,没有的话”authc”拦截 Controller中查询用户拥有的菜单数据返回前段即可,此时没有权限的数据已经被拦截 易错集合1.授权URL​ 注意使用Shiro权限设置后的url如果需要访问,逻辑路径需要放在 前端 拼接,(后台对逻辑路径没有识别,也没有必要识别,不能将逻辑路径放在后台和数据库中) 2.权限顺序​ 运行时先执行MyRealm中的权限,然后拼接MyShiroFilterFactoryBean中的权限 ​ 注意:限制范围较大的往后排,特别是全部拦截的/ 如果需要的话尽量放在MyShiroFilterFactoryBean**中 8.Remember me功能简述Shiro的Remember Me可以很轻松的实现自动登录的功能,方便快捷 实现过程123456UsernamePasswordToken token = new UsernamePasswordToken(username, password); Subject subject = SecurityUtils.getSubject(); if(loginForm.getRememberMe() != null &amp;&amp; &quot;Y&quot;.equals(loginForm.getRememberMe()))&#123; token.setRememberMe(true); &#125; subject.login(token); 1/** = user Remember Me只需要在登录时将token的RememberMe功能开启,本来的拦截级别为/ = authc 将拦截设置(降级)为user级别**即可使用 Remember Me功能开启使用后,Shiro会生成一个叫RememberMe的Cookie保存在浏览器中,当subject.loginout退出或者过期后失效,改参数是base64加密的字符串如下 12名称： rememberMe内容： 6gYvaCGZaDXt1c0xwriXj/Uvz6g8OMT3VSaAK4WL0Fvqvkcm0nf3CfTwkWWTT4EjeSS/EoQjRfCPv4WKUXezQDvoNwVgFMtsLIeYMAfTd17ey5BrZQMxW+xU1lBSDoEM1yOy/i11ENh6eXjmYeQFv0yGbhchGdJWzk5W3MxJjv2SljlW4dkGxOSsol3mucoShzmcQ4VqiDjTcbVfZ7mxSHF/0M1JnXRphi8meDaIm9IwM4Hilgjmai+yzdVHFVDDHv/vsU/fZmjb+2tJnBiZ+jrDhl2Elt4qBDKxUKT05cDtXaUZWYQmP1bet2EqTfE8eiofa1+FO3iSTJmEocRLDLPWKSJ26bUWA8wUl/QdpH07Ymq1W0ho8EIdFhOsELxM66oMcj7a/8LVzypJXAXZdMFaNe8cBSN2dXpv4PwiktCs3J9P9vP4XrmYees5x27UmXNqYFk86xQhRjFdJsw5A9ctDKXzPYvJmWFouo3qT5hugX0uxWALCfWg8MHJnG9w7QgVKM8oy3Xy4Ut8lSvYlA== Shiro的RememberMe设计时!=已经登录,因为该cookie被序列化后可以不同的浏览器之间访问,并且可能被黑客复制截取等,因此使用该功能的话尽量以非关键性资源为主,当牵扯到资金等关键资源时,选择再次登录即可 开发时如果使用Session域对象,则自动登录后Session中不会再有数据,如果需要用到,那么需要重写isAccessAllowed 方法 详细参考自:https://blog.csdn.net/nsrainbow/article/details/36945267/ (本次Remember Me尚未指定配置更改,待更新)","path":"2018/07/04/Shiro基础原理/","date":"07-04","excerpt":""},{"title":"Redis基础原理","text":"Redis基础原理[TOC] 1.概念NoSQL 非关系型数据库,Redis是非关系型数据库中的键值存储数据库 应用 处理高并发/海量数据的访问,内容缓存 优点 快速查询,支持横向扩充(集群)和纵向扩充(加强设备) 一主多从,读写分离 哨兵机制,检测选举 集群机制,多主多从,数据高可用,分布式存储 缺点 ​ 存储缺少结构化(难以构建关系型理数据库模型) 2.数据类型String最简单的KV存储,value可以是String也可以是数字等 场景 kv字符串结构等,非常普遍 指令 ​ SET key value 设置key=value ​ GET key 或者键key对应的值 ​ GETRANGE key start end 得到字符串的子字符串存放在一个键 ​ GETSET key value 设置键的字符串值，并返回旧值 ​ GETBIT key offset 返回存储在键位值的字符串值的偏移 ​ MGET key1 [key2..] 得到所有的给定键的值 ​ SETBIT key offset value 设置或清除该位在存储在键的字符串值偏移 ​ SETEX key seconds value 键到期时设置值 ​ SETNX key value 设置键的值，只有当该键不存在 ​ SETRANGE key offset value 覆盖字符串的一部分从指定键的偏移 ​ STRLEN key 得到存储在键的值的长度 ​ MSET key value [key value…] 设置多个键和多个值 ​ MSETNX key value [key value…] 设置多个键多个值，只有在当没有按键的存在时 ​ PSETEX key milliseconds value 设置键的毫秒值和到期时间 ​ INCR key 增加键的整数值一次 INCRBY key increment 由给定的数量递增键的整数值 ​ INCRBYFLOAT key increment 由给定的数量递增键的浮点值 ​ DECR key 递减键一次的整数值 ​ DECRBY key decrement 由给定数目递减键的整数值 ​ APPEND key value 追加值到一个键 ​ ——–操作管理———- DEL key 如果存在删除键 DUMP key 返回存储在指定键的值的序列化版本 EXISTS key 此命令检查该键是否存在 EXPIRE key seconds 指定键的过期时间 EXPIREAT key timestamp 指定的键过期时间。在这里，时间是在Unix时间戳格式 PEXPIRE key milliseconds 设置键以毫秒为单位到期 PEXPIREAT key milliseconds-timestamp 设置键在Unix时间戳指定为毫秒到期 KEYS pattern 查找与指定模式匹配的所有键 MOVE key db 移动键到另一个数据库 PERSIST key 移除过期的键 PTTL key 以毫秒为单位获取剩余时间的到期键。 TTL key 获取键到期的剩余时间。 RANDOMKEY 从Redis返回随机键 RENAME key newkey 更改键的名称 RENAMENX key newkey 重命名键，如果新的键不存在 TYPE key 返回存储在键的数据类型的值。 List(列表)字符串列表,非常重要的Redis类型,本质是双向链表,支持反向查询和遍历,更加方便,但是会额外增加内存开销(存储双向链表),redis内部的发送缓冲队列使用的就是List结构 场景 如twitter的关注列表和粉丝列表,实现轻量级的消息队列等 指令 BLPOPBLPOP key1 [key2 ] timeout 取出并获取列表中的第一个元素，或阻塞，直到有可用 BRPOPBRPOP key1 [key2 ] timeout 取出并获取列表中的最后一个元素，或阻塞，直到有可用 BRPOPLPUSHBRPOPLPUSH source destination timeout 从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用 LINDEXLINDEX key index 从一个列表其索引获取对应的元素 LINSERTLINSERT key BEFORE|AFTER pivot value 在列表中的其他元素之后或之前插入一个元素 LLENLLEN key 获取列表的长度 LPOPLPOP key 获取并取出列表中的第一个元素 LPUSHLPUSH key value1 [value2] 在前面加上一个或多个值的列表 LPUSHXLPUSHX key value 在前面加上一个值列表，仅当列表中存在 LRANGELRANGE key start stop 从一个列表获取各种元素 LREMLREM key count value 从列表中删除元素 LSETLSET key index value 在列表中的索引设置一个元素的值 LTRIMLTRIM key start stop 修剪列表到指定的范围内 RPOPRPOP key 取出并获取列表中的最后一个元素 RPOPLPUSHRPOPLPUSH source destination 删除最后一个元素的列表，将其附加到另一个列表并返回它 RPUSHRPUSH key value1 [value2] 添加一个或多个值到列表 RPUSHXRPUSHX key value 添加一个值列表，仅当列表中存在 HashRedis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。 场景 可以方便的存储用户信息,用户ID为Key,用户信息序列化为value存储 指令 HDELHDEL key field[field…] 删除对象的一个或几个属性域，不存在的属性将被忽略 HEXISTSHEXISTS key field 查看对象是否存在该属性域 HGETHGET key field 获取对象中该field属性域的值 HGETALLHGETALL key 获取对象的所有属性域和值 HINCRBYHINCRBY key field value 将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用 HINCRBYFLOATHINCRBYFLOAT key field increment 将该对象中指定域的值增加给定的浮点数 HKEYSHKEYS key 获取对象的所有属性字段 HVALSHVALS key 获取对象的所有属性值 HLENHLEN key 获取对象的所有属性字段的总数 HMGETHMGET key field[field…] 获取对象的一个或多个指定字段的值 HSETHSET key field value 设置对象指定字段的值 HMSETHMSET key field value [field value …] 同时设置对象中一个或多个字段的值 HSETNXHSETNX key field value 只在对象不存在指定的字段时才设置字段的值 HSTRLENHSTRLEN key field 返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0. HSCANHSCAN key cursor [MATCH pattern] [COUNT count] 类似SCAN命令 Set存储数据不重复,set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 场景 set和list的功能类似,但是set加载的列表自动排重,当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 指令 SADDSADD key member [member …] 添加一个或者多个元素到集合(set)里 SACRDSCARD key 获取集合里面的元素数量 SDIFFSDIFF key [key …] 获得队列不存在的元素 SDIFFSTORESDIFFSTORE destination key [key …] 获得队列不存在的元素，并存储在一个关键的结果集 SINTERSINTER key [key …] 获得两个集合的交集 SINTERSTORESINTERSTORE destination key [key …] 获得两个集合的交集，并存储在一个集合中 SISMEMBERSISMEMBER key member 确定一个给定的值是一个集合的成员 SMEMBERSSMEMBERS key 获取集合里面的所有key SMOVESMOVE source destination member 移动集合里面的一个key到另一个集合 SPOPSPOP key [count] 获取并删除一个集合里面的元素 SRANDMEMBERSRANDMEMBER key [count] 从集合里面随机获取一个元素 SREMSREM key member [member …] 从集合里删除一个或多个元素，不存在的元素会被忽略 SUNIONSUNION key [key …] 添加多个set元素 SUNIONSTORESUNIONSTORE destination key [key …] 合并set元素，并将结果存入新的set里面 SSCANSSCAN key cursor [MATCH pattern][COUNT count] 迭代set里面的元素 Sorted Setset的有序版,由HaspMap和跳跃表组成 场景 用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列。 指令 ZADDZADD key score1 member1 [score2 member2] 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数 ZCARDZCARD key 得到的有序集合成员的数量 ZCOUNTZCOUNT key min max 计算一个有序集合成员与给定值范围内的分数 ZINCRBYZINCRBY key increment member 在有序集合增加成员的分数 ZINTERSTOREZINTERSTORE destination numkeys key [key …] 多重交叉排序集合，并存储生成一个新的键有序集合。 ZLEXCOUNTZLEXCOUNT key min max 计算一个给定的字典范围之间的有序集合成员的数量 ZRANGEZRANGE key start stop [WITHSCORES] 由索引返回一个成员范围的有序集合（从低到高） ZRANGEBYLEXZRANGEBYLEX key min max [LIMIT offset count]返回一个成员范围的有序集合（由字典范围） ZRANGEBYSCOREZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列 ZRANKZRANK key member 确定成员的索引中有序集合 ZREMZREM key member [member …] 从有序集合中删除一个或多个成员，不存在的成员将被忽略 ZREMRANGEBYLEXZREMRANGEBYLEX key min max 删除所有成员在给定的字典范围之间的有序集合 ZREMRANGEBYRANKZREMRANGEBYRANK key start stop 在给定的索引之内删除所有成员的有序集合 ZREMRANGEBYSCOREZREMRANGEBYSCORE key min max 在给定的分数之内删除所有成员的有序集合 ZREVRANGEZREVRANGE key start stop [WITHSCORES] 返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分 ZREVRANGEBYSCOREZREVRANGEBYSCORE key max min [WITHSCORES] 返回一个成员范围的有序集合，以socre排序从高到低 ZREVRANKZREVRANK key member 确定一个有序集合成员的索引，以分数排序，从高分到低分 ZSCOREZSCORE key member 获取给定成员相关联的分数在一个有序集合 ZUNIONSTOREZUNIONSTORE destination numkeys key [key …] 添加多个集排序，所得排序集合存储在一个新的键 ZSCANZSCAN key cursor [MATCH pattern] [COUNT count] 增量迭代排序元素集和相关的分数 **Redis过期策略:https://www.jb51.net/article/103236.htm 3.Redis运用实际开发中,经常会用到集合(list读取较快)来存储缓存数据,但是Redis只支持List,不能直接支持List,因此需要制作工具类来转换Json类型读写 导入POM 导入JsonUtils工具类(将Object/List &lt;Object &gt;转化为字符串) 导入Redis工具类接口/实现接口 导入配置文件spring-redis/redis.properties service中注入使用即可 注意spring的加载机制: 1Caused by: java.lang.IllegalArgumentException: Could not resolve placeholder &apos;USER_LIST&apos; in string value &quot;$&#123;USER_LIST&#125;&quot; Spring容器采用反射扫描的发现机制，在探测到Spring容器中有一个org.springframework.beans.factory.config.PropertyPlaceholderConfigurer的Bean就会停止对剩余PropertyPlaceholderConfigurer的扫描（Spring 3.1已经使用PropertySourcesPlaceholderConfigurer替代PropertyPlaceholderConfigurer了） 所以根据加载的顺序，配置的第二个property-placeholder就被没有被spring加载，我想引入的config-wxapp.properties就没有被引入，所以在使用@Value注入的时候占位符就解析不了…解决方法就是把2个property-placeholder注解配置合并在一起就好了","path":"2018/07/04/Redis基础原理/","date":"07-04","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/07/03/hello-world/","date":"07-03","excerpt":""},{"title":"GitHub 博客快速搭建","text":"GitHub 博客快速搭建[TOC] 环境:Win7 搭建流程 Node.js | Hexo | Next(themes) 基础 首先安装Node.js 注意Path指定位置(影响到balabala一些配置的存放的位置,默认C盘,建议改) Node.js安装好后,选择一个文件夹安装Hexo(此处为搭建Blog的位置) 将GitHub账号的博客地址添加到Hexo的配置文件中(根目录 _config.yml),并将部署方式改为Git(老版本是GitHub方式) 根据指令部署后即可完成基础的博客搭建,此时查看博客仓库是否上传了静态资源(如果上传了则代表搭建成功) 短暂的延迟后进入博客网页即可看到搭建的博客 写博客的方式–&gt;将编写的md文章放在posts下,然后 hexo g d 部署一下即可(每次方式用这个指令就可以上传文章了,文章会被自适应解析) 参考https://www.cnblogs.com/fengxiongZz/p/7707219.html 进阶 Hexo中的themes是主题设定的位置,可以选择主题,教程中选择Next的基础主题(没有追求可以凑合用( • ̀ω•́ )✧) themes中的(_config.yml)是主题的配置,里面可以根据提示做自己的简单配置,包括菜单的增减和修改,布局等等,如下 123456789# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: 根据教程和注释完成自己的布局即可 参考http://www.cnblogs.com/fengxiongZz/p/7707568.html 进阶加强 完成这些想玩点花的话可以去官网或者GitHub找喜欢的themes修改使用,教程百度一大堆( • ̀ω•́ )✧ 一大波官网主题:https://hexo.io/themes/ 第三方的插件口头整合 第三方登录(Github) 评论功能 站内搜索 站内统计 交互式背景 网易云播放器插件 将网站的所有图片通过url委托给第三方云图片服务器(七牛云存储10G免费) … 维护技巧 当不能保证在同一台电脑上传文章时,可以选择master分离的方式或者将博客部署在自己的远程服务器上","path":"2018/07/02/GitHub博客搭建/","date":"07-02","excerpt":""},{"title":"FreeMarker结合Nginx|FTP基础使用","text":"FreeMarker结合Nginx|FTP基础使用[TOC] 目前做页面模板引擎主流使用Thymeleaf(效率更高),本文主要介绍FreeMarker的相关知识 传送门:Thymeleaf基础原理https://blog.csdn.net/abap_brave/article/details/53009149 传送门:Thymeleaf快速使用https://blog.csdn.net/u014042066/article/details/75614906 1.FreeMarker1.介绍 FreeMarker是一个模板引擎,一个基于模板生成文件的通用工具,由纯java代码编写 FreeMarker不是一个Web框架,而是适合Web框架的一个组件 FreeMarker与容器无关,更加通用,而且免费 数值类型:| String | 数值(不区分浮点) | boolean | 日期 | 集合 |等大部分类型 2.使用 引入jar包 建立模板 进行输出 2.FTP结合1.介绍FTP连接分主动模式和被动模式 主动模式(port)使用N(发送数据) 和N+1(发送FTP命令)两个端口,一般20 21 固定端口,可能造成数据被拦截窃取 被动模式(pasv)使用21 和P&gt;1024所有端口 不固定大范围端口,可能造服务器服务器被攻击 解决方案分析:https://blog.csdn.net/u014774781/article/details/48376633 FTP传送门(待更新) 2.使用FreeMarker生成静态页面后,可以通过FTP发送到服务器指定的位置存放 3.Nginx结合1.介绍Nginx是一个Http服务器,可以将服务器上的静态文件通过Http协议展现给客户端 2.使用Nginx将FreeMarker发送来的静态页面以url的方式发送到客户端完成一套静态部署 Nginx传送门(待更新)","path":"2018/07/02/FreeMarker和Nginx_FTP原理使用/","date":"07-02","excerpt":""}]}