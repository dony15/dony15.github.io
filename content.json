{"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-05","excerpt":""},{"title":"categories","text":"暂无分类","path":"categories/index.html","date":"07-05","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"07-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-05","excerpt":""},{"title":"tags","text":"暂无标签哦","path":"tags/index.html","date":"07-05","excerpt":""}],"posts":[{"title":"","text":"title: Zookeeper与Dubbo基础原理date: 2018-07-08tags:categories: 框架 Zookeeper与Dubbo基础原理Zookeeper(RPC框架)高效的分布式分布式应用协调服务,提供注册和负载均衡等–&gt;服务中心 zookeeper让调用者知道调用的哪台服务器地址,也是集群的管理者 Zookeeper具有心跳检测机制,当服务器挂掉时可以让调用者知道,从而切换请求服务器 Zookeeper具有高并发的横向扩展,在不改变代码的情况下对设备进行扩展 1.命名服务 2.配置管理 3.集群管理 4.分布式锁 5.队列管理 命名服务:在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现。 配置管理:程序分散部署在多台机器上难以管理,可以将每台设备的信息存储在Zookeeper的目录节点中,然后相关程序对该目录进行监控,如果配置信息发生变化,则Zookeeper会发布新的配置 集群管理:(1)设备的加入(2)选举master(可以改变设备编号,编号第一位自动master(一种思路)) 分布式锁:zookeeper是一致性的文件系统,锁服务可以分为两类，(1)保持独占，(2)控制时序。 列队管理: 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。 队列按照 FIFO 方式进行入队和出队操作。和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。 特性 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。 可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。 原子性：更新只能成功或者失败，没有中间状态。 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。 Zookeeper工作原理​ Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态 ​ 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。 (部分整理) 原文:https://blog.csdn.net/xqb_756148978/article/details/52259381 Dubbo(SOA基础框架)管理中间层的框架,与注册中心搭配使用,如Zookeeper(最常用),使之具有Zookeeper负载均衡/资源同步等的特性 单一应用架构(ORM) –&gt;垂直应用架构(MVC)–&gt;分布式服务架构(RPC)–&gt;流动计算架构(SOA) 核心部分 远程通讯 集群容错 自动发现 作用 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点. 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 Dubbo采用全spring配置方式,透明化接入,应用,没有API入侵 架构 Provider: 暴露服务的服务提供方。 ​ Consumer: 调用远程服务的服务消费方。 ​ Registry: 服务注册与发现的注册中心。 ​ Monitor: 统计服务的调用次调和调用时间的监控中心. ​ Container]: 服务运行器。 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 收藏Dubbo架构详解http://shiyanjun.cn/archives/325.html","path":"2018/07/07/Zookeeper基础原理/","date":"07-07","excerpt":""},{"title":"FastDFS 基础原理","text":"FastDFS 基础原理深度优先搜索Depth First Search 无向图算法概念(一种递归原理) 先按照一条边进行搜索,当遇到第一个节点时,对它相邻的其他节点进行搜索并标记为已查找的节点(会查找完第一条节点的最深层后返回)详细见算法目录(持续更新) FastDFS–结构FastDFS 架构–结构 FastDFS服务有三个角色:跟踪服务器(tracker server)、存储服务器(storage server)和客户端(client) 主要解决了海量数据存储问题 ,特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。 跟踪器Tracker :主要做调度工作，相当于mvc中的controller的角色，在访问上起负载均衡的作用。跟踪器和存储节点都可以由一台或多台服务器构成，跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务，其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。 跟踪器Tracker负责管理所有的Storage和group，本身不需要持久化任何数据,直接增加机器就可以拓展tracker,每个Storage在启动后会连接Tracker，并周期性保持联系. 存储服务器Storage:以group为最小单位,方便实现 应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数）,建议同一group内的配置尽量相同,减少资源浪费(storage依赖于本地文件系统) 客户端Client:基本文件访问接口:比如upload、download、append、delete等，以客户端库的方式提供给用户使用。 FastDFS–运行tracker 当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个trakcer。 group 当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group，支持如下选择group的规则： Round robin，所有的group间轮询 Specified group，指定某一个确定的group Load balance，剩余存储空间多多group优先 storage 当选定group后，tracker会在group内选择一个storage server给客户端，支持如下选择storage的规则： Round robin，在group内的所有storage间轮询 First server ordered by ip，按ip排序 First server ordered by priority，按优先级排序（优先级在storage上配置） storage path 当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录，支持如下规则： Round robin，多个存储目录间轮询 剩余存储空间最多的优先 Fileid 选定存储目录之后，storage会为文件生一个Fileid，由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，然后将这个二进制串进行base64编码，转换为可打印的字符串。 选择两级目录 当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash（猜测），路由到其中一个子目录，然后将文件以fileid为文件名存储到该子目录下。 生成文件名 当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。 文件同步 写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至 [同group] 内其他的storage server。storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。 Download file 客户端upload file成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。 FastDFS–特点小文件合并存储解决问题: 本地文件系统inode数量有限，从而存储的小文件数量也就受到限制。 多级目录+目录里很多文件，导致访问文件的开销很大（可能导致很多次IO） 按小文件存储，备份与恢复的效率低 FastDFS在V3.0版本里引入小文件合并存储的机制，可将多个小文件存储到一个大的文件（trunk file），为了支持这个机制，FastDFS生成的文件fileid需要额外增加16个字节 HTTP访问支持客户端可以通过http协议来下载文件，tracker在接收到请求时，通过http的redirect机制将请求[重定向]至文件所在的storage上；除了内置的http协议外，FastDFS还提供了通过apache或nginx扩展模块下载文件的支持。 负载均衡group机制本身可用来做负载均衡，但这只是一种静态的负载均衡机制，需要预先知道应用的访问特性；同时group机制也导致不可能在group之间迁移数据来做动态负载均衡。 FastDFS–使用小结1.每次上传文件后都会返回一个地址，用户需要自己保存此地址。2.为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。 FastDFS原理系列文章(转发)https://blog.csdn.net/hfty290/article/details/42076205","path":"2018/07/06/FastDfs基础原理/","date":"07-06","excerpt":""},{"title":"Shiro基础原理","text":"Shiro基础原理1.简介shiro是apache的一个开源框架，实现 |认证|授权|为核心的一系列权限管理框架. Web 应用程序一般做法通过表单提交用户名及密码达到认证目的。 “授权”即是否允许已认证用户访问受保护资源。 2.对比Shiro与Spring Security 简单性:shiro更加简单,更容易理解 灵活性:shiro可以使用在 |Web|EJB|IoC| 等大部分的应用环境,而Spring Security必须和Spring一起集成使用 拔插性:shiro干净的API(工具类集合)和设计模式(单例+工厂)使它可以方便的和许多其他框架整合,Spring Security则只能与Spring一起集成 3.组成 三个核心组件 Subject: 令牌与项目的登录关系,Shiro保证了项目整体的安全性,是Shiro对外API的核心 Security Manager:负责安全认证预授权等 Shiro的核心 Realm:整个框架中必须由设计者自行实现的模块之一.并且Shiro支持多个Realm数据源,最为重要的一种实现方式—&gt;数据库查询,当需要多个数据库组合验证时,多个数据源的效果就体现出来 Authentication: 身份认证 Authorization: 授权,权限验证 Session Manager: 会话管理 Cryptography:加密 Web Support: web支持 Caching:缓存 Concurrency:多线程验证 Testing:提供测试支持 Run As:允许一个用户假装另一个用户访问 Remember Me: 记住我 注意:Shiro不会自己维护用户|权限; 需要开发者去 设计|提供 ; 然后通过接口注入给Shiro即可 4.源码Token认证JdbcRealm Shiro –&gt;JdbcRealm封装的固定sql [1.封装根据用户名查询密码的SQL语句] 1234/** * The default query used to retrieve account data for the user. */ protected static final String DEFAULT_AUTHENTICATION_QUERY = \"select password from users where username = ?\"; [2.盐加密&amp;&amp;authenticationQuery验证查询(判断)] 1234567891011/** * Sets the salt style. See &#123;@link #saltStyle&#125;. * * @param saltStyle new SaltStyle to set. */ public void setSaltStyle(SaltStyle saltStyle) &#123; this.saltStyle = saltStyle; if (saltStyle == SaltStyle.COLUMN &amp;&amp; authenticationQuery.equals(DEFAULT_AUTHENTICATION_QUERY)) &#123; authenticationQuery = DEFAULT_SALTED_AUTHENTICATION_QUERY; &#125; &#125; [3.发现源代码中使用预编译的原生JDBC,并根据索引查找对比,所以要求自定义语句时不能乱写,根据规则走] 12345678910111213141516171819202122232425PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(authenticationQuery); ps.setString(1, username); // Execute query rs = ps.executeQuery(); // Loop over results - although we are only expecting one result, since usernames should be unique boolean foundResult = false; while (rs.next()) &#123; // Check to ensure only one row is processed if (foundResult) &#123; throw new AuthenticationException(&quot;More than one user row found for user [&quot; + username + &quot;]. Usernames must be unique.&quot;); &#125; result[0] = rs.getString(1); //索引查询 if (returningSeparatedSalt) &#123; result[1] = rs.getString(2); &#125; foundResult = true; &#125; new SimpleAuthenticationInfo()(存放唯一认证) 源码分析 principal: 整个Shiro中唯一的标识符,可以存用户名,也可以存ID credentials: 唯一标识符的密码 realmName: 当前数据源的名字 1234public SimpleAuthenticationInfo(Object principal, Object credentials, String realmName) &#123; this.principals = new SimplePrincipalCollection(principal, realmName); this.credentials = credentials; &#125; 使用了工厂模式来对SecurityManager进行生成和配置 生成过程是使用单例+工厂 提供对外的工具类来使用，包含获取SecurityManager的方法和获取Subject的方法 (代码略) subject的使用是通过传入AuthenticationToken接口（注意是接口，其实扩展接口rememnverMeaut…和HostAutho…）， 该接口目前的实现类是UserPasswordToken，当然也可以自己扩展实现自定义的认证Token 测试加密算法盐值加密如果几个人密码一样，那么加密后的密码则一致。这样不安全，要解决这个问题，可以在密码上加盐。一般会选择不重复的值作为盐值，例如 用户名。(部分代码) 12345678//构造方法： //第一个参数：散列算法 //第二个参数：明文，原始密码 //第三个参数：盐，通过使用随机数 //第四个参数：散列的次数，比如散列两次，相当 于md5(md5('')) SimpleHash simpleHash = new SimpleHash(\"md5\", source, salt, hashIterations); String md5 = simpleHash.toString(); System.out.println(md5); 12345678910111213141516shiro-realm-md5.ini---------------------[main]定义凭证匹配器credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher散列算法credentialsMatcher.hashAlgorithmName=md5散列次数credentialsMatcher.hashIterations=1024开启加盐（无需设置，realm中使用的SimpleAuthenticationInfo 是 SaltedAuthenticationInfo 接口的实现类，默认开启的加盐功能）credentialsMatcher.hashSalted=true自定义 realmcustomRealm=com.qfedu.shirodemo.realm.CustomRealmMd5customRealm.credentialsMatcher=$credentialsMatcher将realm设置到securityManager，相当 于spring中注入securityManager.realms=$customRealm 授权流程原理授权 授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。 主体（Subject） 主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。 资源 在应用中用户可以访问的任何东西，比如JSP 页面、某些数据、某个业务方法等等都是资源。用户只要授权后才能访问。 权限 权限表示在应用中用户能不能访问某个资源， 如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）打印文档等等。。。 角色 角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。 典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。 判断是否授权的方式Shiro 支持三种方式的授权判断： 编程式 通过写if/else 授权代码块完成： Subject subject = SecurityUtils.getSubject(); if(subject.hasRole(“admin”)) { ​ //有权限 } else { ​ //无权限 } 注解式 通过在执行的Java方法上放置相应的注解完成： @RequiresRoles(“admin”) public void hello() { //有权限 } 没有权限将抛出相应的异常； JSP 标签 在JSP 页面通过相应的标签完成： 12345&lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;!— 有权限—&gt;&lt; /shiro:hasRole &gt; 自定义realm授权从认证的realm拷贝，改变继承的抽象父类，添加新的方法 5.程序分析程序分析：从应用程序角度的来观察如何使用Shiro完成工作 应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager； 我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。 可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject； Shiro内部结构 详细原理深入和运用:http://jinnianshilongnian.iteye.com/blog/2018398 6.Shiro使用技巧整理工具类接口的使用建立一个工具类接口Constants,以常量字符串的方式,专门存放Shiro中自定义的标识符 12345678910public interface Constants &#123; // md5(用户密码+PASSWORD_SALT_KEY)保存到数据库中。 String PASSWORD_SALT_KEY = &quot;Shiro.admin.2017&quot;; //Shiro的session中存放用户的key String SESSION_USER_KEY = &quot;SESSION_USER_KEY&quot;; //redis中存放的用户权限菜单的key String SESSION_USER_MANU = &quot;SESSION_USER_MANU&quot;; //Shiro存放的角色信息 String SESSION_USER_ROLE = &quot;SESSION_USER_ROLE&quot;;&#125; 接口工具类的思路不仅限于Shiro,灵活的定义接口,将冗余和容易混淆的部分抽离出来统一管理,可以极大的提高开发和维护的效率 ..shiro.xml 拦截器设置Shiro主过滤器本身功能十分强大,其强大之处就在于它支持任何基于URL路径表达式的、自定义的过滤器的执行 /login.html=anon 静态资源的方式屏蔽过滤器 /**=authc 该路径下需要认证才能访问 … 过滤器的完整参考： http://blog.csdn.net/jadyer/article/details/12172839 登录认证使用原理 配置好环境和工具类 自定义Realm和异常 service中添加通过用户名查找用户信息 在Controller层认证登录 UsernamePasswordToken token = new UsernamePasswordToken(name, password); Subject subject = SecurityUtils.getSubject(); ubject.login(token); 将真正的验证交给封装的底层–&gt;AuthenticationToken实现.(自定义Realm中) 通过此时token的username去数据库查询用户信息 用户信息存在,则存入SimpleAuthenticationInfo,否则 抛出用户对应的异常 Shiro的分布式认证结构(shiro认证将账号密码的比较环节封装到AuthenticationToken中) ​ Realm放在Controller(保留意见)中,在分布式中Controller使用Dubbo服务端接口,而dubbo接口通过service实现类来发布,这个角度看realm与dao隔层交互设计不太合理 ​ 验证成功则返回SimpleAuthenticationInfo(存放唯一标识(id或者username),密码,Realm名","path":"2018/07/04/Shiro基础原理/","date":"07-04","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/07/03/hello-world/","date":"07-03","excerpt":""}]}