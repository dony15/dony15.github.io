{"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-05","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-05","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"07-05","excerpt":""},{"title":"tags","text":"暂无标签哦","path":"tags/index.html","date":"07-05","excerpt":""},{"title":"categories","text":"暂无分类","path":"categories/index.html","date":"07-05","excerpt":""}],"posts":[{"title":"基础排序 组合","text":"规范:()中,先写下,在写上 1.排序转换为计算机写法A(n,m) n在下 m在上 ​ 即:n个数中取m个来排序 2.组合转换为计算机写法C(n,m) n在下 m在上 ​ 即: 分子:n的阶乘,阶乘的个数为m ​ 分母:m的阶乘","path":"2018/07/08/基础排序 组合/","date":"07-08","excerpt":""},{"title":"Zookeeper与Dubbo基础原理","text":"Zookeeper与Dubbo基础原理Zookeeper(RPC框架)高效的分布式分布式应用协调服务,提供注册和负载均衡等–&gt;服务中心 zookeeper让调用者知道调用的哪台服务器地址,也是集群的管理者 Zookeeper具有心跳检测机制,当服务器挂掉时可以让调用者知道,从而切换请求服务器 Zookeeper具有高并发的横向扩展,在不改变代码的情况下对设备进行扩展 1.命名服务 2.配置管理 3.集群管理 4.分布式锁 5.队列管理 命名服务:在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现。 配置管理:程序分散部署在多台机器上难以管理,可以将每台设备的信息存储在Zookeeper的目录节点中,然后相关程序对该目录进行监控,如果配置信息发生变化,则Zookeeper会发布新的配置 集群管理:(1)设备的加入(2)选举master(可以改变设备编号,编号第一位自动master(一种思路)) 分布式锁:zookeeper是一致性的文件系统,锁服务可以分为两类，(1)保持独占，(2)控制时序。 列队管理: 同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。 队列按照 FIFO 方式进行入队和出队操作。和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。 特性 最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。 可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。 实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。 等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。 原子性：更新只能成功或者失败，没有中间状态。 顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。 Zookeeper工作原理​ Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态 ​ 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。 (部分整理) 原文:https://blog.csdn.net/xqb_756148978/article/details/52259381 Dubbo(SOA基础框架)管理中间层的框架,与注册中心搭配使用,如Zookeeper(最常用),使之具有Zookeeper负载均衡/资源同步等的特性 单一应用架构(ORM) –&gt;垂直应用架构(MVC)–&gt;分布式服务架构(RPC)–&gt;流动计算架构(SOA) 核心部分 远程通讯 集群容错 自动发现 作用 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点. 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 Dubbo采用全spring配置方式,透明化接入,应用,没有API入侵 架构 Provider: 暴露服务的服务提供方。 ​ Consumer: 调用远程服务的服务消费方。 ​ Registry: 服务注册与发现的注册中心。 ​ Monitor: 统计服务的调用次调和调用时间的监控中心. ​ Container]: 服务运行器。 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 收藏Dubbo架构详解http://shiyanjun.cn/archives/325.html","path":"2018/07/08/Zookeeper基础原理/","date":"07-08","excerpt":""},{"title":"实用工具类集合","text":"实用工具类集合简述 该工具类集合章会持续更新,具体工具类会集成到我的GitHub仓库中 传送门 https://github.com/dony15/mymodes 1.js-utils.js常用js的前段封装 XMLHttpRequest 原生ajax的获取 ,内置了Chrome和IE的兼容转换 图片上传功能前段,四个id解决 | 图片 | 表单 | 回显 | 的结合 验证码显示和输入框校验 两个id 一个url 即可解决 | 校验 | 提示 | 提交url |的结合 点击切换验证码 id和url 2.pattern.js包含开发中各种验证常用的正则封装 2.CollectionsFactory包含各种集合类型的构建,静态工具类,使代码看起来更加规范简洁 3.DownloadUtil文件下载工具类,根据文件名或者文件路径获取文件进行下载(多场景的封装) 3.FileUtil非常实用的文件处理工具,如获取文件名/去重/清空但不删除文件夹/磁盘遍历/xml生成等等… 4.FormatStyle文件容量单位的格式转换,主要解决特殊情况下因为数字太大导致java直接写无法识别的 5.IDUtilsID的多种生成策略 5.JsonUtils使用jackson,多种类型和json的转化封装 对象 | List 6.ResourcesUtil资源读取工具类,较为特殊,使用较少(主要是国际语言的匹配读取,现在前段控制即可) 7.UtilFuns该工具类非常的丰富.各种SE的基础转换和时间/固定长度转换/编码解码等都有涉猎 其他中文命名工具类不再解释(简单明了)","path":"2018/07/08/实用工具类集合/","date":"07-08","excerpt":""},{"title":"工具类集合分析--接口","text":"工具类集合分析–接口1.概述使用接口作为工具类,一般分两种情况 ​ (1)定义常量 ​ (2)定义动态工具类 2.分析1.定义常量可以在工具类中快捷明了的定义常量来使用,因为接口中默认属性便是常量,如: ​ int HOTEL_STATUS_INVALID=0;//酒店失效 ​ int HOTEL_STATUS_VALID=1;//酒店有效 当controller中往前端传递数据时,需要判断状态,而状态从controller中多次定义会导致观察不变,不利于交接和后期维护,此时便可以将状态抽出来存进接口工具类中,提高代码的可读性和开发效率 (RestFull开发风格中,提高代码可读性尤为突出) 2.定义动态工具类当程序运行在不同的环境中时,因为程序对环境的耦合性,频繁的修改代码会大大降低开发效率,可以使用工具类接口的方式,将耦合性降低,如动态工具类 场景 ​ redis 单机版和集群版 (可以根据需要选择具体的方案,减少代码的修改量) ​","path":"2018/07/08/工具类集合分析--接口/","date":"07-08","excerpt":""},{"title":"Solr基础原理","text":"Solr基础原理1.目录核心组成1.core ​ solr的索引库,可以理解为数据库,需要手动创建(文件夹),core可以根据需要建立多个索引库,索引库的内容可以在后台看到也可以在core中看到 2.solrhome ​ solr的配置目录,solr服务器所有的配置文件存放的目录(core创建在solrhome中) 3.collection ​ solr的逻辑索引(逻辑意义上的完整索引),由多个shard的组成,每个shard又由一个leadereplica和多个replica,每个replica都是物理索引,即每个replica都对应着一个core,collection本质是可以跨越多个核的索引,包含冗余的索引. 参考https://blog.csdn.net/zhousenshan/article/details/51799567 2.配置详解1.配置中文分词 ​ &lt;!– default values for query parameters can be specified, these ​ will be overridden by parameters in the request ​ –&gt; ​ ​ explicit ​ item_keywords ​ 10 ​ ​ explicit ​ json ​ true ​ item_keywords ​ 2.配置Solr Dataimport ​ ​ data-config.xml ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ 3.Solr后台的使用第一次先Dataimport–&gt;Execute导入,然后Refresh刷新状态即可 Query:查询功能 ​ q ; –&gt;第一个 表示字段; 第二个 表示字段的内容; ​ 如 item_keywords:北京 分词中有”北京”关键字的内容 ​ item_price:[* TO 200] 价格是200以内的内容 ​ item_price:[100 TO 700] 价格是100-200的内容 3.java中的作用建立一个新的索引模块 index,接口层和实现发布层 写Solr更新和搜索两个方法dubbo发布即可在controller中使用 (一般与MQ一起使用,如activeMQ,见activeMQ基础与运用章节)","path":"2018/07/06/Solr基础原理/","date":"07-06","excerpt":""},{"title":"ActiveMQ基础与运用","text":"ActiveMQ基础与运用1.概念消息队列:即时消息通信和延时消息通信 ActiveMQ底层基于java的JMS实现,在没有JMS之前的系统存在很多缺陷: 前后端同步问题,如果后台没有响应,则前段会一直阻塞等待 前后端生命周期耦合性太强,一方崩了则另一方也会崩 点对点通信,前段一次只能发送给某一个单独的服务对象,无法群发 JMS: (Java Message Service ) 通过消息中间件(MOM：Message Oriented Middleware ) 将消息发送给单独的消息服务器中,消息服务器会将消息存放在若干的队列/主题中,在合适的时候将消息发送给接收者.发送和接收是异步的,无需阻塞等待 在pub/sub的模式下,可以将消息发送给多个接收者 JMS类中定义了java访问中间件的接口,除此之外都是异常定义 Provider/MessageProvider：生产者 Consumer/MessageConsumer：消费者 PTP：Point To Point，点对点通信消息模型 Pub/Sub：Publish/Subscribe，发布订阅消息模型 Queue：队列，目标类型之一，和PTP结合 Topic：主题，目标类型之一，和Pub/Sub结合 ConnectionFactory：连接工厂，JMS用它创建连接 Connnection：JMS Client到JMS Provider的连接 Destination：消息目的地，由Session创建 Session：会话，由Connection创建，实质上就是发送、接受消息的一个线程，因此生产者、消费者都是Session创建的 2.应用| 异步处理 | 应用解耦 | 流量削锋 | 消息通讯 | 详情参考:https://blog.csdn.net/kingcat666/article/details/78660535 3.消息模式 P2P模式(点对点) Pub/Sub模式(发布订阅) Push模式(推拉模式,消息更新C/S中) 4.java中与Solr结合ActiveMQ以监视器的方式将信息与Solr结合使用…待更新","path":"2018/07/06/activeMQ基础与运用/","date":"07-06","excerpt":""},{"title":"FastDFS 基础原理","text":"FastDFS 基础原理深度优先搜索Depth First Search 无向图算法概念(一种递归原理) 先按照一条边进行搜索,当遇到第一个节点时,对它相邻的其他节点进行搜索并标记为已查找的节点(会查找完第一条节点的最深层后返回)详细见算法目录(持续更新) FastDFS–结构FastDFS 架构–结构 FastDFS服务有三个角色:跟踪服务器(tracker server)、存储服务器(storage server)和客户端(client) 主要解决了海量数据存储问题 ,特别适合以中小文件（建议范围：4KB &lt; file_size &lt;500MB）为载体的在线服务。 跟踪器Tracker :主要做调度工作，相当于mvc中的controller的角色，在访问上起负载均衡的作用。跟踪器和存储节点都可以由一台或多台服务器构成，跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务，其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。 跟踪器Tracker负责管理所有的Storage和group，本身不需要持久化任何数据,直接增加机器就可以拓展tracker,每个Storage在启动后会连接Tracker，并周期性保持联系. 存储服务器Storage:以group为最小单位,方便实现 应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数）,建议同一group内的配置尽量相同,减少资源浪费(storage依赖于本地文件系统) 客户端Client:基本文件访问接口:比如upload、download、append、delete等，以客户端库的方式提供给用户使用。 FastDFS–运行tracker 当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个trakcer。 group 当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group，支持如下选择group的规则： Round robin，所有的group间轮询 Specified group，指定某一个确定的group Load balance，剩余存储空间多多group优先 storage 当选定group后，tracker会在group内选择一个storage server给客户端，支持如下选择storage的规则： Round robin，在group内的所有storage间轮询 First server ordered by ip，按ip排序 First server ordered by priority，按优先级排序（优先级在storage上配置） storage path 当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录，支持如下规则： Round robin，多个存储目录间轮询 剩余存储空间最多的优先 Fileid 选定存储目录之后，storage会为文件生一个Fileid，由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，然后将这个二进制串进行base64编码，转换为可打印的字符串。 选择两级目录 当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash（猜测），路由到其中一个子目录，然后将文件以fileid为文件名存储到该子目录下。 生成文件名 当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。 文件同步 写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至 [同group] 内其他的storage server。storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。 Download file 客户端upload file成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。 FastDFS–特点小文件合并存储解决问题: 本地文件系统inode数量有限，从而存储的小文件数量也就受到限制。 多级目录+目录里很多文件，导致访问文件的开销很大（可能导致很多次IO） 按小文件存储，备份与恢复的效率低 FastDFS在V3.0版本里引入小文件合并存储的机制，可将多个小文件存储到一个大的文件（trunk file），为了支持这个机制，FastDFS生成的文件fileid需要额外增加16个字节 HTTP访问支持客户端可以通过http协议来下载文件，tracker在接收到请求时，通过http的redirect机制将请求[重定向]至文件所在的storage上；除了内置的http协议外，FastDFS还提供了通过apache或nginx扩展模块下载文件的支持。 负载均衡group机制本身可用来做负载均衡，但这只是一种静态的负载均衡机制，需要预先知道应用的访问特性；同时group机制也导致不可能在group之间迁移数据来做动态负载均衡。 FastDFS–使用小结 分别配置Tracker地址(上传存储使用)和Storage地址(响应回显使用) 接收前段file文件后,将名字拆分重塑后存储 响应url则拼接Storage地址生成 每次上传文件后都会返回一个地址，用户需要自己保存此地址。 前段设计:将整个编辑内容存进一个由事件控制的表单,当图片上传的时候不会影响到表单的完整性,而且可以依靠上传时间来动态生成回显方案,将url放进input中,清除不必要的组件(可能影响表单提交完整性的部分) 为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。 注意:spring-mvc中除了要配置上传解析器之外,还需要将String的字符串指定为UTF-8(默认8859-1) FastDFS原理系列文章(转发)https://blog.csdn.net/hfty290/article/details/42076205","path":"2018/07/06/FastDfs基础原理/","date":"07-06","excerpt":""},{"title":"Redis基础原理","text":"Redis基础原理1.概念NoSQL 非关系型数据库,Redis是非关系型数据库中的键值存储数据库 应用 处理高并发/海量数据的访问,内容缓存 优点 快速查询,支持横向扩充(集群)和纵向扩充(加强设备) 一主多从,读写分离 哨兵机制,检测选举 集群机制,多主多从,数据高可用,分布式存储 缺点 ​ 存储缺少结构化(难以构建关系型理数据库模型) 2.数据类型String最简单的KV存储,value可以是String也可以是数字等 场景 kv字符串结构等,非常普遍 指令 ​ SET key value 设置key=value ​ GET key 或者键key对应的值 ​ GETRANGE key start end 得到字符串的子字符串存放在一个键 ​ GETSET key value 设置键的字符串值，并返回旧值 ​ GETBIT key offset 返回存储在键位值的字符串值的偏移 ​ MGET key1 [key2..] 得到所有的给定键的值 ​ SETBIT key offset value 设置或清除该位在存储在键的字符串值偏移 ​ SETEX key seconds value 键到期时设置值 ​ SETNX key value 设置键的值，只有当该键不存在 ​ SETRANGE key offset value 覆盖字符串的一部分从指定键的偏移 ​ STRLEN key 得到存储在键的值的长度 ​ MSET key value [key value…] 设置多个键和多个值 ​ MSETNX key value [key value…] 设置多个键多个值，只有在当没有按键的存在时 ​ PSETEX key milliseconds value 设置键的毫秒值和到期时间 ​ INCR key 增加键的整数值一次 INCRBY key increment 由给定的数量递增键的整数值 ​ INCRBYFLOAT key increment 由给定的数量递增键的浮点值 ​ DECR key 递减键一次的整数值 ​ DECRBY key decrement 由给定数目递减键的整数值 ​ APPEND key value 追加值到一个键 ​ ——–操作管理———- DEL key 如果存在删除键 DUMP key 返回存储在指定键的值的序列化版本 EXISTS key 此命令检查该键是否存在 EXPIRE key seconds 指定键的过期时间 EXPIREAT key timestamp 指定的键过期时间。在这里，时间是在Unix时间戳格式 PEXPIRE key milliseconds 设置键以毫秒为单位到期 PEXPIREAT key milliseconds-timestamp 设置键在Unix时间戳指定为毫秒到期 KEYS pattern 查找与指定模式匹配的所有键 MOVE key db 移动键到另一个数据库 PERSIST key 移除过期的键 PTTL key 以毫秒为单位获取剩余时间的到期键。 TTL key 获取键到期的剩余时间。 RANDOMKEY 从Redis返回随机键 RENAME key newkey 更改键的名称 RENAMENX key newkey 重命名键，如果新的键不存在 TYPE key 返回存储在键的数据类型的值。 List(列表)字符串列表,非常重要的Redis类型,本质是双向链表,支持反向查询和遍历,更加方便,但是会额外增加内存开销(存储双向链表),redis内部的发送缓冲队列使用的就是List结构 场景 如twitter的关注列表和粉丝列表,实现轻量级的消息队列等 指令 BLPOPBLPOP key1 [key2 ] timeout 取出并获取列表中的第一个元素，或阻塞，直到有可用 BRPOPBRPOP key1 [key2 ] timeout 取出并获取列表中的最后一个元素，或阻塞，直到有可用 BRPOPLPUSHBRPOPLPUSH source destination timeout 从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用 LINDEXLINDEX key index 从一个列表其索引获取对应的元素 LINSERTLINSERT key BEFORE|AFTER pivot value 在列表中的其他元素之后或之前插入一个元素 LLENLLEN key 获取列表的长度 LPOPLPOP key 获取并取出列表中的第一个元素 LPUSHLPUSH key value1 [value2] 在前面加上一个或多个值的列表 LPUSHXLPUSHX key value 在前面加上一个值列表，仅当列表中存在 LRANGELRANGE key start stop 从一个列表获取各种元素 LREMLREM key count value 从列表中删除元素 LSETLSET key index value 在列表中的索引设置一个元素的值 LTRIMLTRIM key start stop 修剪列表到指定的范围内 RPOPRPOP key 取出并获取列表中的最后一个元素 RPOPLPUSHRPOPLPUSH source destination 删除最后一个元素的列表，将其附加到另一个列表并返回它 RPUSHRPUSH key value1 [value2] 添加一个或多个值到列表 RPUSHXRPUSHX key value 添加一个值列表，仅当列表中存在 HashRedis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。 场景 可以方便的存储用户信息,用户ID为Key,用户信息序列化为value存储 指令 HDELHDEL key field[field…] 删除对象的一个或几个属性域，不存在的属性将被忽略 HEXISTSHEXISTS key field 查看对象是否存在该属性域 HGETHGET key field 获取对象中该field属性域的值 HGETALLHGETALL key 获取对象的所有属性域和值 HINCRBYHINCRBY key field value 将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用 HINCRBYFLOATHINCRBYFLOAT key field increment 将该对象中指定域的值增加给定的浮点数 HKEYSHKEYS key 获取对象的所有属性字段 HVALSHVALS key 获取对象的所有属性值 HLENHLEN key 获取对象的所有属性字段的总数 HMGETHMGET key field[field…] 获取对象的一个或多个指定字段的值 HSETHSET key field value 设置对象指定字段的值 HMSETHMSET key field value [field value …] 同时设置对象中一个或多个字段的值 HSETNXHSETNX key field value 只在对象不存在指定的字段时才设置字段的值 HSTRLENHSTRLEN key field 返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0. HSCANHSCAN key cursor [MATCH pattern] [COUNT count] 类似SCAN命令 Set存储数据不重复,set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 场景 set和list的功能类似,但是set加载的列表自动排重,当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 指令 SADDSADD key member [member …] 添加一个或者多个元素到集合(set)里 SACRDSCARD key 获取集合里面的元素数量 SDIFFSDIFF key [key …] 获得队列不存在的元素 SDIFFSTORESDIFFSTORE destination key [key …] 获得队列不存在的元素，并存储在一个关键的结果集 SINTERSINTER key [key …] 获得两个集合的交集 SINTERSTORESINTERSTORE destination key [key …] 获得两个集合的交集，并存储在一个集合中 SISMEMBERSISMEMBER key member 确定一个给定的值是一个集合的成员 SMEMBERSSMEMBERS key 获取集合里面的所有key SMOVESMOVE source destination member 移动集合里面的一个key到另一个集合 SPOPSPOP key [count] 获取并删除一个集合里面的元素 SRANDMEMBERSRANDMEMBER key [count] 从集合里面随机获取一个元素 SREMSREM key member [member …] 从集合里删除一个或多个元素，不存在的元素会被忽略 SUNIONSUNION key [key …] 添加多个set元素 SUNIONSTORESUNIONSTORE destination key [key …] 合并set元素，并将结果存入新的set里面 SSCANSSCAN key cursor [MATCH pattern][COUNT count] 迭代set里面的元素 Sorted Setset的有序版,由HaspMap和跳跃表组成 场景 用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列。 指令 ZADDZADD key score1 member1 [score2 member2] 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数 ZCARDZCARD key 得到的有序集合成员的数量 ZCOUNTZCOUNT key min max 计算一个有序集合成员与给定值范围内的分数 ZINCRBYZINCRBY key increment member 在有序集合增加成员的分数 ZINTERSTOREZINTERSTORE destination numkeys key [key …] 多重交叉排序集合，并存储生成一个新的键有序集合。 ZLEXCOUNTZLEXCOUNT key min max 计算一个给定的字典范围之间的有序集合成员的数量 ZRANGEZRANGE key start stop [WITHSCORES] 由索引返回一个成员范围的有序集合（从低到高） ZRANGEBYLEXZRANGEBYLEX key min max [LIMIT offset count]返回一个成员范围的有序集合（由字典范围） ZRANGEBYSCOREZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列 ZRANKZRANK key member 确定成员的索引中有序集合 ZREMZREM key member [member …] 从有序集合中删除一个或多个成员，不存在的成员将被忽略 ZREMRANGEBYLEXZREMRANGEBYLEX key min max 删除所有成员在给定的字典范围之间的有序集合 ZREMRANGEBYRANKZREMRANGEBYRANK key start stop 在给定的索引之内删除所有成员的有序集合 ZREMRANGEBYSCOREZREMRANGEBYSCORE key min max 在给定的分数之内删除所有成员的有序集合 ZREVRANGEZREVRANGE key start stop [WITHSCORES] 返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分 ZREVRANGEBYSCOREZREVRANGEBYSCORE key max min [WITHSCORES] 返回一个成员范围的有序集合，以socre排序从高到低 ZREVRANKZREVRANK key member 确定一个有序集合成员的索引，以分数排序，从高分到低分 ZSCOREZSCORE key member 获取给定成员相关联的分数在一个有序集合 ZUNIONSTOREZUNIONSTORE destination numkeys key [key …] 添加多个集排序，所得排序集合存储在一个新的键 ZSCANZSCAN key cursor [MATCH pattern] [COUNT count] 增量迭代排序元素集和相关的分数 Redis过期策略:https://www.jb51.net/article/103236.htm","path":"2018/07/04/Redis基础原理/","date":"07-04","excerpt":""},{"title":"Shiro基础原理","text":"Shiro基础原理1.简介shiro是apache的一个开源框架，实现 |认证|授权|为核心的一系列权限管理框架. Web 应用程序一般做法通过表单提交用户名及密码达到认证目的。 “授权”即是否允许已认证用户访问受保护资源。 2.对比Shiro与Spring Security 简单性:shiro更加简单,更容易理解 灵活性:shiro可以使用在 |Web|EJB|IoC| 等大部分的应用环境,而Spring Security必须和Spring一起集成使用 拔插性:shiro干净的API(工具类集合)和设计模式(单例+工厂)使它可以方便的和许多其他框架整合,Spring Security则只能与Spring一起集成 3.组成 三个核心组件 Subject: 令牌与项目的登录关系,Shiro保证了项目整体的安全性,是Shiro对外API的核心 Security Manager:负责安全认证预授权等 Shiro的核心 Realm:整个框架中必须由设计者自行实现的模块之一.并且Shiro支持多个Realm数据源,最为重要的一种实现方式—&gt;数据库查询,当需要多个数据库组合验证时,多个数据源的效果就体现出来 Authentication: 身份认证 Authorization: 授权,权限验证 Session Manager: 会话管理 Cryptography:加密 Web Support: web支持 Caching:缓存 Concurrency:多线程验证 Testing:提供测试支持 Run As:允许一个用户假装另一个用户访问 Remember Me: 记住我 注意:Shiro不会自己维护用户|权限; 需要开发者去 设计|提供 ; 然后通过接口注入给Shiro即可 4.源码Token认证JdbcRealm Shiro –&gt;JdbcRealm封装的固定sql [1.封装根据用户名查询密码的SQL语句] 1234/** * The default query used to retrieve account data for the user. */ protected static final String DEFAULT_AUTHENTICATION_QUERY = \"select password from users where username = ?\"; [2.盐加密&amp;&amp;authenticationQuery验证查询(判断)] 1234567891011/** * Sets the salt style. See &#123;@link #saltStyle&#125;. * * @param saltStyle new SaltStyle to set. */ public void setSaltStyle(SaltStyle saltStyle) &#123; this.saltStyle = saltStyle; if (saltStyle == SaltStyle.COLUMN &amp;&amp; authenticationQuery.equals(DEFAULT_AUTHENTICATION_QUERY)) &#123; authenticationQuery = DEFAULT_SALTED_AUTHENTICATION_QUERY; &#125; &#125; [3.发现源代码中使用预编译的原生JDBC,并根据索引查找对比,所以要求自定义语句时不能乱写,根据规则走] 12345678910111213141516171819202122232425PreparedStatement ps = null; ResultSet rs = null; try &#123; ps = conn.prepareStatement(authenticationQuery); ps.setString(1, username); // Execute query rs = ps.executeQuery(); // Loop over results - although we are only expecting one result, since usernames should be unique boolean foundResult = false; while (rs.next()) &#123; // Check to ensure only one row is processed if (foundResult) &#123; throw new AuthenticationException(&quot;More than one user row found for user [&quot; + username + &quot;]. Usernames must be unique.&quot;); &#125; result[0] = rs.getString(1); //索引查询 if (returningSeparatedSalt) &#123; result[1] = rs.getString(2); &#125; foundResult = true; &#125; new SimpleAuthenticationInfo()(存放唯一认证) 源码分析 principal: 整个Shiro中唯一的标识符,可以存用户名,也可以存ID credentials: 唯一标识符的密码 realmName: 当前数据源的名字 1234public SimpleAuthenticationInfo(Object principal, Object credentials, String realmName) &#123; this.principals = new SimplePrincipalCollection(principal, realmName); this.credentials = credentials; &#125; 使用了工厂模式来对SecurityManager进行生成和配置 生成过程是使用单例+工厂 提供对外的工具类来使用，包含获取SecurityManager的方法和获取Subject的方法 (代码略) subject的使用是通过传入AuthenticationToken接口（注意是接口，其实扩展接口rememnverMeaut…和HostAutho…）， 该接口目前的实现类是UserPasswordToken，当然也可以自己扩展实现自定义的认证Token 测试加密算法盐值加密如果几个人密码一样，那么加密后的密码则一致。这样不安全，要解决这个问题，可以在密码上加盐。一般会选择不重复的值作为盐值，例如 用户名。(部分代码) 12345678//构造方法： //第一个参数：散列算法 //第二个参数：明文，原始密码 //第三个参数：盐，通过使用随机数 //第四个参数：散列的次数，比如散列两次，相当 于md5(md5('')) SimpleHash simpleHash = new SimpleHash(\"md5\", source, salt, hashIterations); String md5 = simpleHash.toString(); System.out.println(md5); 12345678910111213141516shiro-realm-md5.ini---------------------[main]定义凭证匹配器credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher散列算法credentialsMatcher.hashAlgorithmName=md5散列次数credentialsMatcher.hashIterations=1024开启加盐（无需设置，realm中使用的SimpleAuthenticationInfo 是 SaltedAuthenticationInfo 接口的实现类，默认开启的加盐功能）credentialsMatcher.hashSalted=true自定义 realmcustomRealm=com.qfedu.shirodemo.realm.CustomRealmMd5customRealm.credentialsMatcher=$credentialsMatcher将realm设置到securityManager，相当 于spring中注入securityManager.realms=$customRealm 授权流程原理授权 授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。 主体（Subject） 主体，即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。 资源 在应用中用户可以访问的任何东西，比如JSP 页面、某些数据、某个业务方法等等都是资源。用户只要授权后才能访问。 权限 权限表示在应用中用户能不能访问某个资源， 如：访问用户列表页面查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）打印文档等等。。。 角色 角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。 典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。 判断是否授权的方式Shiro 支持三种方式的授权判断： 编程式 通过写if/else 授权代码块完成： Subject subject = SecurityUtils.getSubject(); if(subject.hasRole(“admin”)) { ​ //有权限 } else { ​ //无权限 } 注解式 通过在执行的Java方法上放置相应的注解完成： @RequiresRoles(“admin”) public void hello() { //有权限 } 没有权限将抛出相应的异常； JSP 标签 在JSP 页面通过相应的标签完成： 12345&lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;!— 有权限—&gt;&lt; /shiro:hasRole &gt; 自定义realm授权从认证的realm拷贝，改变继承的抽象父类，添加新的方法 5.程序分析程序分析：从应用程序角度的来观察如何使用Shiro完成工作 应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager； 我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。 可以看到：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject； Shiro内部结构 详细原理深入和运用:http://jinnianshilongnian.iteye.com/blog/2018398 6.Shiro认证技巧整理工具类接口的使用建立一个工具类接口Constants,以常量字符串的方式,专门存放Shiro中自定义的标识符 12345678910public interface Constants &#123; // md5(用户密码+PASSWORD_SALT_KEY)保存到数据库中。 String PASSWORD_SALT_KEY = &quot;Shiro.admin.2017&quot;; //Shiro的session中存放用户的key String SESSION_USER_KEY = &quot;SESSION_USER_KEY&quot;; //redis中存放的用户权限菜单的key String SESSION_USER_MANU = &quot;SESSION_USER_MANU&quot;; //Shiro存放的角色信息 String SESSION_USER_ROLE = &quot;SESSION_USER_ROLE&quot;;&#125; 接口工具类的思路不仅限于Shiro,灵活的定义接口,将冗余和容易混淆的部分抽离出来统一管理,可以极大的提高开发和维护的效率 认证优化技巧Controller层登录方法中,接收到用户名和密码后先进行 1234Subject currentUser = SecurityUtils.getSubject();if (!currentUser.isAuthenticated()) &#123; ...认证&#125; 直接获取subject,先进性判断该用户是否认证过,如果认证过则直接跳出即可 如果没有认证过,再进入认证环节 该逻辑可以减少服务器和数据库的压力,提高服务器的并发能力 ..shiro.xml 拦截器设置Shiro主过滤器本身功能十分强大,其强大之处就在于它支持任何基于URL路径表达式的、自定义的过滤器的执行 /login.html=anon 静态资源的方式屏蔽过滤器 /**=authc 该路径下需要认证才能访问 … 过滤器的完整参考： http://blog.csdn.net/jadyer/article/details/12172839 登录认证使用原理动态权限控制 RBAC（Role-Based Access Control ）基于角色的访问控制 配置好环境和工具类 自定义Realm和异常 service中添加通过用户名查找用户信息 在Controller层认证登录 UsernamePasswordToken token = new UsernamePasswordToken(name, password); Subject subject = SecurityUtils.getSubject(); ubject.login(token); 将真正的验证交给封装的底层–&gt;AuthenticationToken实现.(自定义Realm中) 通过此时token的username去数据库查询用户信息 用户信息存在,则存入SimpleAuthenticationInfo,否则 抛出用户对应的异常 Shiro的分布式认证结构(shiro认证将账号密码的比较环节封装到AuthenticationToken中) ​ Realm放在Controller中,在分布式中Controller使用Dubbo服务端接口,而dubbo接口通过service实现类来发布,这个角度看realm与dao隔层交互设计不太合理 ​ 验证成功则返回SimpleAuthenticationInfo(存放唯一标识(id或者username),密码,Realm名 7.Shiro授权技巧整理 通过用户登录的唯一标识principals 查找到用户有哪些菜单权限(ID) 将这些ID存到SimpleAuthorizationInfo中 在自定义ShiroFilterFactoryBean中获取所有菜单列表,并将id加入到section中 底层自动对比,哪些ID用户有,则允许访问,没有的话”authc”拦截","path":"2018/07/04/Shiro基础原理/","date":"07-04","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/07/03/hello-world/","date":"07-03","excerpt":""},{"title":"GitHub 博客快速搭建","text":"GitHub 博客快速搭建环境:Win7 搭建流程 Node.js | Hexo | Next(themes) 基础 首先安装Node.js 注意Path指定位置(影响到balabala一些配置的存放的位置,默认C盘,建议改) Node.js安装好后,选择一个文件夹安装Hexo(此处为搭建Blog的位置) 将GitHub账号的博客地址添加到Hexo的配置文件中(根目录 _config.yml),并将部署方式改为Git(老版本是GitHub方式) 根据指令部署后即可完成基础的博客搭建,此时查看博客仓库是否上传了静态资源(如果上传了则代表搭建成功) 短暂的延迟后进入博客网页即可看到搭建的博客 写博客的方式–&gt;将编写的md文章放在posts下,然后 hexo g d 部署一下即可(每次方式用这个指令就可以上传文章了,文章会被自适应解析) 参考https://www.cnblogs.com/fengxiongZz/p/7707219.html 进阶 Hexo中的themes是主题设定的位置,可以选择主题,教程中选择Next的基础主题(没有追求可以凑合用( • ̀ω•́ )✧) themes中的(_config.yml)是主题的配置,里面可以根据提示做自己的简单配置,包括菜单的增减和修改,布局等等,如下 123456789# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: 根据教程和注释完成自己的布局即可 参考http://www.cnblogs.com/fengxiongZz/p/7707568.html 进阶加强 完成这些想玩点花的话可以去官网或者GitHub找喜欢的themes修改使用,教程百度一大堆( • ̀ω•́ )✧ 一大波官网主题:https://hexo.io/themes/ 第三方的插件口头整合 第三方登录(Github) 评论功能 站内搜索 站内统计 交互式背景 网易云播放器插件 将网站的所有图片通过url委托给第三方云图片服务器(七牛云存储10G免费) … 维护技巧 当不能保证在同一台电脑上传文章时,可以选择master分离的方式或者将博客部署在自己的远程服务器上","path":"2018/07/02/GitHub博客搭建/","date":"07-02","excerpt":""}]}